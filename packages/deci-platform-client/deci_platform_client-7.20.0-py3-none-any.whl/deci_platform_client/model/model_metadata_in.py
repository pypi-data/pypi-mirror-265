# coding: utf-8

"""
    Deci Platform API

    Train, deploy, optimize and serve your models using Deci's platform, in your cloud or on premise.  # noqa: E501

    The version of the OpenAPI document: 4.0.0
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from deci_platform_client import schemas  # noqa: F401


class ModelMetadataIn(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    A base class for all of Deci's model classes.
A model stores data in constant fields, and let us manipulate the data in a more readable way.
    """


    class MetaOapg:
        required = {
            "primaryHardware",
            "dlTask",
            "framework",
            "name",
        }
        
        class properties:
            name = schemas.StrSchema
            
            
            class framework(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            FrameworkType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'framework':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            dlTask = schemas.StrSchema
            primaryHardware = schemas.StrSchema
            updateTime = schemas.DateTimeSchema
            creationTime = schemas.DateTimeSchema
            id = schemas.UUIDSchema
            deleted = schemas.BoolSchema
            modelId = schemas.UUIDSchema
            owner = schemas.UUIDSchema
            version = schemas.StrSchema
            modelSize = schemas.NumberSchema
            
            
            class source(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            ModelSource,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'source':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class quantizationLevel(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            QuantizationLevel,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'quantizationLevel':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            platformVersion = schemas.StrSchema
            
            
            class inputDimensions(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.AnyTypeSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'inputDimensions':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            channelFirst = schemas.BoolSchema
            
            
            class fetchedModelInputDimensions(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.AnyTypeSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'fetchedModelInputDimensions':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class datasetName(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            DatasetName,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'datasetName':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            architecture = schemas.StrSchema
            primaryBatchSize = schemas.IntSchema
            
            
            class benchmarkState(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            ModelBenchmarkState,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'benchmarkState':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            benchmarkStartDate = schemas.DateTimeSchema
            benchmarkEndDate = schemas.DateTimeSchema
            
            
            class benchmark(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class additional_properties(
                        schemas.ListSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @staticmethod
                            def items() -> typing.Type['ModelBenchmarkResultMetadata']:
                                return ModelBenchmarkResultMetadata
                    
                        def __new__(
                            cls,
                            _arg: typing.Union[typing.Tuple['ModelBenchmarkResultMetadata'], typing.List['ModelBenchmarkResultMetadata']],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'additional_properties':
                            return super().__new__(
                                cls,
                                _arg,
                                _configuration=_configuration,
                            )
                    
                        def __getitem__(self, i: int) -> 'ModelBenchmarkResultMetadata':
                            return super().__getitem__(i)
                
                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                    return super().get_item_oapg(name)
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[MetaOapg.additional_properties, list, tuple, ],
                ) -> 'benchmark':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class optimizationState(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            ModelOptimizationState,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'optimizationState':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            optimizationStartDate = schemas.DateTimeSchema
            optimizationEndDate = schemas.DateTimeSchema
            
            
            class gruState(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            ModelGruState,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'gruState':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            gruStartDate = schemas.DateTimeSchema
            gruEndDate = schemas.DateTimeSchema
            
            
            class inputTensorName(
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    max_length = 100
            
            
            class outputTensorName(
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    max_length = 100
            description = schemas.StrSchema
            
            
            class tags(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.StrSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'tags':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class kpis(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['KPI']:
                        return KPI
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['KPI'], typing.List['KPI']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'kpis':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'KPI':
                    return super().__getitem__(i)
            
            
            class accuracyMetrics(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['AccuracyMetric']:
                        return AccuracyMetric
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['AccuracyMetric'], typing.List['AccuracyMetric']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'accuracyMetrics':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'AccuracyMetric':
                    return super().__getitem__(i)
            
            
            class hyperParameters(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['HyperParameter']:
                        return HyperParameter
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['HyperParameter'], typing.List['HyperParameter']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'hyperParameters':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'HyperParameter':
                    return super().__getitem__(i)
            rawFormat = schemas.BoolSchema
            
            
            class companyName(
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    max_length = 100
                    min_length = 1
            companyId = schemas.UUIDSchema
            workspaceId = schemas.UUIDSchema
            baselineModelId = schemas.UUIDSchema
            
            
            class error(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            ModelErrorRecord,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'error':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            customHardware = schemas.StrSchema
            colabLink = schemas.StrSchema
            isInt8Calibrated = schemas.BoolSchema
            __annotations__ = {
                "name": name,
                "framework": framework,
                "dlTask": dlTask,
                "primaryHardware": primaryHardware,
                "updateTime": updateTime,
                "creationTime": creationTime,
                "id": id,
                "deleted": deleted,
                "modelId": modelId,
                "owner": owner,
                "version": version,
                "modelSize": modelSize,
                "source": source,
                "quantizationLevel": quantizationLevel,
                "platformVersion": platformVersion,
                "inputDimensions": inputDimensions,
                "channelFirst": channelFirst,
                "fetchedModelInputDimensions": fetchedModelInputDimensions,
                "datasetName": datasetName,
                "architecture": architecture,
                "primaryBatchSize": primaryBatchSize,
                "benchmarkState": benchmarkState,
                "benchmarkStartDate": benchmarkStartDate,
                "benchmarkEndDate": benchmarkEndDate,
                "benchmark": benchmark,
                "optimizationState": optimizationState,
                "optimizationStartDate": optimizationStartDate,
                "optimizationEndDate": optimizationEndDate,
                "gruState": gruState,
                "gruStartDate": gruStartDate,
                "gruEndDate": gruEndDate,
                "inputTensorName": inputTensorName,
                "outputTensorName": outputTensorName,
                "description": description,
                "tags": tags,
                "kpis": kpis,
                "accuracyMetrics": accuracyMetrics,
                "hyperParameters": hyperParameters,
                "rawFormat": rawFormat,
                "companyName": companyName,
                "companyId": companyId,
                "workspaceId": workspaceId,
                "baselineModelId": baselineModelId,
                "error": error,
                "customHardware": customHardware,
                "colabLink": colabLink,
                "isInt8Calibrated": isInt8Calibrated,
            }
    
    primaryHardware: MetaOapg.properties.primaryHardware
    dlTask: MetaOapg.properties.dlTask
    framework: MetaOapg.properties.framework
    name: MetaOapg.properties.name
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["framework"]) -> MetaOapg.properties.framework: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dlTask"]) -> MetaOapg.properties.dlTask: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["primaryHardware"]) -> MetaOapg.properties.primaryHardware: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["updateTime"]) -> MetaOapg.properties.updateTime: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["creationTime"]) -> MetaOapg.properties.creationTime: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["deleted"]) -> MetaOapg.properties.deleted: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["modelId"]) -> MetaOapg.properties.modelId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["owner"]) -> MetaOapg.properties.owner: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["version"]) -> MetaOapg.properties.version: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["modelSize"]) -> MetaOapg.properties.modelSize: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["quantizationLevel"]) -> MetaOapg.properties.quantizationLevel: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["platformVersion"]) -> MetaOapg.properties.platformVersion: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["inputDimensions"]) -> MetaOapg.properties.inputDimensions: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["channelFirst"]) -> MetaOapg.properties.channelFirst: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["fetchedModelInputDimensions"]) -> MetaOapg.properties.fetchedModelInputDimensions: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["datasetName"]) -> MetaOapg.properties.datasetName: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["architecture"]) -> MetaOapg.properties.architecture: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["primaryBatchSize"]) -> MetaOapg.properties.primaryBatchSize: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["benchmarkState"]) -> MetaOapg.properties.benchmarkState: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["benchmarkStartDate"]) -> MetaOapg.properties.benchmarkStartDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["benchmarkEndDate"]) -> MetaOapg.properties.benchmarkEndDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["benchmark"]) -> MetaOapg.properties.benchmark: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["optimizationState"]) -> MetaOapg.properties.optimizationState: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["optimizationStartDate"]) -> MetaOapg.properties.optimizationStartDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["optimizationEndDate"]) -> MetaOapg.properties.optimizationEndDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["gruState"]) -> MetaOapg.properties.gruState: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["gruStartDate"]) -> MetaOapg.properties.gruStartDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["gruEndDate"]) -> MetaOapg.properties.gruEndDate: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["inputTensorName"]) -> MetaOapg.properties.inputTensorName: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["outputTensorName"]) -> MetaOapg.properties.outputTensorName: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["tags"]) -> MetaOapg.properties.tags: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["kpis"]) -> MetaOapg.properties.kpis: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["accuracyMetrics"]) -> MetaOapg.properties.accuracyMetrics: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["hyperParameters"]) -> MetaOapg.properties.hyperParameters: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["rawFormat"]) -> MetaOapg.properties.rawFormat: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["companyName"]) -> MetaOapg.properties.companyName: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["companyId"]) -> MetaOapg.properties.companyId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["workspaceId"]) -> MetaOapg.properties.workspaceId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["baselineModelId"]) -> MetaOapg.properties.baselineModelId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["error"]) -> MetaOapg.properties.error: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["customHardware"]) -> MetaOapg.properties.customHardware: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["colabLink"]) -> MetaOapg.properties.colabLink: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["isInt8Calibrated"]) -> MetaOapg.properties.isInt8Calibrated: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "framework", "dlTask", "primaryHardware", "updateTime", "creationTime", "id", "deleted", "modelId", "owner", "version", "modelSize", "source", "quantizationLevel", "platformVersion", "inputDimensions", "channelFirst", "fetchedModelInputDimensions", "datasetName", "architecture", "primaryBatchSize", "benchmarkState", "benchmarkStartDate", "benchmarkEndDate", "benchmark", "optimizationState", "optimizationStartDate", "optimizationEndDate", "gruState", "gruStartDate", "gruEndDate", "inputTensorName", "outputTensorName", "description", "tags", "kpis", "accuracyMetrics", "hyperParameters", "rawFormat", "companyName", "companyId", "workspaceId", "baselineModelId", "error", "customHardware", "colabLink", "isInt8Calibrated", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["framework"]) -> MetaOapg.properties.framework: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dlTask"]) -> MetaOapg.properties.dlTask: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["primaryHardware"]) -> MetaOapg.properties.primaryHardware: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["updateTime"]) -> typing.Union[MetaOapg.properties.updateTime, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["creationTime"]) -> typing.Union[MetaOapg.properties.creationTime, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["deleted"]) -> typing.Union[MetaOapg.properties.deleted, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["modelId"]) -> typing.Union[MetaOapg.properties.modelId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["owner"]) -> typing.Union[MetaOapg.properties.owner, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["version"]) -> typing.Union[MetaOapg.properties.version, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["modelSize"]) -> typing.Union[MetaOapg.properties.modelSize, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["quantizationLevel"]) -> typing.Union[MetaOapg.properties.quantizationLevel, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["platformVersion"]) -> typing.Union[MetaOapg.properties.platformVersion, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["inputDimensions"]) -> typing.Union[MetaOapg.properties.inputDimensions, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["channelFirst"]) -> typing.Union[MetaOapg.properties.channelFirst, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["fetchedModelInputDimensions"]) -> typing.Union[MetaOapg.properties.fetchedModelInputDimensions, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["datasetName"]) -> typing.Union[MetaOapg.properties.datasetName, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["architecture"]) -> typing.Union[MetaOapg.properties.architecture, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["primaryBatchSize"]) -> typing.Union[MetaOapg.properties.primaryBatchSize, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["benchmarkState"]) -> typing.Union[MetaOapg.properties.benchmarkState, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["benchmarkStartDate"]) -> typing.Union[MetaOapg.properties.benchmarkStartDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["benchmarkEndDate"]) -> typing.Union[MetaOapg.properties.benchmarkEndDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["benchmark"]) -> typing.Union[MetaOapg.properties.benchmark, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["optimizationState"]) -> typing.Union[MetaOapg.properties.optimizationState, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["optimizationStartDate"]) -> typing.Union[MetaOapg.properties.optimizationStartDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["optimizationEndDate"]) -> typing.Union[MetaOapg.properties.optimizationEndDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["gruState"]) -> typing.Union[MetaOapg.properties.gruState, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["gruStartDate"]) -> typing.Union[MetaOapg.properties.gruStartDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["gruEndDate"]) -> typing.Union[MetaOapg.properties.gruEndDate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["inputTensorName"]) -> typing.Union[MetaOapg.properties.inputTensorName, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["outputTensorName"]) -> typing.Union[MetaOapg.properties.outputTensorName, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["tags"]) -> typing.Union[MetaOapg.properties.tags, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["kpis"]) -> typing.Union[MetaOapg.properties.kpis, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["accuracyMetrics"]) -> typing.Union[MetaOapg.properties.accuracyMetrics, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["hyperParameters"]) -> typing.Union[MetaOapg.properties.hyperParameters, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["rawFormat"]) -> typing.Union[MetaOapg.properties.rawFormat, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["companyName"]) -> typing.Union[MetaOapg.properties.companyName, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["companyId"]) -> typing.Union[MetaOapg.properties.companyId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["workspaceId"]) -> typing.Union[MetaOapg.properties.workspaceId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["baselineModelId"]) -> typing.Union[MetaOapg.properties.baselineModelId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["error"]) -> typing.Union[MetaOapg.properties.error, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["customHardware"]) -> typing.Union[MetaOapg.properties.customHardware, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["colabLink"]) -> typing.Union[MetaOapg.properties.colabLink, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["isInt8Calibrated"]) -> typing.Union[MetaOapg.properties.isInt8Calibrated, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "framework", "dlTask", "primaryHardware", "updateTime", "creationTime", "id", "deleted", "modelId", "owner", "version", "modelSize", "source", "quantizationLevel", "platformVersion", "inputDimensions", "channelFirst", "fetchedModelInputDimensions", "datasetName", "architecture", "primaryBatchSize", "benchmarkState", "benchmarkStartDate", "benchmarkEndDate", "benchmark", "optimizationState", "optimizationStartDate", "optimizationEndDate", "gruState", "gruStartDate", "gruEndDate", "inputTensorName", "outputTensorName", "description", "tags", "kpis", "accuracyMetrics", "hyperParameters", "rawFormat", "companyName", "companyId", "workspaceId", "baselineModelId", "error", "customHardware", "colabLink", "isInt8Calibrated", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        primaryHardware: typing.Union[MetaOapg.properties.primaryHardware, str, ],
        dlTask: typing.Union[MetaOapg.properties.dlTask, str, ],
        framework: typing.Union[MetaOapg.properties.framework, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        name: typing.Union[MetaOapg.properties.name, str, ],
        updateTime: typing.Union[MetaOapg.properties.updateTime, str, datetime, schemas.Unset] = schemas.unset,
        creationTime: typing.Union[MetaOapg.properties.creationTime, str, datetime, schemas.Unset] = schemas.unset,
        id: typing.Union[MetaOapg.properties.id, str, uuid.UUID, schemas.Unset] = schemas.unset,
        deleted: typing.Union[MetaOapg.properties.deleted, bool, schemas.Unset] = schemas.unset,
        modelId: typing.Union[MetaOapg.properties.modelId, str, uuid.UUID, schemas.Unset] = schemas.unset,
        owner: typing.Union[MetaOapg.properties.owner, str, uuid.UUID, schemas.Unset] = schemas.unset,
        version: typing.Union[MetaOapg.properties.version, str, schemas.Unset] = schemas.unset,
        modelSize: typing.Union[MetaOapg.properties.modelSize, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        source: typing.Union[MetaOapg.properties.source, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        quantizationLevel: typing.Union[MetaOapg.properties.quantizationLevel, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        platformVersion: typing.Union[MetaOapg.properties.platformVersion, str, schemas.Unset] = schemas.unset,
        inputDimensions: typing.Union[MetaOapg.properties.inputDimensions, list, tuple, schemas.Unset] = schemas.unset,
        channelFirst: typing.Union[MetaOapg.properties.channelFirst, bool, schemas.Unset] = schemas.unset,
        fetchedModelInputDimensions: typing.Union[MetaOapg.properties.fetchedModelInputDimensions, list, tuple, schemas.Unset] = schemas.unset,
        datasetName: typing.Union[MetaOapg.properties.datasetName, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        architecture: typing.Union[MetaOapg.properties.architecture, str, schemas.Unset] = schemas.unset,
        primaryBatchSize: typing.Union[MetaOapg.properties.primaryBatchSize, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        benchmarkState: typing.Union[MetaOapg.properties.benchmarkState, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        benchmarkStartDate: typing.Union[MetaOapg.properties.benchmarkStartDate, str, datetime, schemas.Unset] = schemas.unset,
        benchmarkEndDate: typing.Union[MetaOapg.properties.benchmarkEndDate, str, datetime, schemas.Unset] = schemas.unset,
        benchmark: typing.Union[MetaOapg.properties.benchmark, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        optimizationState: typing.Union[MetaOapg.properties.optimizationState, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        optimizationStartDate: typing.Union[MetaOapg.properties.optimizationStartDate, str, datetime, schemas.Unset] = schemas.unset,
        optimizationEndDate: typing.Union[MetaOapg.properties.optimizationEndDate, str, datetime, schemas.Unset] = schemas.unset,
        gruState: typing.Union[MetaOapg.properties.gruState, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        gruStartDate: typing.Union[MetaOapg.properties.gruStartDate, str, datetime, schemas.Unset] = schemas.unset,
        gruEndDate: typing.Union[MetaOapg.properties.gruEndDate, str, datetime, schemas.Unset] = schemas.unset,
        inputTensorName: typing.Union[MetaOapg.properties.inputTensorName, str, schemas.Unset] = schemas.unset,
        outputTensorName: typing.Union[MetaOapg.properties.outputTensorName, str, schemas.Unset] = schemas.unset,
        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
        tags: typing.Union[MetaOapg.properties.tags, list, tuple, schemas.Unset] = schemas.unset,
        kpis: typing.Union[MetaOapg.properties.kpis, list, tuple, schemas.Unset] = schemas.unset,
        accuracyMetrics: typing.Union[MetaOapg.properties.accuracyMetrics, list, tuple, schemas.Unset] = schemas.unset,
        hyperParameters: typing.Union[MetaOapg.properties.hyperParameters, list, tuple, schemas.Unset] = schemas.unset,
        rawFormat: typing.Union[MetaOapg.properties.rawFormat, bool, schemas.Unset] = schemas.unset,
        companyName: typing.Union[MetaOapg.properties.companyName, str, schemas.Unset] = schemas.unset,
        companyId: typing.Union[MetaOapg.properties.companyId, str, uuid.UUID, schemas.Unset] = schemas.unset,
        workspaceId: typing.Union[MetaOapg.properties.workspaceId, str, uuid.UUID, schemas.Unset] = schemas.unset,
        baselineModelId: typing.Union[MetaOapg.properties.baselineModelId, str, uuid.UUID, schemas.Unset] = schemas.unset,
        error: typing.Union[MetaOapg.properties.error, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        customHardware: typing.Union[MetaOapg.properties.customHardware, str, schemas.Unset] = schemas.unset,
        colabLink: typing.Union[MetaOapg.properties.colabLink, str, schemas.Unset] = schemas.unset,
        isInt8Calibrated: typing.Union[MetaOapg.properties.isInt8Calibrated, bool, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'ModelMetadataIn':
        return super().__new__(
            cls,
            *_args,
            primaryHardware=primaryHardware,
            dlTask=dlTask,
            framework=framework,
            name=name,
            updateTime=updateTime,
            creationTime=creationTime,
            id=id,
            deleted=deleted,
            modelId=modelId,
            owner=owner,
            version=version,
            modelSize=modelSize,
            source=source,
            quantizationLevel=quantizationLevel,
            platformVersion=platformVersion,
            inputDimensions=inputDimensions,
            channelFirst=channelFirst,
            fetchedModelInputDimensions=fetchedModelInputDimensions,
            datasetName=datasetName,
            architecture=architecture,
            primaryBatchSize=primaryBatchSize,
            benchmarkState=benchmarkState,
            benchmarkStartDate=benchmarkStartDate,
            benchmarkEndDate=benchmarkEndDate,
            benchmark=benchmark,
            optimizationState=optimizationState,
            optimizationStartDate=optimizationStartDate,
            optimizationEndDate=optimizationEndDate,
            gruState=gruState,
            gruStartDate=gruStartDate,
            gruEndDate=gruEndDate,
            inputTensorName=inputTensorName,
            outputTensorName=outputTensorName,
            description=description,
            tags=tags,
            kpis=kpis,
            accuracyMetrics=accuracyMetrics,
            hyperParameters=hyperParameters,
            rawFormat=rawFormat,
            companyName=companyName,
            companyId=companyId,
            workspaceId=workspaceId,
            baselineModelId=baselineModelId,
            error=error,
            customHardware=customHardware,
            colabLink=colabLink,
            isInt8Calibrated=isInt8Calibrated,
            _configuration=_configuration,
            **kwargs,
        )

from deci_platform_client.model.accuracy_metric import AccuracyMetric
from deci_platform_client.model.dataset_name import DatasetName
from deci_platform_client.model.framework_type import FrameworkType
from deci_platform_client.model.hyper_parameter import HyperParameter
from deci_platform_client.model.kpi import KPI
from deci_platform_client.model.model_benchmark_result_metadata import ModelBenchmarkResultMetadata
from deci_platform_client.model.model_benchmark_state import ModelBenchmarkState
from deci_platform_client.model.model_error_record import ModelErrorRecord
from deci_platform_client.model.model_gru_state import ModelGruState
from deci_platform_client.model.model_optimization_state import ModelOptimizationState
from deci_platform_client.model.model_source import ModelSource
from deci_platform_client.model.quantization_level import QuantizationLevel
