# coding: utf-8

"""
    Civitai Orchestration Consumer API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from civitai.models.generic_parameter_attributes import GenericParameterAttributes
from civitai.models.member_types import MemberTypes
from civitai.models.runtime_type_handle import RuntimeTypeHandle
from civitai.models.struct_layout_attribute import StructLayoutAttribute
from civitai.models.type_attributes import TypeAttributes
from typing import Optional, Set
from typing_extensions import Self


class Type(BaseModel):
    """
from civitai_py.models.assembly import Assembly
from civitai_py.models.module import Module
from civitai_py.models.method_base import MethodBase
from civitai_py.models.custom_attribute_data import CustomAttributeData
from civitai_py.models.constructor_info import ConstructorInfo
    Type
    """  # noqa: E501
    name: Optional[StrictStr] = None
    custom_attributes: Optional[List[CustomAttributeData]
                                ] = Field(default=None, alias="customAttributes")
    is_collectible: Optional[StrictBool] = Field(default=None, alias="isCollectible")
    metadata_token: Optional[StrictInt] = Field(default=None, alias="metadataToken")
    is_interface: Optional[StrictBool] = Field(default=None, alias="isInterface")
    member_type: Optional[MemberTypes] = Field(default=None, alias="memberType")
    namespace: Optional[StrictStr] = None
    assembly_qualified_name: Optional[StrictStr] = Field(
        default=None, alias="assemblyQualifiedName")
    full_name: Optional[StrictStr] = Field(default=None, alias="fullName")
    assembly: Optional[Assembly] = None
    module: Optional[Module] = None
    is_nested: Optional[StrictBool] = Field(default=None, alias="isNested")
    declaring_type: Optional[Type] = Field(default=None, alias="declaringType")
    declaring_method: Optional[MethodBase] = Field(default=None, alias="declaringMethod")
    reflected_type: Optional[Type] = Field(default=None, alias="reflectedType")
    underlying_system_type: Optional[Type] = Field(default=None, alias="underlyingSystemType")
    is_type_definition: Optional[StrictBool] = Field(default=None, alias="isTypeDefinition")
    is_array: Optional[StrictBool] = Field(default=None, alias="isArray")
    is_by_ref: Optional[StrictBool] = Field(default=None, alias="isByRef")
    is_pointer: Optional[StrictBool] = Field(default=None, alias="isPointer")
    is_constructed_generic_type: Optional[StrictBool] = Field(
        default=None, alias="isConstructedGenericType")
    is_generic_parameter: Optional[StrictBool] = Field(default=None, alias="isGenericParameter")
    is_generic_type_parameter: Optional[StrictBool] = Field(
        default=None, alias="isGenericTypeParameter")
    is_generic_method_parameter: Optional[StrictBool] = Field(
        default=None, alias="isGenericMethodParameter")
    is_generic_type: Optional[StrictBool] = Field(default=None, alias="isGenericType")
    is_generic_type_definition: Optional[StrictBool] = Field(
        default=None, alias="isGenericTypeDefinition")
    is_sz_array: Optional[StrictBool] = Field(default=None, alias="isSZArray")
    is_variable_bound_array: Optional[StrictBool] = Field(
        default=None, alias="isVariableBoundArray")
    is_by_ref_like: Optional[StrictBool] = Field(default=None, alias="isByRefLike")
    is_function_pointer: Optional[StrictBool] = Field(default=None, alias="isFunctionPointer")
    is_unmanaged_function_pointer: Optional[StrictBool] = Field(
        default=None, alias="isUnmanagedFunctionPointer")
    has_element_type: Optional[StrictBool] = Field(default=None, alias="hasElementType")
    generic_type_arguments: Optional[List[Type]] = Field(
        default=None, alias="genericTypeArguments")
    generic_parameter_position: Optional[StrictInt] = Field(
        default=None, alias="genericParameterPosition")
    generic_parameter_attributes: Optional[GenericParameterAttributes] = Field(
        default=None, alias="genericParameterAttributes")
    attributes: Optional[TypeAttributes] = None
    is_abstract: Optional[StrictBool] = Field(default=None, alias="isAbstract")
    is_import: Optional[StrictBool] = Field(default=None, alias="isImport")
    is_sealed: Optional[StrictBool] = Field(default=None, alias="isSealed")
    is_special_name: Optional[StrictBool] = Field(default=None, alias="isSpecialName")
    is_class: Optional[StrictBool] = Field(default=None, alias="isClass")
    is_nested_assembly: Optional[StrictBool] = Field(default=None, alias="isNestedAssembly")
    is_nested_fam_and_assem: Optional[StrictBool] = Field(
        default=None, alias="isNestedFamANDAssem")
    is_nested_family: Optional[StrictBool] = Field(default=None, alias="isNestedFamily")
    is_nested_fam_or_assem: Optional[StrictBool] = Field(default=None, alias="isNestedFamORAssem")
    is_nested_private: Optional[StrictBool] = Field(default=None, alias="isNestedPrivate")
    is_nested_public: Optional[StrictBool] = Field(default=None, alias="isNestedPublic")
    is_not_public: Optional[StrictBool] = Field(default=None, alias="isNotPublic")
    is_public: Optional[StrictBool] = Field(default=None, alias="isPublic")
    is_auto_layout: Optional[StrictBool] = Field(default=None, alias="isAutoLayout")
    is_explicit_layout: Optional[StrictBool] = Field(default=None, alias="isExplicitLayout")
    is_layout_sequential: Optional[StrictBool] = Field(default=None, alias="isLayoutSequential")
    is_ansi_class: Optional[StrictBool] = Field(default=None, alias="isAnsiClass")
    is_auto_class: Optional[StrictBool] = Field(default=None, alias="isAutoClass")
    is_unicode_class: Optional[StrictBool] = Field(default=None, alias="isUnicodeClass")
    is_com_object: Optional[StrictBool] = Field(default=None, alias="isCOMObject")
    is_contextful: Optional[StrictBool] = Field(default=None, alias="isContextful")
    is_enum: Optional[StrictBool] = Field(default=None, alias="isEnum")
    is_marshal_by_ref: Optional[StrictBool] = Field(default=None, alias="isMarshalByRef")
    is_primitive: Optional[StrictBool] = Field(default=None, alias="isPrimitive")
    is_value_type: Optional[StrictBool] = Field(default=None, alias="isValueType")
    is_signature_type: Optional[StrictBool] = Field(default=None, alias="isSignatureType")
    is_security_critical: Optional[StrictBool] = Field(default=None, alias="isSecurityCritical")
    is_security_safe_critical: Optional[StrictBool] = Field(
        default=None, alias="isSecuritySafeCritical")
    is_security_transparent: Optional[StrictBool] = Field(
        default=None, alias="isSecurityTransparent")
    struct_layout_attribute: Optional[StructLayoutAttribute] = Field(
        default=None, alias="structLayoutAttribute")
    type_initializer: Optional[ConstructorInfo] = Field(default=None, alias="typeInitializer")
    type_handle: Optional[RuntimeTypeHandle] = Field(default=None, alias="typeHandle")
    guid: Optional[StrictStr] = None
    base_type: Optional[Type] = Field(default=None, alias="baseType")
    contains_generic_parameters: Optional[StrictBool] = Field(
        default=None, alias="containsGenericParameters")
    is_visible: Optional[StrictBool] = Field(default=None, alias="isVisible")
    __properties: ClassVar[List[str]] = ["name", "customAttributes", "isCollectible", "metadataToken", "isInterface", "memberType", "namespace", "assemblyQualifiedName", "fullName", "assembly", "module", "isNested", "declaringType", "declaringMethod", "reflectedType", "underlyingSystemType", "isTypeDefinition", "isArray", "isByRef", "isPointer", "isConstructedGenericType", "isGenericParameter", "isGenericTypeParameter", "isGenericMethodParameter", "isGenericType", "isGenericTypeDefinition", "isSZArray", "isVariableBoundArray", "isByRefLike", "isFunctionPointer", "isUnmanagedFunctionPointer", "hasElementType", "genericTypeArguments", "genericParameterPosition",
                                         "genericParameterAttributes", "attributes", "isAbstract", "isImport", "isSealed", "isSpecialName", "isClass", "isNestedAssembly", "isNestedFamANDAssem", "isNestedFamily", "isNestedFamORAssem", "isNestedPrivate", "isNestedPublic", "isNotPublic", "isPublic", "isAutoLayout", "isExplicitLayout", "isLayoutSequential", "isAnsiClass", "isAutoClass", "isUnicodeClass", "isCOMObject", "isContextful", "isEnum", "isMarshalByRef", "isPrimitive", "isValueType", "isSignatureType", "isSecurityCritical", "isSecuritySafeCritical", "isSecurityTransparent", "structLayoutAttribute", "typeInitializer", "typeHandle", "guid", "baseType", "containsGenericParameters", "isVisible"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Type from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "name",
            "custom_attributes",
            "is_collectible",
            "metadata_token",
            "is_interface",
            "namespace",
            "assembly_qualified_name",
            "full_name",
            "is_nested",
            "is_type_definition",
            "is_array",
            "is_by_ref",
            "is_pointer",
            "is_constructed_generic_type",
            "is_generic_parameter",
            "is_generic_type_parameter",
            "is_generic_method_parameter",
            "is_generic_type",
            "is_generic_type_definition",
            "is_sz_array",
            "is_variable_bound_array",
            "is_by_ref_like",
            "is_function_pointer",
            "is_unmanaged_function_pointer",
            "has_element_type",
            "generic_type_arguments",
            "generic_parameter_position",
            "is_abstract",
            "is_import",
            "is_sealed",
            "is_special_name",
            "is_class",
            "is_nested_assembly",
            "is_nested_fam_and_assem",
            "is_nested_family",
            "is_nested_fam_or_assem",
            "is_nested_private",
            "is_nested_public",
            "is_not_public",
            "is_public",
            "is_auto_layout",
            "is_explicit_layout",
            "is_layout_sequential",
            "is_ansi_class",
            "is_auto_class",
            "is_unicode_class",
            "is_com_object",
            "is_contextful",
            "is_enum",
            "is_marshal_by_ref",
            "is_primitive",
            "is_value_type",
            "is_signature_type",
            "is_security_critical",
            "is_security_safe_critical",
            "is_security_transparent",
            "guid",
            "contains_generic_parameters",
            "is_visible",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in custom_attributes (list)
        _items = []
        if self.custom_attributes:
            for _item in self.custom_attributes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['customAttributes'] = _items
        # override the default output from pydantic by calling `to_dict()` of assembly
        if self.assembly:
            _dict['assembly'] = self.assembly.to_dict()
        # override the default output from pydantic by calling `to_dict()` of module
        if self.module:
            _dict['module'] = self.module.to_dict()
        # override the default output from pydantic by calling `to_dict()` of declaring_type
        if self.declaring_type:
            _dict['declaringType'] = self.declaring_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of declaring_method
        if self.declaring_method:
            _dict['declaringMethod'] = self.declaring_method.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reflected_type
        if self.reflected_type:
            _dict['reflectedType'] = self.reflected_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of underlying_system_type
        if self.underlying_system_type:
            _dict['underlyingSystemType'] = self.underlying_system_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in generic_type_arguments (list)
        _items = []
        if self.generic_type_arguments:
            for _item in self.generic_type_arguments:
                if _item:
                    _items.append(_item.to_dict())
            _dict['genericTypeArguments'] = _items
        # override the default output from pydantic by calling `to_dict()` of struct_layout_attribute
        if self.struct_layout_attribute:
            _dict['structLayoutAttribute'] = self.struct_layout_attribute.to_dict()
        # override the default output from pydantic by calling `to_dict()` of type_initializer
        if self.type_initializer:
            _dict['typeInitializer'] = self.type_initializer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of type_handle
        if self.type_handle:
            _dict['typeHandle'] = self.type_handle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of base_type
        if self.base_type:
            _dict['baseType'] = self.base_type.to_dict()
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if custom_attributes (nullable) is None
        # and model_fields_set contains the field
        if self.custom_attributes is None and "custom_attributes" in self.model_fields_set:
            _dict['customAttributes'] = None

        # set to None if namespace (nullable) is None
        # and model_fields_set contains the field
        if self.namespace is None and "namespace" in self.model_fields_set:
            _dict['namespace'] = None

        # set to None if assembly_qualified_name (nullable) is None
        # and model_fields_set contains the field
        if self.assembly_qualified_name is None and "assembly_qualified_name" in self.model_fields_set:
            _dict['assemblyQualifiedName'] = None

        # set to None if full_name (nullable) is None
        # and model_fields_set contains the field
        if self.full_name is None and "full_name" in self.model_fields_set:
            _dict['fullName'] = None

        # set to None if generic_type_arguments (nullable) is None
        # and model_fields_set contains the field
        if self.generic_type_arguments is None and "generic_type_arguments" in self.model_fields_set:
            _dict['genericTypeArguments'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Type from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "customAttributes": [CustomAttributeData.from_dict(_item) for _item in obj["customAttributes"]] if obj.get("customAttributes") is not None else None,
            "isCollectible": obj.get("isCollectible"),
            "metadataToken": obj.get("metadataToken"),
            "isInterface": obj.get("isInterface"),
            "memberType": obj.get("memberType"),
            "namespace": obj.get("namespace"),
            "assemblyQualifiedName": obj.get("assemblyQualifiedName"),
            "fullName": obj.get("fullName"),
            "assembly": Assembly.from_dict(obj["assembly"]) if obj.get("assembly") is not None else None,
            "module": Module.from_dict(obj["module"]) if obj.get("module") is not None else None,
            "isNested": obj.get("isNested"),
            "declaringType": Type.from_dict(obj["declaringType"]) if obj.get("declaringType") is not None else None,
            "declaringMethod": MethodBase.from_dict(obj["declaringMethod"]) if obj.get("declaringMethod") is not None else None,
            "reflectedType": Type.from_dict(obj["reflectedType"]) if obj.get("reflectedType") is not None else None,
            "underlyingSystemType": Type.from_dict(obj["underlyingSystemType"]) if obj.get("underlyingSystemType") is not None else None,
            "isTypeDefinition": obj.get("isTypeDefinition"),
            "isArray": obj.get("isArray"),
            "isByRef": obj.get("isByRef"),
            "isPointer": obj.get("isPointer"),
            "isConstructedGenericType": obj.get("isConstructedGenericType"),
            "isGenericParameter": obj.get("isGenericParameter"),
            "isGenericTypeParameter": obj.get("isGenericTypeParameter"),
            "isGenericMethodParameter": obj.get("isGenericMethodParameter"),
            "isGenericType": obj.get("isGenericType"),
            "isGenericTypeDefinition": obj.get("isGenericTypeDefinition"),
            "isSZArray": obj.get("isSZArray"),
            "isVariableBoundArray": obj.get("isVariableBoundArray"),
            "isByRefLike": obj.get("isByRefLike"),
            "isFunctionPointer": obj.get("isFunctionPointer"),
            "isUnmanagedFunctionPointer": obj.get("isUnmanagedFunctionPointer"),
            "hasElementType": obj.get("hasElementType"),
            "genericTypeArguments": [Type.from_dict(_item) for _item in obj["genericTypeArguments"]] if obj.get("genericTypeArguments") is not None else None,
            "genericParameterPosition": obj.get("genericParameterPosition"),
            "genericParameterAttributes": obj.get("genericParameterAttributes"),
            "attributes": obj.get("attributes"),
            "isAbstract": obj.get("isAbstract"),
            "isImport": obj.get("isImport"),
            "isSealed": obj.get("isSealed"),
            "isSpecialName": obj.get("isSpecialName"),
            "isClass": obj.get("isClass"),
            "isNestedAssembly": obj.get("isNestedAssembly"),
            "isNestedFamANDAssem": obj.get("isNestedFamANDAssem"),
            "isNestedFamily": obj.get("isNestedFamily"),
            "isNestedFamORAssem": obj.get("isNestedFamORAssem"),
            "isNestedPrivate": obj.get("isNestedPrivate"),
            "isNestedPublic": obj.get("isNestedPublic"),
            "isNotPublic": obj.get("isNotPublic"),
            "isPublic": obj.get("isPublic"),
            "isAutoLayout": obj.get("isAutoLayout"),
            "isExplicitLayout": obj.get("isExplicitLayout"),
            "isLayoutSequential": obj.get("isLayoutSequential"),
            "isAnsiClass": obj.get("isAnsiClass"),
            "isAutoClass": obj.get("isAutoClass"),
            "isUnicodeClass": obj.get("isUnicodeClass"),
            "isCOMObject": obj.get("isCOMObject"),
            "isContextful": obj.get("isContextful"),
            "isEnum": obj.get("isEnum"),
            "isMarshalByRef": obj.get("isMarshalByRef"),
            "isPrimitive": obj.get("isPrimitive"),
            "isValueType": obj.get("isValueType"),
            "isSignatureType": obj.get("isSignatureType"),
            "isSecurityCritical": obj.get("isSecurityCritical"),
            "isSecuritySafeCritical": obj.get("isSecuritySafeCritical"),
            "isSecurityTransparent": obj.get("isSecurityTransparent"),
            "structLayoutAttribute": StructLayoutAttribute.from_dict(obj["structLayoutAttribute"]) if obj.get("structLayoutAttribute") is not None else None,
            "typeInitializer": ConstructorInfo.from_dict(obj["typeInitializer"]) if obj.get("typeInitializer") is not None else None,
            "typeHandle": RuntimeTypeHandle.from_dict(obj["typeHandle"]) if obj.get("typeHandle") is not None else None,
            "guid": obj.get("guid"),
            "baseType": Type.from_dict(obj["baseType"]) if obj.get("baseType") is not None else None,
            "containsGenericParameters": obj.get("containsGenericParameters"),
            "isVisible": obj.get("isVisible")
        })
        return _obj


# TODO: Rewrite to not use raise_errors
Type.model_rebuild(raise_errors=False)
