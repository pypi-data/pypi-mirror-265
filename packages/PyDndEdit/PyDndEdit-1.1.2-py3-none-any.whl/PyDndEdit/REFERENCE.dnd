::comment
  Some of this text looks pretty ugly due to all the <tt>tags. This document
  format is not optimized for rendering code, so that is an acceptable tradeoff.
  Some spots have this weird <tt>:</tt><tt>:nodename</tt> pattern going
  on. That is so that the parser doesn't see a double colon and issue an error
  due to an illegal node. Again, it is extremely rare to actually talk about the
  nodes themselves in your code, so it is not really a problem.
::toc .left
::md .right
  Reference::title
  General::md .node
    Nodes are defined by lines that contain a double colon (<tt>:​:</tt>).
    Immediately following the node is the node type. The text preceding the
    double colon is the "header". For most nodes, this header will be
    represented in the document as a headhello that is a child of the tag that
    contains that node. The node type can be followed by classes, which are
    indicated by a leading dot (.), attributes, which are indicated by a leading
    at (@), or a directive, which are indicated by a leading pound sign (#).
    Attributes can take a parenthesized argument which is stored as a string.

    For example, in the following line:

    ::pre #noid
      Hello World::md .hello @greeting @bonjour(monde)
    will be parsed as follows:

    * "Hello World" is the header
    * <tt>[md]</tt> is the node type.
    * The node has one class, "hello"
    * The node has two attributes.
      - The first attribute is "greeting", with no associated value
      - The second attribute is "bonjour" with an associated value of "monde"
      - These attributes can be retrieved from javascript.

  Links::md .node #id(links-concept)
    In almost any place that text can go, text including a link can go. Links
    look like:

    ::pre #noid
      [link text]
    This will indicate a link that resolved to an internal id of #link-text by
    default. This behavior can be overriden in two ways. One way is with the
    [links] node. This will override the default handling of links. The other
    way is to put the override inline. It looks like this.

    ::pre #noid
      [link text | some-link]
    The contents inside the square brackets are split by the pipe character,
    <tt>|</tt>. The contents to the left is the text that will be rendered
    into the document. The stuff to the right is where the link will go. This
    text is used to look up what the link will resolve to. Therefore the
    following won't work:

    ::pre #noid
      [This is a bad link | https://google.com]
    What you would want to do instead is this:

    ::pre
      [This is a good link | google]
      ::links
        google = https://google.com
    This is an unusual use case. Usually you are referring to an internal anchor
    which is what the syntax is optimized for. For example:

    ::div .side-by-side
      Input::pre .leftside #noid
        Room 1::md
          There's like 90d90 goblins.
        Room 2::md
          When anyone enters this room, an alarm will sound,
          alerting the [goblins in 1. | room 1]
      Rendered::md .rightside #noid
        ::comment
          Use a raw node so that the toc doesn't see these.
          Maybe we should add @nonav or something similar?
        ::raw
          <div>
            <h4 id="room-1">Room 1</h4>
            <p>
              There's like 90d90 goblins.
            </p>
          </div>
          <div>
            <h4 id="room-2">Room 2</h4>
            <p>
              When anyone enters this room, an alarm will sound, alerting the
              <a href="#room-1">goblins in 1</a>.
            </p>
          </div>


  Attributes::md .node #id(attributes)
    Nodes can have attributes, designated by the <tt>@</tt>. Attributes are
    generally for the use of the author as they can be checked and accessed from
    <tt>[:​:js| js]</tt> nodes. All attributes are available for the user.

  Directives::md .node #id(directive)
    Nodes can have directives, designated by the <tt>#</tt>. Directives can
    affect the parsing of a node, its behavior or its rendered output. The
    current ones are described in the table below.

    ::table
      Attribute              | Description
      <tt>#import</tt>   | Treat the lines of the node as filepaths to be
                               imported and parsed, as children of this node.
      <tt>#noid</tt>     | Do not generate an id for this node.
      <tt>#hide</tt>     | Don't render the node in the html output. The
                               node is still normally parsed and is available
                               from js.
      <tt>#noinline</tt> | [img] and [imglinks] nodes normally "inline" the
                               image as a base64 string into the final document.
                               This disables that behaviour for that node.
      <tt>#id</tt>       | This directive takes an argument. This directive
                               overrides the normal generation of ids for this
                               node and instead uses the argument as the id.
  :​:md::md .node #id(md)
    <tt>md</tt> nodes are inspired by markdown, while not exactly being the
    same. <tt>md</tt> nodes accept any other nodes as children, as well as 3
    special forms for more convenient writing. Plain lines are treated as
    paragraphs. Include a blank line between them to separate paragraphs. For
    example:

    ::div .side-by-side
      Input::pre .leftside #noid
        ::md
          This is some text.
          Adjacent lines are merged into one paragraph.

          Use a blank line to break paragraphs into more than one.
          Nested node::md
            Paragraphs are also break on node change.
          Another paragraph
      Rendered::md .rightside #noid
        This is some text. Adjacent lines are merged into one paragraph.

        Use a blank line to break paragraphs into more than one.

        Nested node::md #noid
          Paragraphs are also break on node change.

        Another paragraph

    Lists, both ordered and unordered are supported. Unordered lists begin with
    a <tt>*</tt>, <tt>-</tt>, or <tt>+</tt> and one or more spaces.
    Ordered lists begin with a number, a <tt>.</tt> and a space. For
    example:

    ::div .side-by-side
      Input::pre .leftside #noid
        ::md
          * This is a list.
          - This is a continuation of the same list
            This is still considered one item, just with
            linebreaks.
            + Lists can be nested.
            1. Nested lists can be of different types
          1. This is a seperate list as it is a different type.
          3. The actual number is ignored.
          This is a new paragraph as it is not indented
          and does not start with a list. This is a little
          confusing, so avoid this stylistically.
      Rendered::md .rightside #noid
        * This is a list.
        * This is a continuation of the same list This is still considered one
          item, just with linebreaks.
          - Lists can be nested.
          1. Nested lists can be of different types

        1. This is a seperate list as it is a different type.
        2. The actual number is ignored.
        This is a new paragraph as it is not indented and does not start with a
        list. This is a little confusing, so avoid this stylistically.

    Note that the top level of the document is implicitly an <tt>md</tt>
    node.

  :​:deflist and:​:def::md .node #id(deflist)
    <tt>deflist</tt> nodes form a definition list, which corresponds to the
    <dl> html tag. The contents of a <tt>deflist</tt> should be
    <tt>def</tt> nodes. The contents of a <tt>def</tt> node is parsed in
    the same manner as the <tt>md</tt> node.

    ::div .side-by-side
      Input::pre .leftside #noid
        Game Terms::deflist
          d6::def
            A six-sided die.
          Space::def
            A square on the game board.
          Hit Points::def
            How many points of damage a unit can take before
            it is removed from the board.
      Rendered::md .rightside #noid
        Game Terms::deflist #noid
          d6::def #noid
            A six-sided die.

          Space::def #noid
            A square on the game board.

          Hit Points::def #noid
            How many points of damage a unit can take before it is removed from
            the board.

  :​:div::md .node #id(div)
    The <tt>div</tt> node is useful for creating wrapper nodes. Plain lines
    within the div node are not parsed specially and are outputted as plain
    lines within the div element. This is useful if you specifically do not want
    paragraphs (<p> tags) or special processing. It is also can express the
    intent that this is just a wrapper node.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::div
          * This is not a list.
          - Still not a list.
            1. Not a nested list.
          This is not a paragraph
      Rendered::div .rightside #noid
        * This is not a list. - Still not a list. 1. Not a nested list. This is
        not a paragraph
  :​:import::md .node #id(import)
    <tt>:​:import</tt> nodes are used to reuse the contents of other
    <tt>.dnd</tt> files. Every line of an import is treated as a filepath of
    another <tt>.dnd</tt>. That file is loaded and parsed and the resulting
    contents added as elements of the import node. The import node itself is
    then converted to xxx what actualy happens to imports.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::import
          list-of-cats.dnd
      Rendered::md .rightside #noid
        * Calico
        * Tortoise Shell
        * Black

    This node can't be used in untrusted input.

  :​:js::md .node #id(js)
    <tt>:​:js</tt> nodes are used to script the document. See the
    [js documentation] for more information on what js nodes can do.

    ::links
      js documentation = jsdoc.html
    ::div .side-by-side
      Input::pre .leftside #noid
        Hello::md
          Hi there!
        ::js
          // Add a '!!!' to the heading of every md node,
          // for emphasis.
          for(let node of ctx.select_nodes({type:NodeType.MD})){
            if(node.header)
              node.header += '!!!';
          }
      Rendered::md .rightside #noid
        Hello!!!::md #noid
          Hi there!

    This node can't be used in untrusted input.

  :​:title::md .node #id(title)
    The <tt>:​:title</tt> node is used to set the title of the document.
    The title node is also rendered as an <h1>. This node can have no children.
    The text before the double colon is all that is considered.

    ::div .side-by-side
      Input::pre .leftside #noid
        My Document::title
        This is my document.
      Rendered::md .rightside #noid
        ::raw
          <h1>My Document</h1>
          <p>This is my document</h1>
  :​:h::md .node #id(h)
    The <tt>:​:h</tt> node creates a heading. Generally, a nested md block
    is more useful, but sometimes you want to avoid overly indented documents.

    ::div .side-by-side
      Input::pre .leftside #noid
        Some Information::md
          Blah blah
          Subheading::h
          Blah Blah
      Rendered::md .rightside #noid
        Some Information::md #noid
          Blah blah

          Subheading::h #noid
          Blah Blah

  :​:table::md .node #id(table)
    The <tt>:​:table</tt> node is for tables! Columns are separted by the
    pipe character: <tt>|</tt>. The first row is the table heading. The last
    column of each row is allowed to continue on the next line if it is
    indented. This allows you to have larger amounts of text in the last column.

    ::div .side-by-side
      Input::pre .leftside #noid
        Wandering Monsters::table
          d6 | Monster
          1 | 1d6 orcs
          2 | 2d10 gremlins
          3 | 1d4 elves
          4 | Gambler,
              in an existential crisis
          5 | Ghost of christmas past.
          6 | Roll again twice
      Rendered::md .rightside #noid
        Wandering Monsters::table #noid
          d6 | Monster
          1  | 1d6 orcs
          2  | 2d10 gremlins
          3  | 1d4 elves
          4  | Gambler, in an existential crisis
          5  | Ghost of christmas past.
          6  | Roll again twice
  :​:css::md .node #id(css)
    The <tt>:​:css</tt> node allows adding styling information to the
    final rendered document. The contents will be placed in a <style> tag in the
    resulting html.

    ::div .side-by-side
      Input::pre .leftside #noid
        I Am Angry!!::md.angry
          So angry!
        ::css
          .angry {color: red;}
      Rendered::md .rightside #noid
        I Am Angry!!::md .angry #noid
          So angry!

        ::css
          .angry {color: red;}
  :​:links::md .node #id(links)
    The <tt>:​:links</tt> node allows adding information on what links in
    the text should resolve to. Each line is parsed in the following way: the
    line is split on the '<tt>=</tt>' character. The left hand side is the
    text as you refer to it in the document and the right hand side is what the
    link should resolve to. The left hand side is normalized so that
    punctuation, spaces and upper vs lower case doesn't matter.

    ::div .side-by-side
      Input::pre .leftside #noid
        There's a great website for playing dnd, [krug's basement]!
        ::links
          krug's basement = https://krugsbasement.com
      Rendered::md .rightside #noid
        There's a great website for playing dnd, [krug's basement]!

        ::links
          krug's basement = https://krugsbasement.com
  :​:script::md .node #id(script)
    The <tt>:​:script</tt> node allows adding javascript that will be in
    the final output document. Don't confuse this with the <tt>:​:js</tt>
    node, which is used to script the document at compile time. These scripts
    will be run when you open the document in a browser. See the copious
    documentation on the web for what you can do with javascript in a webpage.
    The contents will be in a <script> tag.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::script
          document.addEventListener('DOMContentLoaded', function(){
            alert('Hello world');
          });
      Rendered::md .rightside #noid
    This node can't be used in untrusted input.

  :​:img::md .node #id(img)
    The <tt>:​:img</tt> node is for adding an image to the document.

    The first line of the block is the path to the image. Lines after that are
    rendered as strings.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::img
          roxie-the-cat.png
          Roxie is a beautiful cat
      Rendered::md .rightside #noid
        ::img #noinline
          roxie-the-cat.png
          Roxie is a beautiful cat
        TODO

  :​:raw::md .node #id(raw)
    The <tt>:​:raw</tt> node allows adding unescaped content into the
    document, without being parsed specially in any way. Double colons don't
    introduce nodes, tags won't be escaped, etc. This allows you to add content
    that can't be expressed via another node.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::raw
          <button id="click-me" onclick="clicked()">
          Click::Me!
          </button>
        ::script
          function clicked(){
            let button = document.getElementById('clickme');
            button.textContent = 'You clicked!';
          }
      Rendered::md .rightside #noid
        ::raw
          <button id="clickme" onclick="clicked()">
          Click::Me!
          </button>
        ::script
          function clicked(){
            let button = document.getElementById('clickme');
            button.textContent = 'You clicked!';
          }
    This node can't be used in untrusted input.

  :​:pre::md .node #id(pre)
    The <tt>:​:pre</tt> node is for pre-formatted text. It's like the
    <pre> tag in html.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::pre
          * This is some preformatted text.
          * These are parsed as-is.
          <tags> are still escaped though.
      Rendered::pre .rightside #noid
        * This is some preformatted text.
        * These are parsed as-is.
        <tags> are still escaped though.
  :​:kv::md .node #id(kv)
    The <tt>:​:kv</tt> node allows for a display of key-value data. It is
    rendered as a two column table and is typically used for things like monster
    statistics. You can programmatically access the values as well.

    ::div .side-by-side
      Input::pre .leftside #noid
        Goblin::kv
          HP: 18
          AC: 14
          Atk: +4
          Dmg: 1d6+2
          Spd: 30'
      Rendered::md .rightside #noid
        Goblin::kv #noid
          HP:  18
          AC:  14
          Atk: +4
          Dmg: 1d6+2
          Spd: 30'
    You can add the ':' back with CSS. It is removed so that accessing kv
    entries via javascript is easier. For example:

    ::div .side-by-side
      Input::pre .leftside #noid
        Goblin::kv.monster
          HP: 18
          AC: 14
          Atk: +4
          Dmg: 1d6+2
          Spd: 30'
        ::css
          .monster tr > td:nth-child(1)::after{
            content:":";
          }
      Rendered::md .rightside #noid
        Goblin::kv .monster #noid
          HP:  18
          AC:  14
          Atk: +4
          Dmg: 1d6+2
          Spd: 30'
        ::css
          .monster tr > td:nth-child(1)::after{
            content:":";
          }
    You could also add it back via javascript, but this feels more elegant.

  :​:comment::md .node #id(comment)
    The <tt>:​:comment</tt> node is for describing potentially confusing sections
    of your document to editors of your document. It is not rendered in the
    final html.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::comment
          This node is so the script tag has something to add
          content to.
        ::div #id(add-me)
        ::script
          document.addEventListener('DOMContentLoaded', function(){
            const el = document.getElementById('add-me');
            el.add_child(document.createTextNode('Hello'));
          });
      Rendered::md .rightside #noid
        ::comment
          This node is so the script tag has something to add
          content to.
        ::div #id(add-me)
        ::script
          document.addEventListener('DOMContentLoaded', function(){
            const el = document.getElementById('add-me');
            el.appendChild(document.createTextNode('Hello'));
          });
  :​:imglinks::md .node #id(imglinks)
    The <tt>:​:imglinks</tt> node is really awesome and is one of the
    reasons dnd files are really nice for writing up your dungeons. They have a
    very specific syntax.

    1. The first line is the path to the image.
    2. The second line is the width. It is in the form <tt>width =
       300</tt>(or whatever width).
    3. The third line is the height. It is in the form <tt>height =
       400</tt>(or whatever height).
    4. The fourth line is the viewBox. It is in the form of<tt>viewBox = 0 0
       600 800</tt>. The 800 600 should be the original width of the image.
       GUI editors will fill in this and the other above lines in for you.
    5. The remaining lines are in the form of <tt> text = href @ x,y</tt>.
       <tt>text</tt> is the text that will appear on the image.
       <tt>href</tt> is what the link should target when clicked. Use anchor
       links (aka <tt>#id</tt>) for internal links, otherwise provide the
       url. <tt>x,y</tt> is the coordinates (in the units of the viewBox) of
       where the text should be centered. GUI editors can help automate this and
       you probably want to derive these lines from your document via
       javascript. The <tt>krugs-basement.dnd</tt> example is an example of
       how to do this.
    Really, just look at the krug's basement example dnd file.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::imglinks
          imgs/cells.png
          width = 600
          height = 450
          viewBox = 0 0 800 600
          1 = #den-of-evil @ 20, 30
      Rendered::md .rightside #noid
        TODO

  :​:toc::md .node #id(toc)
    The <tt>:​:toc</tt> node is a special kind of node. It renders into
    effectively a table of contents of the document, grabbing all h2s and h3s
    and putting them into an unordered list.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::toc
      Rendered::md .rightside #noid
        ::toc
  :​:quote::md .node #id(quote)
    The <tt>:​:quote</tt> node is for block quotes. It's like a div, but
    wraps in a <blockquote> instead of a div.

    ::div .side-by-side
      Input::pre .leftside #noid
        ::quote
          ::md
            Hello world
        ::css
          blockquote > div > *:before {
            content: "> ";
          }
      Rendered::md .rightside #noid
        ::quote
          ::md
            Hello world

        ::css
          blockquote > div > *:before {
            content: "> ";
          }
  :​:details::md .node #id(details)
    The <tt>:​:details</tt> node is parsed like a <tt>md</tt> node,
    but the final output will be in a <details> tag. The header will be put in
    the summary instead of as a heading.

    ::div .side-by-side
      Input::pre .leftside #noid
        Strength::details
          You add your strength to things like melee attacks or
          attempts to use raw brawn to overcome problems, like
          smashing open a door.
      Rendered::md .rightside #noid
        Strength::details #noid
          You add your strength to things like melee attacks or attempts to use
          raw brawn to overcome problems, like smashing open a door.

  :​:meta::md .node #id(meta)
    The <tt>:​:meta</tt> node is parsed as a raw node. Each line is
    wrapped in a <meta> tag and placed verbatim into the <head> of the document.
    This allows you to set specific meta-attributes. Search online for what can
    be done with <meta> tags. This functionality is rarely needed.

    This node can't be used in untrusted input.

  :​:head::md .node #id(head)
    The <tt>:​:head</tt> node is parsed as a raw node. Each line is
    placed verbatim into the <head> of the document.
    This allows you to do whatever you need to do.
    This functionality is rarely needed.

    This node can't be used in untrusted input.

::css
  * {
    box-sizing: border-box;
  }
  .left {
    height: 100%;
    overflow-y: auto;
  }
  .right {
    overflow-y: scroll;
    height: 100%;
    padding-bottom: 40em;
  }
  .right > * {
    max-width: 50em;
  }
  .side-by-side {
    display: grid;
    grid-template-columns: 30em 30em;
  }
  .side-by-side > * {
    border: 1px solid grey;
    padding: 0 1em;
  }
  .side-by-side > * > h3 {
    border-bottom: 1px dotted grey;
  }
  pre {
  }
  td, th  {
    border: 1px solid black;
    padding: 2px 8px;
  }
  th {
    padding: 8px;
  }
  table {
    border-collapse: collapse;
  }
  .node h2 {
    background-color: #eee;
    box-shadow: 1px 1px 3px 1px rgba(0,0,0,0.2);
    border-radius: 8px;
    padding: 2px 16px;
    width: 40em;
    font-family: "SF Mono", ui-mono, "Cascadia Mono", Consolas, monospace;
  }
  h1, h2, h3 {
    width: 100%;
  }
  html {
    width: 100%;
    height: 100%;
  }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    display: grid;
    height: 100%;
    width: 100%;
    margin: 0;
    grid-template-columns: max-content auto;
    grid-column-gap: 3em;
  }
  tt, pre {
    font-family: "SF Mono", ui-mono, "Cascadia Mono", Consolas, monospace;
  }
  tt {
    background-color: #f0f0f0;
    padding: 0 8px;
    border-radius: 8px;
  }
  pre {
    font-size: 12px;
  }
  nav {
    font-family: "SF Mono", ui-mono, "Cascadia Mono", Consolas, monospace;
  }

::script
  document.addEventListener('DOMContentLoaded', function(){
    const h2s = document.getElementsByTagName('h2');
    for(let h2 of h2s){
      h2.style.cursor = 'pointer';
      h2.addEventListener('click', function(){
        window.location.hash = h2.id;
      });
    }
  });
