# coding: utf-8

"""
    Advanced Bot Protection API

    This is the API for onboarding websites into Advanced Bot Protection. For full feature documentation, see [Advanced Bot Protection](https://docs.imperva.com/bundle/advanced-bot-protection/page/74791.htm)  ## Terminology differences  The API term *Domain* corresponds to, and is interchangeable with, a *Website* as used in the UI and web based documentation.  The API term *Site* corresponds to and is interchangeable with a *Website Group* as used in the UI and web based documentation.  The API term *Selector* corresponds to and is interchangeable with a *per-Path* *Policy* as used in the UI and web based documentation.  Besides the Imperva *account*, there is also an Advanced Bot Protection *account*. The are connected but have their own identifiers that cannot be mixed. In the API, *account* always refers to an ABP account unless otherwise specified.  ## Updates  When using PUT to update a resource, the entire resource will be replaced and any omitted fields may be deleted. To prevent data loss when performing an update you must GET the resource, update the returned response, and then send the result as the PUT request body.  ## API compatibility  Previous versions of the API are deprecated when a new version is released. Previous versions will be supported until further notice.  For a client to stay compatible with non breaking changes they need to take the following into account:  * New optional properties and properties with default values may   be added to JSON objects used as API request bodies.  * New properties may be added to JSON objects in API response bodies.  * Certain sum types (e.g. `enum` and `oneOf`) are documented as *open*   which means new alternatives can be added. The new values will only   be present if configured using the API or UI.  ## Authentication  See [API Key Management](https://docs.imperva.com/bundle/cloud-application-security/page/settings/api-keys.htm) for instructions on how to authenticate to this API.  ## Pagination  Resources may be paginated. This is indicated by the inclusion of the 'next' and/or the 'prev' relations in the '_links' property. See the Links schema documentation.   # noqa: E501

    OpenAPI spec version: 0.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class CreateDomainV1(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'site_id': 'SiteId',
        'challenge_ip_lookup_mode': 'OneOfCreateDomainV1ChallengeIpLookupMode',
        'analysis_ip_lookup_mode': 'OneOfCreateDomainV1AnalysisIpLookupMode',
        'criteria': 'CreateDomainCriteriaV1',
        'cookiescope': 'Cookiescope',
        'captcha_settings': 'OneOfCreateDomainV1CaptchaSettings',
        'log_region': 'OneOfCreateDomainV1LogRegion',
        'no_js_injection_paths': 'list[NoJsInjectionPathV1]',
        'obfuscate_path': 'str',
        'cookie_mode': 'OneOfCreateDomainV1CookieMode',
        'encryption_key_id': 'OneOfCreateDomainV1EncryptionKeyId',
        'unmasked_headers': 'OneOfCreateDomainV1UnmaskedHeaders',
        'proxy_flags': 'OneOfCreateDomainV1ProxyFlags',
        'filter_out_static_assets': 'bool',
        'enable_mitigation': 'bool'
    }

    attribute_map = {
        'site_id': 'site_id',
        'challenge_ip_lookup_mode': 'challenge_ip_lookup_mode',
        'analysis_ip_lookup_mode': 'analysis_ip_lookup_mode',
        'criteria': 'criteria',
        'cookiescope': 'cookiescope',
        'captcha_settings': 'captcha_settings',
        'log_region': 'log_region',
        'no_js_injection_paths': 'no_js_injection_paths',
        'obfuscate_path': 'obfuscate_path',
        'cookie_mode': 'cookie_mode',
        'encryption_key_id': 'encryption_key_id',
        'unmasked_headers': 'unmasked_headers',
        'proxy_flags': 'proxy_flags',
        'filter_out_static_assets': 'filter_out_static_assets',
        'enable_mitigation': 'enable_mitigation'
    }

    def __init__(self, site_id=None, challenge_ip_lookup_mode=None, analysis_ip_lookup_mode=None, criteria=None, cookiescope=None, captcha_settings=None, log_region=None, no_js_injection_paths=None, obfuscate_path=None, cookie_mode=None, encryption_key_id=None, unmasked_headers=None, proxy_flags=None, filter_out_static_assets=None, enable_mitigation=True):  # noqa: E501
        """CreateDomainV1 - a model defined in Swagger"""  # noqa: E501
        self._site_id = None
        self._challenge_ip_lookup_mode = None
        self._analysis_ip_lookup_mode = None
        self._criteria = None
        self._cookiescope = None
        self._captcha_settings = None
        self._log_region = None
        self._no_js_injection_paths = None
        self._obfuscate_path = None
        self._cookie_mode = None
        self._encryption_key_id = None
        self._unmasked_headers = None
        self._proxy_flags = None
        self._filter_out_static_assets = None
        self._enable_mitigation = None
        self.discriminator = None
        self.site_id = site_id
        if challenge_ip_lookup_mode is not None:
            self.challenge_ip_lookup_mode = challenge_ip_lookup_mode
        if analysis_ip_lookup_mode is not None:
            self.analysis_ip_lookup_mode = analysis_ip_lookup_mode
        self.criteria = criteria
        self.cookiescope = cookiescope
        if captcha_settings is not None:
            self.captcha_settings = captcha_settings
        if log_region is not None:
            self.log_region = log_region
        if no_js_injection_paths is not None:
            self.no_js_injection_paths = no_js_injection_paths
        if obfuscate_path is not None:
            self.obfuscate_path = obfuscate_path
        if cookie_mode is not None:
            self.cookie_mode = cookie_mode
        if encryption_key_id is not None:
            self.encryption_key_id = encryption_key_id
        if unmasked_headers is not None:
            self.unmasked_headers = unmasked_headers
        if proxy_flags is not None:
            self.proxy_flags = proxy_flags
        if filter_out_static_assets is not None:
            self.filter_out_static_assets = filter_out_static_assets
        if enable_mitigation is not None:
            self.enable_mitigation = enable_mitigation

    @property
    def site_id(self):
        """Gets the site_id of this CreateDomainV1.  # noqa: E501


        :return: The site_id of this CreateDomainV1.  # noqa: E501
        :rtype: SiteId
        """
        return self._site_id

    @site_id.setter
    def site_id(self, site_id):
        """Sets the site_id of this CreateDomainV1.


        :param site_id: The site_id of this CreateDomainV1.  # noqa: E501
        :type: SiteId
        """
        if site_id is None:
            raise ValueError("Invalid value for `site_id`, must not be `None`")  # noqa: E501

        self._site_id = site_id

    @property
    def challenge_ip_lookup_mode(self):
        """Gets the challenge_ip_lookup_mode of this CreateDomainV1.  # noqa: E501


        :return: The challenge_ip_lookup_mode of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1ChallengeIpLookupMode
        """
        return self._challenge_ip_lookup_mode

    @challenge_ip_lookup_mode.setter
    def challenge_ip_lookup_mode(self, challenge_ip_lookup_mode):
        """Sets the challenge_ip_lookup_mode of this CreateDomainV1.


        :param challenge_ip_lookup_mode: The challenge_ip_lookup_mode of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1ChallengeIpLookupMode
        """

        self._challenge_ip_lookup_mode = challenge_ip_lookup_mode

    @property
    def analysis_ip_lookup_mode(self):
        """Gets the analysis_ip_lookup_mode of this CreateDomainV1.  # noqa: E501


        :return: The analysis_ip_lookup_mode of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1AnalysisIpLookupMode
        """
        return self._analysis_ip_lookup_mode

    @analysis_ip_lookup_mode.setter
    def analysis_ip_lookup_mode(self, analysis_ip_lookup_mode):
        """Sets the analysis_ip_lookup_mode of this CreateDomainV1.


        :param analysis_ip_lookup_mode: The analysis_ip_lookup_mode of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1AnalysisIpLookupMode
        """

        self._analysis_ip_lookup_mode = analysis_ip_lookup_mode

    @property
    def criteria(self):
        """Gets the criteria of this CreateDomainV1.  # noqa: E501


        :return: The criteria of this CreateDomainV1.  # noqa: E501
        :rtype: CreateDomainCriteriaV1
        """
        return self._criteria

    @criteria.setter
    def criteria(self, criteria):
        """Sets the criteria of this CreateDomainV1.


        :param criteria: The criteria of this CreateDomainV1.  # noqa: E501
        :type: CreateDomainCriteriaV1
        """
        if criteria is None:
            raise ValueError("Invalid value for `criteria`, must not be `None`")  # noqa: E501

        self._criteria = criteria

    @property
    def cookiescope(self):
        """Gets the cookiescope of this CreateDomainV1.  # noqa: E501


        :return: The cookiescope of this CreateDomainV1.  # noqa: E501
        :rtype: Cookiescope
        """
        return self._cookiescope

    @cookiescope.setter
    def cookiescope(self, cookiescope):
        """Sets the cookiescope of this CreateDomainV1.


        :param cookiescope: The cookiescope of this CreateDomainV1.  # noqa: E501
        :type: Cookiescope
        """
        if cookiescope is None:
            raise ValueError("Invalid value for `cookiescope`, must not be `None`")  # noqa: E501

        self._cookiescope = cookiescope

    @property
    def captcha_settings(self):
        """Gets the captcha_settings of this CreateDomainV1.  # noqa: E501


        :return: The captcha_settings of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1CaptchaSettings
        """
        return self._captcha_settings

    @captcha_settings.setter
    def captcha_settings(self, captcha_settings):
        """Sets the captcha_settings of this CreateDomainV1.


        :param captcha_settings: The captcha_settings of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1CaptchaSettings
        """

        self._captcha_settings = captcha_settings

    @property
    def log_region(self):
        """Gets the log_region of this CreateDomainV1.  # noqa: E501


        :return: The log_region of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1LogRegion
        """
        return self._log_region

    @log_region.setter
    def log_region(self, log_region):
        """Sets the log_region of this CreateDomainV1.


        :param log_region: The log_region of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1LogRegion
        """

        self._log_region = log_region

    @property
    def no_js_injection_paths(self):
        """Gets the no_js_injection_paths of this CreateDomainV1.  # noqa: E501


        :return: The no_js_injection_paths of this CreateDomainV1.  # noqa: E501
        :rtype: list[NoJsInjectionPathV1]
        """
        return self._no_js_injection_paths

    @no_js_injection_paths.setter
    def no_js_injection_paths(self, no_js_injection_paths):
        """Sets the no_js_injection_paths of this CreateDomainV1.


        :param no_js_injection_paths: The no_js_injection_paths of this CreateDomainV1.  # noqa: E501
        :type: list[NoJsInjectionPathV1]
        """

        self._no_js_injection_paths = no_js_injection_paths

    @property
    def obfuscate_path(self):
        """Gets the obfuscate_path of this CreateDomainV1.  # noqa: E501

        It is recommended to omit this field or set it to null when creating a Domain, which will cause a new value to be generated by the server.   # noqa: E501

        :return: The obfuscate_path of this CreateDomainV1.  # noqa: E501
        :rtype: str
        """
        return self._obfuscate_path

    @obfuscate_path.setter
    def obfuscate_path(self, obfuscate_path):
        """Sets the obfuscate_path of this CreateDomainV1.

        It is recommended to omit this field or set it to null when creating a Domain, which will cause a new value to be generated by the server.   # noqa: E501

        :param obfuscate_path: The obfuscate_path of this CreateDomainV1.  # noqa: E501
        :type: str
        """

        self._obfuscate_path = obfuscate_path

    @property
    def cookie_mode(self):
        """Gets the cookie_mode of this CreateDomainV1.  # noqa: E501


        :return: The cookie_mode of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1CookieMode
        """
        return self._cookie_mode

    @cookie_mode.setter
    def cookie_mode(self, cookie_mode):
        """Sets the cookie_mode of this CreateDomainV1.


        :param cookie_mode: The cookie_mode of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1CookieMode
        """

        self._cookie_mode = cookie_mode

    @property
    def encryption_key_id(self):
        """Gets the encryption_key_id of this CreateDomainV1.  # noqa: E501

        Provide an ID to copy an already existing key. If `null`, a copy of the account default encryption key will be used.  # noqa: E501

        :return: The encryption_key_id of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1EncryptionKeyId
        """
        return self._encryption_key_id

    @encryption_key_id.setter
    def encryption_key_id(self, encryption_key_id):
        """Sets the encryption_key_id of this CreateDomainV1.

        Provide an ID to copy an already existing key. If `null`, a copy of the account default encryption key will be used.  # noqa: E501

        :param encryption_key_id: The encryption_key_id of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1EncryptionKeyId
        """

        self._encryption_key_id = encryption_key_id

    @property
    def unmasked_headers(self):
        """Gets the unmasked_headers of this CreateDomainV1.  # noqa: E501


        :return: The unmasked_headers of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1UnmaskedHeaders
        """
        return self._unmasked_headers

    @unmasked_headers.setter
    def unmasked_headers(self, unmasked_headers):
        """Sets the unmasked_headers of this CreateDomainV1.


        :param unmasked_headers: The unmasked_headers of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1UnmaskedHeaders
        """

        self._unmasked_headers = unmasked_headers

    @property
    def proxy_flags(self):
        """Gets the proxy_flags of this CreateDomainV1.  # noqa: E501


        :return: The proxy_flags of this CreateDomainV1.  # noqa: E501
        :rtype: OneOfCreateDomainV1ProxyFlags
        """
        return self._proxy_flags

    @proxy_flags.setter
    def proxy_flags(self, proxy_flags):
        """Sets the proxy_flags of this CreateDomainV1.


        :param proxy_flags: The proxy_flags of this CreateDomainV1.  # noqa: E501
        :type: OneOfCreateDomainV1ProxyFlags
        """

        self._proxy_flags = proxy_flags

    @property
    def filter_out_static_assets(self):
        """Gets the filter_out_static_assets of this CreateDomainV1.  # noqa: E501

        CWAF Only: Prevents certain static asset paths from being analyzed by ABP. Currently, this filters paths matching the following regular expression:  \"\\.(js|gif|jpe?g|ico|png|css|svg?z|woff2?|ttf)$\"  # noqa: E501

        :return: The filter_out_static_assets of this CreateDomainV1.  # noqa: E501
        :rtype: bool
        """
        return self._filter_out_static_assets

    @filter_out_static_assets.setter
    def filter_out_static_assets(self, filter_out_static_assets):
        """Sets the filter_out_static_assets of this CreateDomainV1.

        CWAF Only: Prevents certain static asset paths from being analyzed by ABP. Currently, this filters paths matching the following regular expression:  \"\\.(js|gif|jpe?g|ico|png|css|svg?z|woff2?|ttf)$\"  # noqa: E501

        :param filter_out_static_assets: The filter_out_static_assets of this CreateDomainV1.  # noqa: E501
        :type: bool
        """

        self._filter_out_static_assets = filter_out_static_assets

    @property
    def enable_mitigation(self):
        """Gets the enable_mitigation of this CreateDomainV1.  # noqa: E501

        If set to false, all Conditions in all related Policies will behave as if they were passive. If set to true, all Conditions will behave according to their state (active or passive).  # noqa: E501

        :return: The enable_mitigation of this CreateDomainV1.  # noqa: E501
        :rtype: bool
        """
        return self._enable_mitigation

    @enable_mitigation.setter
    def enable_mitigation(self, enable_mitigation):
        """Sets the enable_mitigation of this CreateDomainV1.

        If set to false, all Conditions in all related Policies will behave as if they were passive. If set to true, all Conditions will behave according to their state (active or passive).  # noqa: E501

        :param enable_mitigation: The enable_mitigation of this CreateDomainV1.  # noqa: E501
        :type: bool
        """

        self._enable_mitigation = enable_mitigation

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(CreateDomainV1, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, CreateDomainV1):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
