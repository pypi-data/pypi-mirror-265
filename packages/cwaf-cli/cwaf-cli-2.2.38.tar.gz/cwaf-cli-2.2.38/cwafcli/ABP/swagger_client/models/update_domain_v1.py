# coding: utf-8

"""
    Advanced Bot Protection API

    This is the API for onboarding websites into Advanced Bot Protection. For full feature documentation, see [Advanced Bot Protection](https://docs.imperva.com/bundle/advanced-bot-protection/page/74791.htm)  ## Terminology differences  The API term *Domain* corresponds to, and is interchangeable with, a *Website* as used in the UI and web based documentation.  The API term *Site* corresponds to and is interchangeable with a *Website Group* as used in the UI and web based documentation.  The API term *Selector* corresponds to and is interchangeable with a *per-Path* *Policy* as used in the UI and web based documentation.  Besides the Imperva *account*, there is also an Advanced Bot Protection *account*. The are connected but have their own identifiers that cannot be mixed. In the API, *account* always refers to an ABP account unless otherwise specified.  ## Updates  When using PUT to update a resource, the entire resource will be replaced and any omitted fields may be deleted. To prevent data loss when performing an update you must GET the resource, update the returned response, and then send the result as the PUT request body.  ## API compatibility  Previous versions of the API are deprecated when a new version is released. Previous versions will be supported until further notice.  For a client to stay compatible with non breaking changes they need to take the following into account:  * New optional properties and properties with default values may   be added to JSON objects used as API request bodies.  * New properties may be added to JSON objects in API response bodies.  * Certain sum types (e.g. `enum` and `oneOf`) are documented as *open*   which means new alternatives can be added. The new values will only   be present if configured using the API or UI.  ## Authentication  See [API Key Management](https://docs.imperva.com/bundle/cloud-application-security/page/settings/api-keys.htm) for instructions on how to authenticate to this API.  ## Pagination  Resources may be paginated. This is indicated by the inclusion of the 'next' and/or the 'prev' relations in the '_links' property. See the Links schema documentation.   # noqa: E501

    OpenAPI spec version: 0.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class UpdateDomainV1(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'site_id': 'SiteId',
        'challenge_ip_lookup_mode': 'IpLookupModeV1',
        'analysis_ip_lookup_mode': 'IpLookupModeV1',
        'cookiescope': 'Cookiescope',
        'captcha_settings': 'CaptchaSettingsV1',
        'log_region': 'LogRegionV1',
        'no_js_injection_paths': 'list[NoJsInjectionPathV1]',
        'obfuscate_path': 'str',
        'cookie_mode': 'CookieModeV1',
        'unmasked_headers': 'UnmaskedHeadersV1',
        'proxy_flags': 'ProxyFlagsV1',
        'filter_out_static_assets': 'bool',
        'enable_mitigation': 'bool'
    }

    attribute_map = {
        'site_id': 'site_id',
        'challenge_ip_lookup_mode': 'challenge_ip_lookup_mode',
        'analysis_ip_lookup_mode': 'analysis_ip_lookup_mode',
        'cookiescope': 'cookiescope',
        'captcha_settings': 'captcha_settings',
        'log_region': 'log_region',
        'no_js_injection_paths': 'no_js_injection_paths',
        'obfuscate_path': 'obfuscate_path',
        'cookie_mode': 'cookie_mode',
        'unmasked_headers': 'unmasked_headers',
        'proxy_flags': 'proxy_flags',
        'filter_out_static_assets': 'filter_out_static_assets',
        'enable_mitigation': 'enable_mitigation'
    }

    def __init__(self, site_id=None, challenge_ip_lookup_mode=None, analysis_ip_lookup_mode=None, cookiescope=None, captcha_settings=None, log_region=None, no_js_injection_paths=None, obfuscate_path=None, cookie_mode=None, unmasked_headers=None, proxy_flags=None, filter_out_static_assets=None, enable_mitigation=True):  # noqa: E501
        """UpdateDomainV1 - a model defined in Swagger"""  # noqa: E501
        self._site_id = None
        self._challenge_ip_lookup_mode = None
        self._analysis_ip_lookup_mode = None
        self._cookiescope = None
        self._captcha_settings = None
        self._log_region = None
        self._no_js_injection_paths = None
        self._obfuscate_path = None
        self._cookie_mode = None
        self._unmasked_headers = None
        self._proxy_flags = None
        self._filter_out_static_assets = None
        self._enable_mitigation = None
        self.discriminator = None
        self.site_id = site_id
        self.challenge_ip_lookup_mode = challenge_ip_lookup_mode
        self.analysis_ip_lookup_mode = analysis_ip_lookup_mode
        self.cookiescope = cookiescope
        self.captcha_settings = captcha_settings
        self.log_region = log_region
        self.no_js_injection_paths = no_js_injection_paths
        if obfuscate_path is not None:
            self.obfuscate_path = obfuscate_path
        self.cookie_mode = cookie_mode
        self.unmasked_headers = unmasked_headers
        self.proxy_flags = proxy_flags
        if filter_out_static_assets is not None:
            self.filter_out_static_assets = filter_out_static_assets
        if enable_mitigation is not None:
            self.enable_mitigation = enable_mitigation

    @property
    def site_id(self):
        """Gets the site_id of this UpdateDomainV1.  # noqa: E501


        :return: The site_id of this UpdateDomainV1.  # noqa: E501
        :rtype: SiteId
        """
        return self._site_id

    @site_id.setter
    def site_id(self, site_id):
        """Sets the site_id of this UpdateDomainV1.


        :param site_id: The site_id of this UpdateDomainV1.  # noqa: E501
        :type: SiteId
        """
        if site_id is None:
            raise ValueError("Invalid value for `site_id`, must not be `None`")  # noqa: E501

        self._site_id = site_id

    @property
    def challenge_ip_lookup_mode(self):
        """Gets the challenge_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501


        :return: The challenge_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501
        :rtype: IpLookupModeV1
        """
        return self._challenge_ip_lookup_mode

    @challenge_ip_lookup_mode.setter
    def challenge_ip_lookup_mode(self, challenge_ip_lookup_mode):
        """Sets the challenge_ip_lookup_mode of this UpdateDomainV1.


        :param challenge_ip_lookup_mode: The challenge_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501
        :type: IpLookupModeV1
        """
        if challenge_ip_lookup_mode is None:
            raise ValueError("Invalid value for `challenge_ip_lookup_mode`, must not be `None`")  # noqa: E501

        self._challenge_ip_lookup_mode = challenge_ip_lookup_mode

    @property
    def analysis_ip_lookup_mode(self):
        """Gets the analysis_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501


        :return: The analysis_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501
        :rtype: IpLookupModeV1
        """
        return self._analysis_ip_lookup_mode

    @analysis_ip_lookup_mode.setter
    def analysis_ip_lookup_mode(self, analysis_ip_lookup_mode):
        """Sets the analysis_ip_lookup_mode of this UpdateDomainV1.


        :param analysis_ip_lookup_mode: The analysis_ip_lookup_mode of this UpdateDomainV1.  # noqa: E501
        :type: IpLookupModeV1
        """
        if analysis_ip_lookup_mode is None:
            raise ValueError("Invalid value for `analysis_ip_lookup_mode`, must not be `None`")  # noqa: E501

        self._analysis_ip_lookup_mode = analysis_ip_lookup_mode

    @property
    def cookiescope(self):
        """Gets the cookiescope of this UpdateDomainV1.  # noqa: E501


        :return: The cookiescope of this UpdateDomainV1.  # noqa: E501
        :rtype: Cookiescope
        """
        return self._cookiescope

    @cookiescope.setter
    def cookiescope(self, cookiescope):
        """Sets the cookiescope of this UpdateDomainV1.


        :param cookiescope: The cookiescope of this UpdateDomainV1.  # noqa: E501
        :type: Cookiescope
        """
        if cookiescope is None:
            raise ValueError("Invalid value for `cookiescope`, must not be `None`")  # noqa: E501

        self._cookiescope = cookiescope

    @property
    def captcha_settings(self):
        """Gets the captcha_settings of this UpdateDomainV1.  # noqa: E501


        :return: The captcha_settings of this UpdateDomainV1.  # noqa: E501
        :rtype: CaptchaSettingsV1
        """
        return self._captcha_settings

    @captcha_settings.setter
    def captcha_settings(self, captcha_settings):
        """Sets the captcha_settings of this UpdateDomainV1.


        :param captcha_settings: The captcha_settings of this UpdateDomainV1.  # noqa: E501
        :type: CaptchaSettingsV1
        """
        if captcha_settings is None:
            raise ValueError("Invalid value for `captcha_settings`, must not be `None`")  # noqa: E501

        self._captcha_settings = captcha_settings

    @property
    def log_region(self):
        """Gets the log_region of this UpdateDomainV1.  # noqa: E501


        :return: The log_region of this UpdateDomainV1.  # noqa: E501
        :rtype: LogRegionV1
        """
        return self._log_region

    @log_region.setter
    def log_region(self, log_region):
        """Sets the log_region of this UpdateDomainV1.


        :param log_region: The log_region of this UpdateDomainV1.  # noqa: E501
        :type: LogRegionV1
        """
        if log_region is None:
            raise ValueError("Invalid value for `log_region`, must not be `None`")  # noqa: E501

        self._log_region = log_region

    @property
    def no_js_injection_paths(self):
        """Gets the no_js_injection_paths of this UpdateDomainV1.  # noqa: E501


        :return: The no_js_injection_paths of this UpdateDomainV1.  # noqa: E501
        :rtype: list[NoJsInjectionPathV1]
        """
        return self._no_js_injection_paths

    @no_js_injection_paths.setter
    def no_js_injection_paths(self, no_js_injection_paths):
        """Sets the no_js_injection_paths of this UpdateDomainV1.


        :param no_js_injection_paths: The no_js_injection_paths of this UpdateDomainV1.  # noqa: E501
        :type: list[NoJsInjectionPathV1]
        """
        if no_js_injection_paths is None:
            raise ValueError("Invalid value for `no_js_injection_paths`, must not be `None`")  # noqa: E501

        self._no_js_injection_paths = no_js_injection_paths

    @property
    def obfuscate_path(self):
        """Gets the obfuscate_path of this UpdateDomainV1.  # noqa: E501

        If `obfuscate_path` already has a value for this Domain, omitting the field or setting it to `null` will result in a 400 Bad Request.  # noqa: E501

        :return: The obfuscate_path of this UpdateDomainV1.  # noqa: E501
        :rtype: str
        """
        return self._obfuscate_path

    @obfuscate_path.setter
    def obfuscate_path(self, obfuscate_path):
        """Sets the obfuscate_path of this UpdateDomainV1.

        If `obfuscate_path` already has a value for this Domain, omitting the field or setting it to `null` will result in a 400 Bad Request.  # noqa: E501

        :param obfuscate_path: The obfuscate_path of this UpdateDomainV1.  # noqa: E501
        :type: str
        """

        self._obfuscate_path = obfuscate_path

    @property
    def cookie_mode(self):
        """Gets the cookie_mode of this UpdateDomainV1.  # noqa: E501


        :return: The cookie_mode of this UpdateDomainV1.  # noqa: E501
        :rtype: CookieModeV1
        """
        return self._cookie_mode

    @cookie_mode.setter
    def cookie_mode(self, cookie_mode):
        """Sets the cookie_mode of this UpdateDomainV1.


        :param cookie_mode: The cookie_mode of this UpdateDomainV1.  # noqa: E501
        :type: CookieModeV1
        """
        if cookie_mode is None:
            raise ValueError("Invalid value for `cookie_mode`, must not be `None`")  # noqa: E501

        self._cookie_mode = cookie_mode

    @property
    def unmasked_headers(self):
        """Gets the unmasked_headers of this UpdateDomainV1.  # noqa: E501


        :return: The unmasked_headers of this UpdateDomainV1.  # noqa: E501
        :rtype: UnmaskedHeadersV1
        """
        return self._unmasked_headers

    @unmasked_headers.setter
    def unmasked_headers(self, unmasked_headers):
        """Sets the unmasked_headers of this UpdateDomainV1.


        :param unmasked_headers: The unmasked_headers of this UpdateDomainV1.  # noqa: E501
        :type: UnmaskedHeadersV1
        """
        if unmasked_headers is None:
            raise ValueError("Invalid value for `unmasked_headers`, must not be `None`")  # noqa: E501

        self._unmasked_headers = unmasked_headers

    @property
    def proxy_flags(self):
        """Gets the proxy_flags of this UpdateDomainV1.  # noqa: E501


        :return: The proxy_flags of this UpdateDomainV1.  # noqa: E501
        :rtype: ProxyFlagsV1
        """
        return self._proxy_flags

    @proxy_flags.setter
    def proxy_flags(self, proxy_flags):
        """Sets the proxy_flags of this UpdateDomainV1.


        :param proxy_flags: The proxy_flags of this UpdateDomainV1.  # noqa: E501
        :type: ProxyFlagsV1
        """
        if proxy_flags is None:
            raise ValueError("Invalid value for `proxy_flags`, must not be `None`")  # noqa: E501

        self._proxy_flags = proxy_flags

    @property
    def filter_out_static_assets(self):
        """Gets the filter_out_static_assets of this UpdateDomainV1.  # noqa: E501

        CWAF Only: Prevents certain static asset paths from being analyzed by ABP. Currently, this filters paths matching the following regular expression:  \"\\.(js|gif|jpe?g|ico|png|css|svg?z|woff2?|ttf)$\"  # noqa: E501

        :return: The filter_out_static_assets of this UpdateDomainV1.  # noqa: E501
        :rtype: bool
        """
        return self._filter_out_static_assets

    @filter_out_static_assets.setter
    def filter_out_static_assets(self, filter_out_static_assets):
        """Sets the filter_out_static_assets of this UpdateDomainV1.

        CWAF Only: Prevents certain static asset paths from being analyzed by ABP. Currently, this filters paths matching the following regular expression:  \"\\.(js|gif|jpe?g|ico|png|css|svg?z|woff2?|ttf)$\"  # noqa: E501

        :param filter_out_static_assets: The filter_out_static_assets of this UpdateDomainV1.  # noqa: E501
        :type: bool
        """

        self._filter_out_static_assets = filter_out_static_assets

    @property
    def enable_mitigation(self):
        """Gets the enable_mitigation of this UpdateDomainV1.  # noqa: E501

        If set to false, all Conditions in all related Policies will behave as if they were passive. If set to true, all Conditions will behave according to their state (active or passive).  # noqa: E501

        :return: The enable_mitigation of this UpdateDomainV1.  # noqa: E501
        :rtype: bool
        """
        return self._enable_mitigation

    @enable_mitigation.setter
    def enable_mitigation(self, enable_mitigation):
        """Sets the enable_mitigation of this UpdateDomainV1.

        If set to false, all Conditions in all related Policies will behave as if they were passive. If set to true, all Conditions will behave according to their state (active or passive).  # noqa: E501

        :param enable_mitigation: The enable_mitigation of this UpdateDomainV1.  # noqa: E501
        :type: bool
        """

        self._enable_mitigation = enable_mitigation

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(UpdateDomainV1, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, UpdateDomainV1):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
