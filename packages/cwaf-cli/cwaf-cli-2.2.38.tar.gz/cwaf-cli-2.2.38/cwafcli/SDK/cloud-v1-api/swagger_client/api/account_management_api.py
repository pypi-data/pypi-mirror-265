# coding: utf-8

"""
    Cloud Application Security API

    Imperva provides customers and partners with the ability to manage accounts and sites via an API. For more information, see <a style=\"text-decoration:none\" href=\"https://docs.imperva.com/csh?context=my_api\">Cloud Application Security API Reference</a>.  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AccountManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_account(self, email, **kwargs):  # noqa: E501
        """Add a new managed account  # noqa: E501

        Available for Reseller accounts only<br/>Use this operation to add a new account that should be managed by the account of the API client (the parent account). The new account will be configured according to the preferences set for the parent account by Imperva. Depending on these preferences, an activation e-mail will be sent to the specified e-mail address. The user responds to the activation e-mail, selects a password, and can then log directly into the Imperva console. The same e-mail address can also be used to send system notifications to the account. The new account is identified by a numeric value as provided by Imperva in the response in the field account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_account(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: Email address. For example: \"joe@example.com\". (required)
        :param int parent_id: The newly created account's parent id. If not specified, the invoking account will be assigned as the parent.
        :param str name: The account owner's name. For example: \"John Doe\".
        :param str plan_id: An identifier of the plan to assign to the new account. For example, ent100 for the Enterprise 100 plan.<br/>Example values:<br/>ent100 | ent50 | ent20
        :param str ref_id: Customer specific identifier for this operation.
        :param str account_name: Account name.
        :param str account_description: The account description
        :param str user_name: The account owner's name. For example: \"John Doe\".
        :param str log_level: Sets the log reporting level for the site.<br/>Possible values: full | security | none | default<br/>Default value is <b>none</b><br/>Available only for customers that purchased the Logs Integration SKU.
        :param str logs_account_id: Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters. Available only for customers that purchased the Logs Integration SKU.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_account_with_http_info(email, **kwargs)  # noqa: E501
        else:
            (data) = self.add_account_with_http_info(email, **kwargs)  # noqa: E501
            return data

    def add_account_with_http_info(self, email, **kwargs):  # noqa: E501
        """Add a new managed account  # noqa: E501

        Available for Reseller accounts only<br/>Use this operation to add a new account that should be managed by the account of the API client (the parent account). The new account will be configured according to the preferences set for the parent account by Imperva. Depending on these preferences, an activation e-mail will be sent to the specified e-mail address. The user responds to the activation e-mail, selects a password, and can then log directly into the Imperva console. The same e-mail address can also be used to send system notifications to the account. The new account is identified by a numeric value as provided by Imperva in the response in the field account_id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_account_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: Email address. For example: \"joe@example.com\". (required)
        :param int parent_id: The newly created account's parent id. If not specified, the invoking account will be assigned as the parent.
        :param str name: The account owner's name. For example: \"John Doe\".
        :param str plan_id: An identifier of the plan to assign to the new account. For example, ent100 for the Enterprise 100 plan.<br/>Example values:<br/>ent100 | ent50 | ent20
        :param str ref_id: Customer specific identifier for this operation.
        :param str account_name: Account name.
        :param str account_description: The account description
        :param str user_name: The account owner's name. For example: \"John Doe\".
        :param str log_level: Sets the log reporting level for the site.<br/>Possible values: full | security | none | default<br/>Default value is <b>none</b><br/>Available only for customers that purchased the Logs Integration SKU.
        :param str logs_account_id: Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters. Available only for customers that purchased the Logs Integration SKU.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'parent_id', 'name', 'plan_id', 'ref_id', 'account_name', 'account_description', 'user_name', 'log_level', 'logs_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `add_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'parent_id' in params:
            query_params.append(('parent_id', params['parent_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'plan_id' in params:
            query_params.append(('plan_id', params['plan_id']))  # noqa: E501
        if 'ref_id' in params:
            query_params.append(('ref_id', params['ref_id']))  # noqa: E501
        if 'account_name' in params:
            query_params.append(('account_name', params['account_name']))  # noqa: E501
        if 'account_description' in params:
            query_params.append(('account_description', params['account_description']))  # noqa: E501
        if 'user_name' in params:
            query_params.append(('user_name', params['user_name']))  # noqa: E501
        if 'log_level' in params:
            query_params.append(('log_level', params['log_level']))  # noqa: E501
        if 'logs_account_id' in params:
            query_params.append(('logs_account_id', params['logs_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_sub_account(self, sub_account_name, **kwargs):  # noqa: E501
        """Add a new sub account  # noqa: E501

        Use this operation to add a new sub account to be managed by the account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sub_account(sub_account_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sub_account_name: The name of the sub account. (required)
        :param int parent_id: The newly created account's parent id. If not specified, the invoking account will be assigned as the parent account.
        :param str ref_id: Customer specific identifier for this operation.
        :param str log_level: Sets the log reporting level for the site.<br/>Possible values: full, security, none, default<br/>Available only for customers that purchased the Logs Integration SKU.
        :param str logs_account_id: Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.<br/>Available only for customers that purchased the Logs Integration SKU.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_sub_account_with_http_info(sub_account_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_sub_account_with_http_info(sub_account_name, **kwargs)  # noqa: E501
            return data

    def add_sub_account_with_http_info(self, sub_account_name, **kwargs):  # noqa: E501
        """Add a new sub account  # noqa: E501

        Use this operation to add a new sub account to be managed by the account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sub_account_with_http_info(sub_account_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sub_account_name: The name of the sub account. (required)
        :param int parent_id: The newly created account's parent id. If not specified, the invoking account will be assigned as the parent account.
        :param str ref_id: Customer specific identifier for this operation.
        :param str log_level: Sets the log reporting level for the site.<br/>Possible values: full, security, none, default<br/>Available only for customers that purchased the Logs Integration SKU.
        :param str logs_account_id: Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.<br/>Available only for customers that purchased the Logs Integration SKU.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sub_account_name', 'parent_id', 'ref_id', 'log_level', 'logs_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_sub_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sub_account_name' is set
        if ('sub_account_name' not in params or
                params['sub_account_name'] is None):
            raise ValueError("Missing the required parameter `sub_account_name` when calling `add_sub_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sub_account_name' in params:
            query_params.append(('sub_account_name', params['sub_account_name']))  # noqa: E501
        if 'parent_id' in params:
            query_params.append(('parent_id', params['parent_id']))  # noqa: E501
        if 'ref_id' in params:
            query_params.append(('ref_id', params['ref_id']))  # noqa: E501
        if 'log_level' in params:
            query_params.append(('log_level', params['log_level']))  # noqa: E501
        if 'logs_account_id' in params:
            query_params.append(('logs_account_id', params['logs_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/subaccounts/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account(self, account_id, **kwargs):  # noqa: E501
        """Delete managed account  # noqa: E501

        Available for Reseller accounts only Use this operation to delete an account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def delete_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Delete managed account  # noqa: E501

        Available for Reseller accounts only Use this operation to delete an account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `delete_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_sub_account(self, sub_account_id, **kwargs):  # noqa: E501
        """Delete sub account  # noqa: E501

        Use this operation to delete a sub account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sub_account(sub_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int sub_account_id: Numeric identifier of the sub account to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_sub_account_with_http_info(sub_account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_sub_account_with_http_info(sub_account_id, **kwargs)  # noqa: E501
            return data

    def delete_sub_account_with_http_info(self, sub_account_id, **kwargs):  # noqa: E501
        """Delete sub account  # noqa: E501

        Use this operation to delete a sub account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sub_account_with_http_info(sub_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int sub_account_id: Numeric identifier of the sub account to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sub_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_sub_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sub_account_id' is set
        if ('sub_account_id' not in params or
                params['sub_account_id'] is None):
            raise ValueError("Missing the required parameter `sub_account_id` when calling `delete_sub_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sub_account_id' in params:
            query_params.append(('sub_account_id', params['sub_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/subaccounts/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_status(self, **kwargs):  # noqa: E501
        """Get account status  # noqa: E501

        Use this operation to get account status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResultAccountStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get account status  # noqa: E501

        Use this operation to get account status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResultAccountStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/account', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResultAccountStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_region(self, **kwargs):  # noqa: E501
        """Get default data storage region  # noqa: E501

        Use this operation to get the default data region of the account. (Available for Reseller accounts only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_region(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_default_region_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_default_region_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_default_region_with_http_info(self, **kwargs):  # noqa: E501
        """Get default data storage region  # noqa: E501

        Use this operation to get the default data region of the account. (Available for Reseller accounts only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_region_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_region" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/data-privacy/show', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_token(self, **kwargs):  # noqa: E501
        """Get account login token  # noqa: E501

        Tokens are used instead of user/password based authentication to log in to the Imperva Cloud Security Console. Use this operation to generate a token for an account. The token is valid for 15 minutes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str partner_id: Numeric identifier of the parent id to operate on
        :return: ApiResultGetSsoToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_token_with_http_info(self, **kwargs):  # noqa: E501
        """Get account login token  # noqa: E501

        Tokens are used instead of user/password based authentication to log in to the Imperva Cloud Security Console. Use this operation to generate a token for an account. The token is valid for 15 minutes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str partner_id: Numeric identifier of the parent id to operate on
        :return: ApiResultGetSsoToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'partner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'partner_id' in params:
            query_params.append(('partner_id', params['partner_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/gettoken', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResultGetSsoToken',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_accounts(self, **kwargs):  # noqa: E501
        """List managed accounts  # noqa: E501

        Available for Reseller accounts only.<br/>Use this operation to get the list of accounts that are managed by account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str page_size: The number of objects to return in the response.<br/>Default: 50<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default: '0
        :return: ApiResultListUsers
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """List managed accounts  # noqa: E501

        Available for Reseller accounts only.<br/>Use this operation to get the list of accounts that are managed by account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str page_size: The number of objects to return in the response.<br/>Default: 50<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default: '0
        :return: ApiResultListUsers
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'page_size', 'page_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_num' in params:
            query_params.append(('page_num', params['page_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResultListUsers',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sub_accounts(self, **kwargs):  # noqa: E501
        """List account's sub accounts  # noqa: E501

        Use this operation to get a list of sub accounts that are managed by the account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sub_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str page_size: The number of objects to return in the response.<br/>Default: 50<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default: 0
        :return: list[SubAccountStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_sub_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_sub_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_sub_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """List account's sub accounts  # noqa: E501

        Use this operation to get a list of sub accounts that are managed by the account of the API client (the parent account).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sub_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str page_size: The number of objects to return in the response.<br/>Default: 50<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default: 0
        :return: list[SubAccountStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'page_size', 'page_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sub_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_num' in params:
            query_params.append(('page_num', params['page_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/listSubAccounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SubAccountStatus]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_account_configuration(self, param, value, **kwargs):  # noqa: E501
        """Modify account configuration  # noqa: E501

        Use this operation to change the configuration of the account of the API client or one of its managed accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_account_configuration(param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>name</b> the updated name.</li><li><b>email</b> the updated e-mail address</li><li><b>plan_id</b> a plan id</li><li><b>error_page_template</b> a Base64 encoded template for an error page.</li><li><b>support_all_tls_versions</b> Use this operation to allow sites in the account to support all TLS versions for connectivity between clients (visitors) and the Imperva service. When this option is set, you can then enable the option per site to support all TLS versions. Possible values: true, false. Note: To remain PCI-compliant, do not enable this option.</li><li><b>naked_domain_san_for_new_www_sites</b> Use this option to determine if the naked domain SAN will be added to the SSL certificate for new www sites. Default value: true.</li><li><b>wildcard_san_for_new_sites</b> Use this option to determine if the wildcard SAN or the full domain SAN is added to the Imperva SSL certificate for new sites. Possible values: true, false, default (determined by plan) Default value: default.</li><li><b>ref_id</b> Sets the Reference ID, a free-text field that enables you to add a unique identifier to correlate an object in our service, such as a protected website, with an object on the customer side.</li><li><b>enable_http2_for_new_sites</b> Use this option to enable HTTP/2 for newly created SSL sites.</li><li><b>enable_http2_to_origin_for_new_sites</b> Use this option to enable HTTP/2 to Origin for newly created SSL sites. This option can only be enabled once HTTP/2 is enabled for newly created sites.</li><li><b>consent_required</b> Blocks Imperva from performing sensitive operations on your behalf. You can then activate consent via the Cloud Security Console UI. Possible values: true, false..</li></ul> (required)
        :param str value: According to the configuration paramater used. (required)
        :param str body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_account_configuration_with_http_info(param, value, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_account_configuration_with_http_info(param, value, **kwargs)  # noqa: E501
            return data

    def modify_account_configuration_with_http_info(self, param, value, **kwargs):  # noqa: E501
        """Modify account configuration  # noqa: E501

        Use this operation to change the configuration of the account of the API client or one of its managed accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_account_configuration_with_http_info(param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>name</b> the updated name.</li><li><b>email</b> the updated e-mail address</li><li><b>plan_id</b> a plan id</li><li><b>error_page_template</b> a Base64 encoded template for an error page.</li><li><b>support_all_tls_versions</b> Use this operation to allow sites in the account to support all TLS versions for connectivity between clients (visitors) and the Imperva service. When this option is set, you can then enable the option per site to support all TLS versions. Possible values: true, false. Note: To remain PCI-compliant, do not enable this option.</li><li><b>naked_domain_san_for_new_www_sites</b> Use this option to determine if the naked domain SAN will be added to the SSL certificate for new www sites. Default value: true.</li><li><b>wildcard_san_for_new_sites</b> Use this option to determine if the wildcard SAN or the full domain SAN is added to the Imperva SSL certificate for new sites. Possible values: true, false, default (determined by plan) Default value: default.</li><li><b>ref_id</b> Sets the Reference ID, a free-text field that enables you to add a unique identifier to correlate an object in our service, such as a protected website, with an object on the customer side.</li><li><b>enable_http2_for_new_sites</b> Use this option to enable HTTP/2 for newly created SSL sites.</li><li><b>enable_http2_to_origin_for_new_sites</b> Use this option to enable HTTP/2 to Origin for newly created SSL sites. This option can only be enabled once HTTP/2 is enabled for newly created sites.</li><li><b>consent_required</b> Blocks Imperva from performing sensitive operations on your behalf. You can then activate consent via the Cloud Security Console UI. Possible values: true, false..</li></ul> (required)
        :param str value: According to the configuration paramater used. (required)
        :param str body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['param', 'value', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_account_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'param' is set
        if ('param' not in params or
                params['param'] is None):
            raise ValueError("Missing the required parameter `param` when calling `modify_account_configuration`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `modify_account_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'param' in params:
            query_params.append(('param', params['param']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/configure', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_account_log_level(self, log_level, **kwargs):  # noqa: E501
        """Modify account log level  # noqa: E501

        Available for Reseller accounts only<br/>Use this operation to change the account log configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_account_log_level(log_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_level: Sets the log reporting level for the site.<br/> Possible values: full | security | none | default<br/>Available only for customers that purchased the Log Integration SKU. (required)
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_account_log_level_with_http_info(log_level, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_account_log_level_with_http_info(log_level, **kwargs)  # noqa: E501
            return data

    def modify_account_log_level_with_http_info(self, log_level, **kwargs):  # noqa: E501
        """Modify account log level  # noqa: E501

        Available for Reseller accounts only<br/>Use this operation to change the account log configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_account_log_level_with_http_info(log_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str log_level: Sets the log reporting level for the site.<br/> Possible values: full | security | none | default<br/>Available only for customers that purchased the Log Integration SKU. (required)
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_level', 'account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_account_log_level" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_level' is set
        if ('log_level' not in params or
                params['log_level'] is None):
            raise ValueError("Missing the required parameter `log_level` when calling `modify_account_log_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'log_level' in params:
            query_params.append(('log_level', params['log_level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/setlog', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_region(self, **kwargs):  # noqa: E501
        """Set default data storage region  # noqa: E501

        Use this operation to set the default data region of the account for newly created sites. (Available for Reseller accounts only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_region(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str data_storage_region: The data region to use.<br/>Possible values: US | EU | APAC | AU
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_default_region_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_default_region_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_default_region_with_http_info(self, **kwargs):  # noqa: E501
        """Set default data storage region  # noqa: E501

        Use this operation to set the default data region of the account for newly created sites. (Available for Reseller accounts only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_region_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str data_storage_region: The data region to use.<br/>Possible values: US | EU | APAC | AU
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'data_storage_region']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_region" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'data_storage_region' in params:
            query_params.append(('data_storage_region', params['data_storage_region']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/data-privacy/set-region-default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_siem_storage(self, account_id, **kwargs):  # noqa: E501
        """Set Imperva servers for log storage  # noqa: E501

        Use this operation to have your logs saved on Incapsula servers. Once configured, the logs can be retrieved by API calls.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_siem_storage(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_default_siem_storage_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_default_siem_storage_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def set_default_siem_storage_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Set Imperva servers for log storage  # noqa: E501

        Use this operation to have your logs saved on Incapsula servers. Once configured, the logs can be retrieved by API calls.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_siem_storage_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_siem_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_default_siem_storage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/setDefaultSiemStorage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_storage_to_s3(self, account_id, bucket_name, access_key, secret_key, **kwargs):  # noqa: E501
        """Set S3 configuration for log storage  # noqa: E501

        Use this operation to configure your Amazon cloud storage. Once configured, Imperva logs will be uploaded to the selected location.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_storage_to_s3(account_id, bucket_name, access_key, secret_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str bucket_name: S3 bucket name (required)
        :param str access_key: S3 access key (required)
        :param str secret_key: S3 secret key (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_storage_to_s3_with_http_info(account_id, bucket_name, access_key, secret_key, **kwargs)  # noqa: E501
        else:
            (data) = self.set_storage_to_s3_with_http_info(account_id, bucket_name, access_key, secret_key, **kwargs)  # noqa: E501
            return data

    def set_storage_to_s3_with_http_info(self, account_id, bucket_name, access_key, secret_key, **kwargs):  # noqa: E501
        """Set S3 configuration for log storage  # noqa: E501

        Use this operation to configure your Amazon cloud storage. Once configured, Imperva logs will be uploaded to the selected location.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_storage_to_s3_with_http_info(account_id, bucket_name, access_key, secret_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str bucket_name: S3 bucket name (required)
        :param str access_key: S3 access key (required)
        :param str secret_key: S3 secret key (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'bucket_name', 'access_key', 'secret_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_storage_to_s3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_storage_to_s3`")  # noqa: E501
        # verify the required parameter 'bucket_name' is set
        if ('bucket_name' not in params or
                params['bucket_name'] is None):
            raise ValueError("Missing the required parameter `bucket_name` when calling `set_storage_to_s3`")  # noqa: E501
        # verify the required parameter 'access_key' is set
        if ('access_key' not in params or
                params['access_key'] is None):
            raise ValueError("Missing the required parameter `access_key` when calling `set_storage_to_s3`")  # noqa: E501
        # verify the required parameter 'secret_key' is set
        if ('secret_key' not in params or
                params['secret_key'] is None):
            raise ValueError("Missing the required parameter `secret_key` when calling `set_storage_to_s3`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'bucket_name' in params:
            query_params.append(('bucket_name', params['bucket_name']))  # noqa: E501
        if 'access_key' in params:
            query_params.append(('access_key', params['access_key']))  # noqa: E501
        if 'secret_key' in params:
            query_params.append(('secret_key', params['secret_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/setAmazonSiemStorage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_storage_to_sftp(self, account_id, host, user_name, password, destination_folder, **kwargs):  # noqa: E501
        """Set SFTP server configuration for log storage  # noqa: E501

        Use this operation to configure your SFTP server storage. Once configured, Incapsula logs will be uploaded to the selected location.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_storage_to_sftp(account_id, host, user_name, password, destination_folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str host: The IP address of your SFTP server (required)
        :param str user_name: A user name that will be used to log in to the SFTP server (required)
        :param str password: A corresponding password for the user account used to log in to the SFTP server (required)
        :param str destination_folder: The path to the directory on the SFTP server (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_storage_to_sftp_with_http_info(account_id, host, user_name, password, destination_folder, **kwargs)  # noqa: E501
        else:
            (data) = self.set_storage_to_sftp_with_http_info(account_id, host, user_name, password, destination_folder, **kwargs)  # noqa: E501
            return data

    def set_storage_to_sftp_with_http_info(self, account_id, host, user_name, password, destination_folder, **kwargs):  # noqa: E501
        """Set SFTP server configuration for log storage  # noqa: E501

        Use this operation to configure your SFTP server storage. Once configured, Incapsula logs will be uploaded to the selected location.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_storage_to_sftp_with_http_info(account_id, host, user_name, password, destination_folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str host: The IP address of your SFTP server (required)
        :param str user_name: A user name that will be used to log in to the SFTP server (required)
        :param str password: A corresponding password for the user account used to log in to the SFTP server (required)
        :param str destination_folder: The path to the directory on the SFTP server (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'host', 'user_name', 'password', 'destination_folder']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_storage_to_sftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_storage_to_sftp`")  # noqa: E501
        # verify the required parameter 'host' is set
        if ('host' not in params or
                params['host'] is None):
            raise ValueError("Missing the required parameter `host` when calling `set_storage_to_sftp`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `set_storage_to_sftp`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `set_storage_to_sftp`")  # noqa: E501
        # verify the required parameter 'destination_folder' is set
        if ('destination_folder' not in params or
                params['destination_folder'] is None):
            raise ValueError("Missing the required parameter `destination_folder` when calling `set_storage_to_sftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501
        if 'user_name' in params:
            query_params.append(('user_name', params['user_name']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501
        if 'destination_folder' in params:
            query_params.append(('destination_folder', params['destination_folder']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/setSftpSiemStorage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscription(self, **kwargs):  # noqa: E501
        """Get account subscription details  # noqa: E501

        Use this operation to get subscription details for an account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscription(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscription_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.subscription_with_http_info(**kwargs)  # noqa: E501
            return data

    def subscription_with_http_info(self, **kwargs):  # noqa: E501
        """Get account subscription details  # noqa: E501

        Use this operation to get subscription details for an account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscription_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscription" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/subscription', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_connection_s3(self, account_id, bucket_name, access_key, secret_key, **kwargs):  # noqa: E501
        """Test connection with S3 bucket  # noqa: E501

        Use this operation to check that a connection can be created with your Amazon S3 bucket.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_connection_s3(account_id, bucket_name, access_key, secret_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str bucket_name: S3 bucket name (required)
        :param str access_key: S3 access key (required)
        :param str secret_key: S3 secret key (required)
        :param bool save_on_success: Save this configuration if the test connection was successful. Default value:false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_connection_s3_with_http_info(account_id, bucket_name, access_key, secret_key, **kwargs)  # noqa: E501
        else:
            (data) = self.test_connection_s3_with_http_info(account_id, bucket_name, access_key, secret_key, **kwargs)  # noqa: E501
            return data

    def test_connection_s3_with_http_info(self, account_id, bucket_name, access_key, secret_key, **kwargs):  # noqa: E501
        """Test connection with S3 bucket  # noqa: E501

        Use this operation to check that a connection can be created with your Amazon S3 bucket.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_connection_s3_with_http_info(account_id, bucket_name, access_key, secret_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on (required)
        :param str bucket_name: S3 bucket name (required)
        :param str access_key: S3 access key (required)
        :param str secret_key: S3 secret key (required)
        :param bool save_on_success: Save this configuration if the test connection was successful. Default value:false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'bucket_name', 'access_key', 'secret_key', 'save_on_success']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_connection_s3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `test_connection_s3`")  # noqa: E501
        # verify the required parameter 'bucket_name' is set
        if ('bucket_name' not in params or
                params['bucket_name'] is None):
            raise ValueError("Missing the required parameter `bucket_name` when calling `test_connection_s3`")  # noqa: E501
        # verify the required parameter 'access_key' is set
        if ('access_key' not in params or
                params['access_key'] is None):
            raise ValueError("Missing the required parameter `access_key` when calling `test_connection_s3`")  # noqa: E501
        # verify the required parameter 'secret_key' is set
        if ('secret_key' not in params or
                params['secret_key'] is None):
            raise ValueError("Missing the required parameter `secret_key` when calling `test_connection_s3`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'bucket_name' in params:
            query_params.append(('bucket_name', params['bucket_name']))  # noqa: E501
        if 'access_key' in params:
            query_params.append(('access_key', params['access_key']))  # noqa: E501
        if 'secret_key' in params:
            query_params.append(('secret_key', params['secret_key']))  # noqa: E501
        if 'save_on_success' in params:
            query_params.append(('save_on_success', params['save_on_success']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/testS3Connection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_connection_sftp(self, account_id, host, user_name, password, destination_folder, **kwargs):  # noqa: E501
        """Test connection with SFTP server  # noqa: E501

        Use this operation to check that a connection can be created with your SFTP storage.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_connection_sftp(account_id, host, user_name, password, destination_folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on. (required)
        :param str host: The IP address of your SFTP server (required)
        :param str user_name: A user name that will be used to log in to the SFTP server (required)
        :param str password: A corresponding password for the user account used to log in to the SFTP server (required)
        :param str destination_folder: The path to the directory on the SFTP server (required)
        :param bool save_on_success: Save this configuration if the test connection was successful. Default value: false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_connection_sftp_with_http_info(account_id, host, user_name, password, destination_folder, **kwargs)  # noqa: E501
        else:
            (data) = self.test_connection_sftp_with_http_info(account_id, host, user_name, password, destination_folder, **kwargs)  # noqa: E501
            return data

    def test_connection_sftp_with_http_info(self, account_id, host, user_name, password, destination_folder, **kwargs):  # noqa: E501
        """Test connection with SFTP server  # noqa: E501

        Use this operation to check that a connection can be created with your SFTP storage.  **Note:** Before this operation can be used, logs must be activated using /api/prov/v1/waf-log-setup/activate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_connection_sftp_with_http_info(account_id, host, user_name, password, destination_folder, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on. (required)
        :param str host: The IP address of your SFTP server (required)
        :param str user_name: A user name that will be used to log in to the SFTP server (required)
        :param str password: A corresponding password for the user account used to log in to the SFTP server (required)
        :param str destination_folder: The path to the directory on the SFTP server (required)
        :param bool save_on_success: Save this configuration if the test connection was successful. Default value: false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'host', 'user_name', 'password', 'destination_folder', 'save_on_success']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_connection_sftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `test_connection_sftp`")  # noqa: E501
        # verify the required parameter 'host' is set
        if ('host' not in params or
                params['host'] is None):
            raise ValueError("Missing the required parameter `host` when calling `test_connection_sftp`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `test_connection_sftp`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `test_connection_sftp`")  # noqa: E501
        # verify the required parameter 'destination_folder' is set
        if ('destination_folder' not in params or
                params['destination_folder'] is None):
            raise ValueError("Missing the required parameter `destination_folder` when calling `test_connection_sftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501
        if 'user_name' in params:
            query_params.append(('user_name', params['user_name']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501
        if 'destination_folder' in params:
            query_params.append(('destination_folder', params['destination_folder']))  # noqa: E501
        if 'save_on_success' in params:
            query_params.append(('save_on_success', params['save_on_success']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/accounts/testSftpConnection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
