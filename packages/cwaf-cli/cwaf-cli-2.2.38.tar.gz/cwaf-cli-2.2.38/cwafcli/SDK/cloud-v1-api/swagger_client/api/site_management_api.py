# coding: utf-8

"""
    Cloud Application Security API

    Imperva provides customers and partners with the ability to manage accounts and sites via an API. For more information, see <a style=\"text-decoration:none\" href=\"https://docs.imperva.com/csh?context=my_api\">Cloud Application Security API Reference</a>.  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SiteManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_cache_rule(self, action, site_id, name, **kwargs):  # noqa: E501
        """Add a cache rule  # noqa: E501

        Use this operation for adding a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cache_rule(action, site_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See Possible action parameter values.<br/>Possible action parameter values:<br/><ul><li><b>HTTP_CACHE_MAKE_STATIC</b> Cache Resource</li><li><b>HTTP_CACHE_CLIENT_CACHE_CTL</b> Cache Resource on Client</li><li><b>HTTP_CACHE_FORCE_UNCACHEABLE</b> Don't Cache Resource</li><li><b>HTTP_CACHE_DIFFERENTIATE_SSL</b> Differentiate Cache Key by HTTP/HTTPS Scheme</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_HEADER</b> Differentiate Cache Key by Header</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_COOKIE</b> Differentiate Cache Key by Cookie</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_GEO</b> Differentiate Cache Key by Geolocation</li><li><b>HTTP_CACHE_IGNORE_PARAMS</b> Ignore Parameters in Cache Key</li><li><b>HTTP_CACHE_IGNORE_AUTH_HEADER</b> Cache Authenticated Resources</li><li><b>HTTP_CACHE_FORCE_VALIDATION</b> Force User Authentication</li><li><b>HTTP_CACHE_ADD_TAG</b> Create Tag</li><li><b>HTTP_CACHE_ENRICH_CACHE_KEY</b> Enrich Cache Key</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filters, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param str ttl: Rule TTL. Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str ttl_unit: Rule TTL time unit.<br/>Must be one of SECONDS, MINUTES, HOURS, DAYS or WEEKS. If no time unit is provided, SECONDS is used.<br/>Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str differentiated_by_value: Value to differentiate by. HTTP_CACHE_DIFFERENTIATE_BY_HEADER - header name, HTTP_CACHE_DIFFERENTIATE_BY_COOKIE - cookie name, HTTP_CACHE_DIFFERENTIATE_BY_GEO - geo location <br/>(ISO 3166-1 alpha-2 country codes ), otherwise irrelevant.
        :param str params: Comma separated list of parameters to ignore. Parameters name must be alphanumeric.
        :param bool _all_params: When set to <b>true</b>: all parameters in cache key will be ignored.<br/>Default: false.<br/>Relevant for HTTP_CACHE_IGNORE_PARAMS action
        :param str tag_name: The name of the tag to add.
        :param str text: Add text to the cache key as suffix. Relevant for the HTTP_CACHE_ENRICH_CACHE_KEY action
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_cache_rule_with_http_info(action, site_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_cache_rule_with_http_info(action, site_id, name, **kwargs)  # noqa: E501
            return data

    def add_cache_rule_with_http_info(self, action, site_id, name, **kwargs):  # noqa: E501
        """Add a cache rule  # noqa: E501

        Use this operation for adding a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cache_rule_with_http_info(action, site_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See Possible action parameter values.<br/>Possible action parameter values:<br/><ul><li><b>HTTP_CACHE_MAKE_STATIC</b> Cache Resource</li><li><b>HTTP_CACHE_CLIENT_CACHE_CTL</b> Cache Resource on Client</li><li><b>HTTP_CACHE_FORCE_UNCACHEABLE</b> Don't Cache Resource</li><li><b>HTTP_CACHE_DIFFERENTIATE_SSL</b> Differentiate Cache Key by HTTP/HTTPS Scheme</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_HEADER</b> Differentiate Cache Key by Header</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_COOKIE</b> Differentiate Cache Key by Cookie</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_GEO</b> Differentiate Cache Key by Geolocation</li><li><b>HTTP_CACHE_IGNORE_PARAMS</b> Ignore Parameters in Cache Key</li><li><b>HTTP_CACHE_IGNORE_AUTH_HEADER</b> Cache Authenticated Resources</li><li><b>HTTP_CACHE_FORCE_VALIDATION</b> Force User Authentication</li><li><b>HTTP_CACHE_ADD_TAG</b> Create Tag</li><li><b>HTTP_CACHE_ENRICH_CACHE_KEY</b> Enrich Cache Key</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filters, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param str ttl: Rule TTL. Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str ttl_unit: Rule TTL time unit.<br/>Must be one of SECONDS, MINUTES, HOURS, DAYS or WEEKS. If no time unit is provided, SECONDS is used.<br/>Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str differentiated_by_value: Value to differentiate by. HTTP_CACHE_DIFFERENTIATE_BY_HEADER - header name, HTTP_CACHE_DIFFERENTIATE_BY_COOKIE - cookie name, HTTP_CACHE_DIFFERENTIATE_BY_GEO - geo location <br/>(ISO 3166-1 alpha-2 country codes ), otherwise irrelevant.
        :param str params: Comma separated list of parameters to ignore. Parameters name must be alphanumeric.
        :param bool _all_params: When set to <b>true</b>: all parameters in cache key will be ignored.<br/>Default: false.<br/>Relevant for HTTP_CACHE_IGNORE_PARAMS action
        :param str tag_name: The name of the tag to add.
        :param str text: Add text to the cache key as suffix. Relevant for the HTTP_CACHE_ENRICH_CACHE_KEY action
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'site_id', 'name', 'filter', 'ttl', 'ttl_unit', 'differentiated_by_value', 'params', '_all_params', 'tag_name', 'text']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_cache_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `add_cache_rule`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `add_cache_rule`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `add_cache_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501
        if 'ttl_unit' in params:
            query_params.append(('ttl_unit', params['ttl_unit']))  # noqa: E501
        if 'differentiated_by_value' in params:
            query_params.append(('differentiated_by_value', params['differentiated_by_value']))  # noqa: E501
        if 'params' in params:
            query_params.append(('params', params['params']))  # noqa: E501
        if '_all_params' in params:
            query_params.append(('all_params', params['_all_params']))  # noqa: E501
        if 'tag_name' in params:
            query_params.append(('tag_name', params['tag_name']))  # noqa: E501
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/caching-rules/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_custom_rule(self, action, site_id, name, filter, **kwargs):  # noqa: E501
        """Add rule  # noqa: E501

        Use this operation to add a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_custom_rule(action, site_id, name, filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See the possible values in the table below.<br/>Possible action parameter values for Delivery Rules:<br/><ul><li><b>RULE_ACTION_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_SIMPLIFIED_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_REWRITE_URL</b> Modify the path to which a specific request is targeted.</li><li><b>RULE_ACTION_REWRITE_HEADER</b> Modify or add a request header before passing traffic to the origin server.</li><li><b>RULE_ACTION_REWRITE_COOKIE</b> Modify or add cookies that are sent by the client to the origin server. The cookie name and value should be indicated.</li><li><b>RULE_ACTION_DELETE_HEADER</b> Remove a specific request header, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_DELETE_COOKIE</b> Remove a specific cookie set on the client, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_FORWARD_TO_DC</b> Define the data center to which a specific request will be sent.</li><li><b>RULE_ACTION_FORWARD_TO_PORT</b> Define the port to which a specific request will be sent.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_HEADER</b> Modify or add a header to the response received from the origin server.</li><li><b>RULE_ACTION_RESPONSE_DELETE_HEADER</b> Remove a specific response header, which means that it won't be returned to the client.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_RESPONSE_CODE</b> Modify the response code received from the origin server.</li></ul><br/>Possible action parameter values for security rules:<br/><ul><li><b>RULE_ACTION_ALERT</b> Generate a non blocking alert for this event.</li><li><b>RULE_ACTION_BLOCK</b> Block the current request and generate an alert for this event.</li><li><b>RULE_ACTION_BLOCK_USER</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_BLOCK_IP</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_RETRY</b> Require any client matching the rule filters to support cookies in order to complete the request.</li><li><b>RULE_ACTION_INTRUSIVE_HTML</b> Require any client matching the rule filters to support javascript in order to complete the request. Since the Javascript test is embedded in an HTML page, this action should only be enabled for HTML resources.</li><li><b>RULE_ACTION_CAPTCHA</b> Require any client matching the rule filters to pass a CAPTCHA test in order to complete the request. Since the CAPTCHA test is embedded in an HTML page, this action should only be enabled for HTML resources.</li></ul><br/>Possible action parameter values for counter (rate) rules:<br/><ul><li><b>RULE_ACTION_RATE</b> Count the number of requests received that match the rule filter.</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filter guidelines, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.<br/>The filter may contain up to 400 characters. (required)
        :param int response_code: Redirect rule's response code. Valid values are 302, 301, 303, 307, 308.
        :param str protocol:
        :param bool add_missing: Add cookie or header if it doesn't exist (Rewrite cookie rule only)
        :param str _from: The pattern to rewrite.<br/>For RULE_ACTION_REWRITE_URL - The URL to rewrite.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to rewrite.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to rewrite.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str to: The pattern to change to.<br/>For RULE_ACTION_REWRITE_URL - The URL to change to.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to change to.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to change to.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str rewrite_name: Name of cookie or header to rewrite. Applies only for RULE_ACTION_REWRITE_COOKIE and RULE_ACTION_REWRITE_HEADER.
        :param int dc_id: Data center to forward request to. Applies only for RULE_ACTION_FORWARD_TO_DC.
        :param bool allow_caching:
        :param bool is_test_mode: Apply the rule only to the IP address the API request was sent from.<br/>This option is not available for Simplified Redirect rules.
        :param str rate_context: The context of the rate counter. Possible values: IP / Session. Applies only to rules using RULE_ACTION_RATE.
        :param int rate_interval: The interval (in seconds) of the rate counter. Possible values: A multiple of 10 from 10-300. Applies only to rules using RULE_ACTION_RATE.
        :param str port_forwarding_context: Context for port forwarding. \"Use Port Value\" or \"Use Header Name\". Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param str port_forwarding_value: Port number or header name for port forwarding. Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param bool multiple_deletions: Delete multiple header occurrences. Applies only to rules using RULE_ACTION_DELETE_HEADER and RULE_ACTION_RESPONSE_DELETE_HEADER.
        :param bool rewrite_existing: Rewrite cookie or header if it exists
        :return: CustomRuleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_custom_rule_with_http_info(action, site_id, name, filter, **kwargs)  # noqa: E501
        else:
            (data) = self.add_custom_rule_with_http_info(action, site_id, name, filter, **kwargs)  # noqa: E501
            return data

    def add_custom_rule_with_http_info(self, action, site_id, name, filter, **kwargs):  # noqa: E501
        """Add rule  # noqa: E501

        Use this operation to add a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_custom_rule_with_http_info(action, site_id, name, filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See the possible values in the table below.<br/>Possible action parameter values for Delivery Rules:<br/><ul><li><b>RULE_ACTION_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_SIMPLIFIED_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_REWRITE_URL</b> Modify the path to which a specific request is targeted.</li><li><b>RULE_ACTION_REWRITE_HEADER</b> Modify or add a request header before passing traffic to the origin server.</li><li><b>RULE_ACTION_REWRITE_COOKIE</b> Modify or add cookies that are sent by the client to the origin server. The cookie name and value should be indicated.</li><li><b>RULE_ACTION_DELETE_HEADER</b> Remove a specific request header, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_DELETE_COOKIE</b> Remove a specific cookie set on the client, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_FORWARD_TO_DC</b> Define the data center to which a specific request will be sent.</li><li><b>RULE_ACTION_FORWARD_TO_PORT</b> Define the port to which a specific request will be sent.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_HEADER</b> Modify or add a header to the response received from the origin server.</li><li><b>RULE_ACTION_RESPONSE_DELETE_HEADER</b> Remove a specific response header, which means that it won't be returned to the client.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_RESPONSE_CODE</b> Modify the response code received from the origin server.</li></ul><br/>Possible action parameter values for security rules:<br/><ul><li><b>RULE_ACTION_ALERT</b> Generate a non blocking alert for this event.</li><li><b>RULE_ACTION_BLOCK</b> Block the current request and generate an alert for this event.</li><li><b>RULE_ACTION_BLOCK_USER</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_BLOCK_IP</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_RETRY</b> Require any client matching the rule filters to support cookies in order to complete the request.</li><li><b>RULE_ACTION_INTRUSIVE_HTML</b> Require any client matching the rule filters to support javascript in order to complete the request. Since the Javascript test is embedded in an HTML page, this action should only be enabled for HTML resources.</li><li><b>RULE_ACTION_CAPTCHA</b> Require any client matching the rule filters to pass a CAPTCHA test in order to complete the request. Since the CAPTCHA test is embedded in an HTML page, this action should only be enabled for HTML resources.</li></ul><br/>Possible action parameter values for counter (rate) rules:<br/><ul><li><b>RULE_ACTION_RATE</b> Count the number of requests received that match the rule filter.</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filter guidelines, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.<br/>The filter may contain up to 400 characters. (required)
        :param int response_code: Redirect rule's response code. Valid values are 302, 301, 303, 307, 308.
        :param str protocol:
        :param bool add_missing: Add cookie or header if it doesn't exist (Rewrite cookie rule only)
        :param str _from: The pattern to rewrite.<br/>For RULE_ACTION_REWRITE_URL - The URL to rewrite.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to rewrite.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to rewrite.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str to: The pattern to change to.<br/>For RULE_ACTION_REWRITE_URL - The URL to change to.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to change to.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to change to.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str rewrite_name: Name of cookie or header to rewrite. Applies only for RULE_ACTION_REWRITE_COOKIE and RULE_ACTION_REWRITE_HEADER.
        :param int dc_id: Data center to forward request to. Applies only for RULE_ACTION_FORWARD_TO_DC.
        :param bool allow_caching:
        :param bool is_test_mode: Apply the rule only to the IP address the API request was sent from.<br/>This option is not available for Simplified Redirect rules.
        :param str rate_context: The context of the rate counter. Possible values: IP / Session. Applies only to rules using RULE_ACTION_RATE.
        :param int rate_interval: The interval (in seconds) of the rate counter. Possible values: A multiple of 10 from 10-300. Applies only to rules using RULE_ACTION_RATE.
        :param str port_forwarding_context: Context for port forwarding. \"Use Port Value\" or \"Use Header Name\". Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param str port_forwarding_value: Port number or header name for port forwarding. Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param bool multiple_deletions: Delete multiple header occurrences. Applies only to rules using RULE_ACTION_DELETE_HEADER and RULE_ACTION_RESPONSE_DELETE_HEADER.
        :param bool rewrite_existing: Rewrite cookie or header if it exists
        :return: CustomRuleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'site_id', 'name', 'filter', 'response_code', 'protocol', 'add_missing', '_from', 'to', 'rewrite_name', 'dc_id', 'allow_caching', 'is_test_mode', 'rate_context', 'rate_interval', 'port_forwarding_context', 'port_forwarding_value', 'multiple_deletions', 'rewrite_existing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_custom_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `add_custom_rule`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `add_custom_rule`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `add_custom_rule`")  # noqa: E501
        # verify the required parameter 'filter' is set
        if ('filter' not in params or
                params['filter'] is None):
            raise ValueError("Missing the required parameter `filter` when calling `add_custom_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'response_code' in params:
            query_params.append(('response_code', params['response_code']))  # noqa: E501
        if 'protocol' in params:
            query_params.append(('protocol', params['protocol']))  # noqa: E501
        if 'add_missing' in params:
            query_params.append(('add_missing', params['add_missing']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'rewrite_name' in params:
            query_params.append(('rewrite_name', params['rewrite_name']))  # noqa: E501
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501
        if 'allow_caching' in params:
            query_params.append(('allow_caching', params['allow_caching']))  # noqa: E501
        if 'is_test_mode' in params:
            query_params.append(('is_test_mode', params['is_test_mode']))  # noqa: E501
        if 'rate_context' in params:
            query_params.append(('rate_context', params['rate_context']))  # noqa: E501
        if 'rate_interval' in params:
            query_params.append(('rate_interval', params['rate_interval']))  # noqa: E501
        if 'port_forwarding_context' in params:
            query_params.append(('port_forwarding_context', params['port_forwarding_context']))  # noqa: E501
        if 'port_forwarding_value' in params:
            query_params.append(('port_forwarding_value', params['port_forwarding_value']))  # noqa: E501
        if 'multiple_deletions' in params:
            query_params.append(('multiple_deletions', params['multiple_deletions']))  # noqa: E501
        if 'rewrite_existing' in params:
            query_params.append(('rewrite_existing', params['rewrite_existing']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomRuleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_data_center(self, site_id, name, server_address, **kwargs):  # noqa: E501
        """Add data center  # noqa: E501

        Use this operation for adding data center to site.<br/>You can configure up to 40 data centers per site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_data_center(site_id, name, server_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: The new data center's name. (required)
        :param str server_address: The server's address. Possible values: IP, CNAME (required)
        :param str lb_algorithm: Data center load balancing algorithm. Possible values are:<br/>LB_LEAST_PENDING_REQUESTS - Server with least pending requests<br/>LB_LEAST_OPEN_CONNECTIONS - Server with least open connections<br/>LB_SOURCE_IP_HASH - Server by IP hash<br/>RANDOM - Random server<br/>WEIGHTED - Server by weight
        :param bool is_enabled: Enables the data center.
        :param bool is_content: The data center will be available for specific resources (<b>Forward</b> Delivery Rules).
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_data_center_with_http_info(site_id, name, server_address, **kwargs)  # noqa: E501
        else:
            (data) = self.add_data_center_with_http_info(site_id, name, server_address, **kwargs)  # noqa: E501
            return data

    def add_data_center_with_http_info(self, site_id, name, server_address, **kwargs):  # noqa: E501
        """Add data center  # noqa: E501

        Use this operation for adding data center to site.<br/>You can configure up to 40 data centers per site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_data_center_with_http_info(site_id, name, server_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str name: The new data center's name. (required)
        :param str server_address: The server's address. Possible values: IP, CNAME (required)
        :param str lb_algorithm: Data center load balancing algorithm. Possible values are:<br/>LB_LEAST_PENDING_REQUESTS - Server with least pending requests<br/>LB_LEAST_OPEN_CONNECTIONS - Server with least open connections<br/>LB_SOURCE_IP_HASH - Server by IP hash<br/>RANDOM - Random server<br/>WEIGHTED - Server by weight
        :param bool is_enabled: Enables the data center.
        :param bool is_content: The data center will be available for specific resources (<b>Forward</b> Delivery Rules).
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'name', 'server_address', 'lb_algorithm', 'is_enabled', 'is_content']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_data_center" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `add_data_center`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `add_data_center`")  # noqa: E501
        # verify the required parameter 'server_address' is set
        if ('server_address' not in params or
                params['server_address'] is None):
            raise ValueError("Missing the required parameter `server_address` when calling `add_data_center`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'server_address' in params:
            query_params.append(('server_address', params['server_address']))  # noqa: E501
        if 'lb_algorithm' in params:
            query_params.append(('lb_algorithm', params['lb_algorithm']))  # noqa: E501
        if 'is_enabled' in params:
            query_params.append(('is_enabled', params['is_enabled']))  # noqa: E501
        if 'is_content' in params:
            query_params.append(('is_content', params['is_content']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dc_server(self, dc_id, server_address, **kwargs):  # noqa: E501
        """Add server  # noqa: E501

        Use this operation to add a server to a data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dc_server(dc_id, server_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :param str server_address: Server IP address. (required)
        :param bool is_disabled: Enables the data center
        :param bool is_standby: Set the server as Active (P0) or Standby (P1) (Boolean).
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dc_server_with_http_info(dc_id, server_address, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dc_server_with_http_info(dc_id, server_address, **kwargs)  # noqa: E501
            return data

    def add_dc_server_with_http_info(self, dc_id, server_address, **kwargs):  # noqa: E501
        """Add server  # noqa: E501

        Use this operation to add a server to a data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dc_server_with_http_info(dc_id, server_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :param str server_address: Server IP address. (required)
        :param bool is_disabled: Enables the data center
        :param bool is_standby: Set the server as Active (P0) or Standby (P1) (Boolean).
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dc_id', 'server_address', 'is_disabled', 'is_standby']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dc_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dc_id' is set
        if ('dc_id' not in params or
                params['dc_id'] is None):
            raise ValueError("Missing the required parameter `dc_id` when calling `add_dc_server`")  # noqa: E501
        # verify the required parameter 'server_address' is set
        if ('server_address' not in params or
                params['server_address'] is None):
            raise ValueError("Missing the required parameter `server_address` when calling `add_dc_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501
        if 'server_address' in params:
            query_params.append(('server_address', params['server_address']))  # noqa: E501
        if 'is_disabled' in params:
            query_params.append(('is_disabled', params['is_disabled']))  # noqa: E501
        if 'is_standby' in params:
            query_params.append(('is_standby', params['is_standby']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/servers/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_site(self, domain, **kwargs):  # noqa: E501
        """Add a site  # noqa: E501

        Add a new site to an account. If the site already exists, its status is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_site(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain: The domain name of the site. For example: <a href=\"www.example.com\">www.example.com</a>, <a href=\"hello.example.com\">www.example.com</a>, <a href=\"example.com\">www.example.com</a> (required)
        :param str body:
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str ref_id: Customer specific identifier for this operation
        :param str send_site_setup_emails: If this value is false, end users will not get emails about the add site process such as DNS instructions and SSL setup.
        :param str site_ip: Manually set the web server IP/CNAME
        :param str force_ssl: If this value is true, manually set the site to support SSL.<br/>This option is only available for sites with manually configured IP/CNAME and for specific accounts.
        :param str naked_domain_san: Use “true” to add the naked domain SAN to a www site’s SSL certificate. Default value: true
        :param str wildcard_san: Use “true” to add the wildcard SAN or “false” to add the full domain SAN to the site’s SSL certificate. Default value: true
        :param str log_level: Available only for customers that purchased the Logs Integration SKU.<br/>Sets the log reporting level for the site. Options are “full”, “security”, “none” and default
        :param str logs_account_id: Available only for customers that purchased the Logs Integration SKU.<br/>Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_site_with_http_info(domain, **kwargs)  # noqa: E501
        else:
            (data) = self.add_site_with_http_info(domain, **kwargs)  # noqa: E501
            return data

    def add_site_with_http_info(self, domain, **kwargs):  # noqa: E501
        """Add a site  # noqa: E501

        Add a new site to an account. If the site already exists, its status is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_site_with_http_info(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain: The domain name of the site. For example: <a href=\"www.example.com\">www.example.com</a>, <a href=\"hello.example.com\">www.example.com</a>, <a href=\"example.com\">www.example.com</a> (required)
        :param str body:
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.
        :param str ref_id: Customer specific identifier for this operation
        :param str send_site_setup_emails: If this value is false, end users will not get emails about the add site process such as DNS instructions and SSL setup.
        :param str site_ip: Manually set the web server IP/CNAME
        :param str force_ssl: If this value is true, manually set the site to support SSL.<br/>This option is only available for sites with manually configured IP/CNAME and for specific accounts.
        :param str naked_domain_san: Use “true” to add the naked domain SAN to a www site’s SSL certificate. Default value: true
        :param str wildcard_san: Use “true” to add the wildcard SAN or “false” to add the full domain SAN to the site’s SSL certificate. Default value: true
        :param str log_level: Available only for customers that purchased the Logs Integration SKU.<br/>Sets the log reporting level for the site. Options are “full”, “security”, “none” and default
        :param str logs_account_id: Available only for customers that purchased the Logs Integration SKU.<br/>Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain', 'body', 'account_id', 'ref_id', 'send_site_setup_emails', 'site_ip', 'force_ssl', 'naked_domain_san', 'wildcard_san', 'log_level', 'logs_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain' is set
        if ('domain' not in params or
                params['domain'] is None):
            raise ValueError("Missing the required parameter `domain` when calling `add_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'domain' in params:
            query_params.append(('domain', params['domain']))  # noqa: E501
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'ref_id' in params:
            query_params.append(('ref_id', params['ref_id']))  # noqa: E501
        if 'send_site_setup_emails' in params:
            query_params.append(('send_site_setup_emails', params['send_site_setup_emails']))  # noqa: E501
        if 'site_ip' in params:
            query_params.append(('site_ip', params['site_ip']))  # noqa: E501
        if 'force_ssl' in params:
            query_params.append(('force_ssl', params['force_ssl']))  # noqa: E501
        if 'naked_domain_san' in params:
            query_params.append(('naked_domain_san', params['naked_domain_san']))  # noqa: E501
        if 'wildcard_san' in params:
            query_params.append(('wildcard_san', params['wildcard_san']))  # noqa: E501
        if 'log_level' in params:
            query_params.append(('log_level', params['log_level']))  # noqa: E501
        if 'logs_account_id' in params:
            query_params.append(('logs_account_id', params['logs_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_caa_compliance(self, site_id, **kwargs):  # noqa: E501
        """Check CAA compliance  # noqa: E501

        Check site’s associated SANs for CAA compliance. If a given SAN is compliant, its SSL domain validation status is updated accordingly.This operation returns an updated list of the site’s associated SANs that are not compliant. An empty list indicates that all SANs are compliant.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_caa_compliance(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: CaaComplianceCheckResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_caa_compliance_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_caa_compliance_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def check_caa_compliance_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Check CAA compliance  # noqa: E501

        Check site’s associated SANs for CAA compliance. If a given SAN is compliant, its SSL domain validation status is updated accordingly.This operation returns an updated list of the site’s associated SANs that are not compliant. An empty list indicates that all SANs are compliant.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_caa_compliance_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: CaaComplianceCheckResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_caa_compliance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `check_caa_compliance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/caa/check-compliance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CaaComplianceCheckResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_new_csr(self, site_id, **kwargs):  # noqa: E501
        """Create new CSR  # noqa: E501

        Use this operation to create a certificate signing request (CSR) for your site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_csr(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on (required)
        :param str domain: common name. For example: example.com
        :param str email: Email address. For example: joe@example.com
        :param str country: The two-letter ISO code for the country where your organization is located
        :param str state: The state/region where your organization is located. This should not be abbreviated
        :param str city: The city where your organization is located
        :param str organization: The legal name of your organization. This should not be abbreviated or include suffixes such as Inc., Corp., or LLC
        :param str organization_unit: The division of your organization handling the certificate. For example, IT Department
        :return: CreateNewCSRResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_new_csr_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_new_csr_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def create_new_csr_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Create new CSR  # noqa: E501

        Use this operation to create a certificate signing request (CSR) for your site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_csr_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on (required)
        :param str domain: common name. For example: example.com
        :param str email: Email address. For example: joe@example.com
        :param str country: The two-letter ISO code for the country where your organization is located
        :param str state: The state/region where your organization is located. This should not be abbreviated
        :param str city: The city where your organization is located
        :param str organization: The legal name of your organization. This should not be abbreviated or include suffixes such as Inc., Corp., or LLC
        :param str organization_unit: The division of your organization handling the certificate. For example, IT Department
        :return: CreateNewCSRResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'domain', 'email', 'country', 'state', 'city', 'organization', 'organization_unit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `create_new_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'domain' in params:
            query_params.append(('domain', params['domain']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'city' in params:
            query_params.append(('city', params['city']))  # noqa: E501
        if 'organization' in params:
            query_params.append(('organization', params['organization']))  # noqa: E501
        if 'organization_unit' in params:
            query_params.append(('organization_unit', params['organization_unit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/customCertificate/csr', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateNewCSRResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cache_rule(self, site_id, rule_id, **kwargs):  # noqa: E501
        """Delete a cache rule  # noqa: E501

        Use this operation for deleting a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cache_rule(site_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: ID of the rule to change. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cache_rule_with_http_info(site_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cache_rule_with_http_info(site_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_cache_rule_with_http_info(self, site_id, rule_id, **kwargs):  # noqa: E501
        """Delete a cache rule  # noqa: E501

        Use this operation for deleting a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cache_rule_with_http_info(site_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: ID of the rule to change. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cache_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `delete_cache_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_cache_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/caching-rules/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_custom_rule(self, rule_id, **kwargs):  # noqa: E501
        """Delete rule  # noqa: E501

        Use this operation to delete a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_rule(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule id (required)
        :return: DeleteCustomRuleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_custom_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_custom_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def delete_custom_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Delete rule  # noqa: E501

        Use this operation to delete a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_rule_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule id (required)
        :return: DeleteCustomRuleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_custom_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_custom_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteCustomRuleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_data_center(self, dc_id, **kwargs):  # noqa: E501
        """Delete data center  # noqa: E501

        Use this operation to delete a site's data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_data_center(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_data_center_with_http_info(dc_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_data_center_with_http_info(dc_id, **kwargs)  # noqa: E501
            return data

    def delete_data_center_with_http_info(self, dc_id, **kwargs):  # noqa: E501
        """Delete data center  # noqa: E501

        Use this operation to delete a site's data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_data_center_with_http_info(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dc_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_data_center" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dc_id' is set
        if ('dc_id' not in params or
                params['dc_id'] is None):
            raise ValueError("Missing the required parameter `dc_id` when calling `delete_data_center`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dc_server(self, server_id, **kwargs):  # noqa: E501
        """Delete server  # noqa: E501

        Use this operation to delete a data center's server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dc_server(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: Server ID. (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dc_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dc_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def delete_dc_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Delete server  # noqa: E501

        Use this operation to delete a data center's server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dc_server_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: Server ID. (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dc_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dc_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'server_id' in params:
            query_params.append(('server_id', params['server_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/servers/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_site(self, **kwargs):  # noqa: E501
        """Delete site  # noqa: E501

        Delete the site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_site(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on
        :param bool ignore_grace_period: The process ignores the site’s 24 hour grace period and immediately deletes the site. Default value: false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_site_with_http_info(self, **kwargs):  # noqa: E501
        """Delete site  # noqa: E501

        Delete the site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_site_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on
        :param bool ignore_grace_period: The process ignores the site’s 24 hour grace period and immediately deletes the site. Default value: false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'ignore_grace_period']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'ignore_grace_period' in params:
            query_params.append(('ignore_grace_period', params['ignore_grace_period']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def domain_emails(self, domain, **kwargs):  # noqa: E501
        """Get domain approver e-mail addresses  # noqa: E501

        Use this operation to get the list of email addresses that can be used when adding an SSL site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.domain_emails(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain: The domain name of the site. For example: <a href=\"www.example.com\">www.example.com</a>, <a href=\"hello.example.com\">www.example.com</a>, <a href=\"example.com\">www.example.com</a> (required)
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.domain_emails_with_http_info(domain, **kwargs)  # noqa: E501
        else:
            (data) = self.domain_emails_with_http_info(domain, **kwargs)  # noqa: E501
            return data

    def domain_emails_with_http_info(self, domain, **kwargs):  # noqa: E501
        """Get domain approver e-mail addresses  # noqa: E501

        Use this operation to get the list of email addresses that can be used when adding an SSL site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.domain_emails_with_http_info(domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain: The domain name of the site. For example: <a href=\"www.example.com\">www.example.com</a>, <a href=\"hello.example.com\">www.example.com</a>, <a href=\"example.com\">www.example.com</a> (required)
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method domain_emails" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain' is set
        if ('domain' not in params or
                params['domain'] is None):
            raise ValueError("Missing the required parameter `domain` when calling `domain_emails`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'domain' in params:
            query_params.append(('domain', params['domain']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/domain/emails', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_bots_configuration(self, body, ext_site_id, **kwargs):  # noqa: E501
        """Update website bot configuration  # noqa: E501

        Update the Bot Access Control configuration for a given website. <br>For the full list of client applications and their associated IDs, see <a href=\"https://docs.imperva.com/bundle/cloud-application-security/page/settings/client-classification.htm\">Client Classification</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_bots_configuration(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BotsConfigurationDTO body: JSON body.  <br> Note: displayName is relevant for response only. (required)
        :param int ext_site_id: (required)
        :return: BotsConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_bots_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_bots_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
            return data

    def edit_bots_configuration_with_http_info(self, body, ext_site_id, **kwargs):  # noqa: E501
        """Update website bot configuration  # noqa: E501

        Update the Bot Access Control configuration for a given website. <br>For the full list of client applications and their associated IDs, see <a href=\"https://docs.imperva.com/bundle/cloud-application-security/page/settings/client-classification.htm\">Client Classification</a>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_bots_configuration_with_http_info(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BotsConfigurationDTO body: JSON body.  <br> Note: displayName is relevant for response only. (required)
        :param int ext_site_id: (required)
        :return: BotsConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_bots_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `edit_bots_configuration`")  # noqa: E501
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `edit_bots_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/settings/botConfiguration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BotsConfigurationDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_cache_rule(self, action, site_id, rule_id, name, **kwargs):  # noqa: E501
        """Edit a cache rule  # noqa: E501

        Use this operation for editing a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cache_rule(action, site_id, rule_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See Possible action parameter values.<br/>Possible action parameter values:<br/><ul><li><b>HTTP_CACHE_MAKE_STATIC</b> Cache Resource</li><li><b>HTTP_CACHE_CLIENT_CACHE_CTL</b> Cache Resource on Client</li><li><b>HTTP_CACHE_FORCE_UNCACHEABLE</b> Don't Cache Resource</li><li><b>HTTP_CACHE_DIFFERENTIATE_SSL</b> Differentiate Cache Key by HTTP/HTTPS Scheme</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_HEADER</b> Differentiate Cache Key by Header</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_COOKIE</b> Differentiate Cache Key by Cookie</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_GEO</b> Differentiate Cache Key by Geolocation</li><li><b>HTTP_CACHE_IGNORE_PARAMS</b> Ignore Parameters in Cache Key</li><li><b>HTTP_CACHE_IGNORE_AUTH_HEADER</b> Cache Authenticated Resources</li><li><b>HTTP_CACHE_FORCE_VALIDATION</b> Force User Authentication</li><li><b>HTTP_CACHE_ADD_TAG</b> Create Tag</li><li><b>HTTP_CACHE_ENRICH_CACHE_KEY</b> Enrich Cache Key</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: ID of the rule to change. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filters, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param str ttl: Rule TTL. Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str ttl_unit: Rule TTL time unit.<br/>Must be one of SECONDS, MINUTES, HOURS, DAYS or WEEKS. If no time unit is provided, SECONDS is used.<br/>Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str differentiated_by_value: Value to differentiate by. HTTP_CACHE_DIFFERENTIATE_BY_HEADER - header name, HTTP_CACHE_DIFFERENTIATE_BY_COOKIE - cookie name, HTTP_CACHE_DIFFERENTIATE_BY_GEO - geo location<br/> (ISO 3166-1 alpha-2 country codes ), otherwise irrelevant.
        :param str params: Comma separated list of parameters to ignore. Parameters name must be alphanumeric.
        :param bool _all_params: When set to <b>true</b>: all parameters in cache key will be ignored.<br/>Default: false.<br/>Relevant for HTTP_CACHE_IGNORE_PARAMS action
        :param str tag_name: The name of the tag to add.
        :param str text: Add text to the cache key as suffix. Relevant for the HTTP_CACHE_ENRICH_CACHE_KEY action
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_cache_rule_with_http_info(action, site_id, rule_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_cache_rule_with_http_info(action, site_id, rule_id, name, **kwargs)  # noqa: E501
            return data

    def edit_cache_rule_with_http_info(self, action, site_id, rule_id, name, **kwargs):  # noqa: E501
        """Edit a cache rule  # noqa: E501

        Use this operation for editing a cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cache_rule_with_http_info(action, site_id, rule_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: Rule action. See Possible action parameter values.<br/>Possible action parameter values:<br/><ul><li><b>HTTP_CACHE_MAKE_STATIC</b> Cache Resource</li><li><b>HTTP_CACHE_CLIENT_CACHE_CTL</b> Cache Resource on Client</li><li><b>HTTP_CACHE_FORCE_UNCACHEABLE</b> Don't Cache Resource</li><li><b>HTTP_CACHE_DIFFERENTIATE_SSL</b> Differentiate Cache Key by HTTP/HTTPS Scheme</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_HEADER</b> Differentiate Cache Key by Header</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_COOKIE</b> Differentiate Cache Key by Cookie</li><li><b>HTTP_CACHE_DIFFERENTIATE_BY_GEO</b> Differentiate Cache Key by Geolocation</li><li><b>HTTP_CACHE_IGNORE_PARAMS</b> Ignore Parameters in Cache Key</li><li><b>HTTP_CACHE_IGNORE_AUTH_HEADER</b> Cache Authenticated Resources</li><li><b>HTTP_CACHE_FORCE_VALIDATION</b> Force User Authentication</li><li><b>HTTP_CACHE_ADD_TAG</b> Create Tag</li><li><b>HTTP_CACHE_ENRICH_CACHE_KEY</b> Enrich Cache Key</li></ul> (required)
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: ID of the rule to change. (required)
        :param str name: Rule name. (required)
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filters, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param str ttl: Rule TTL. Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str ttl_unit: Rule TTL time unit.<br/>Must be one of SECONDS, MINUTES, HOURS, DAYS or WEEKS. If no time unit is provided, SECONDS is used.<br/>Only relevant when action is HTTP_CACHE_MAKE_STATIC or HTTP_CACHE_CLIENT_CACHE_CTL
        :param str differentiated_by_value: Value to differentiate by. HTTP_CACHE_DIFFERENTIATE_BY_HEADER - header name, HTTP_CACHE_DIFFERENTIATE_BY_COOKIE - cookie name, HTTP_CACHE_DIFFERENTIATE_BY_GEO - geo location<br/> (ISO 3166-1 alpha-2 country codes ), otherwise irrelevant.
        :param str params: Comma separated list of parameters to ignore. Parameters name must be alphanumeric.
        :param bool _all_params: When set to <b>true</b>: all parameters in cache key will be ignored.<br/>Default: false.<br/>Relevant for HTTP_CACHE_IGNORE_PARAMS action
        :param str tag_name: The name of the tag to add.
        :param str text: Add text to the cache key as suffix. Relevant for the HTTP_CACHE_ENRICH_CACHE_KEY action
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'site_id', 'rule_id', 'name', 'filter', 'ttl', 'ttl_unit', 'differentiated_by_value', 'params', '_all_params', 'tag_name', 'text']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_cache_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `edit_cache_rule`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `edit_cache_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `edit_cache_rule`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_cache_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501
        if 'ttl_unit' in params:
            query_params.append(('ttl_unit', params['ttl_unit']))  # noqa: E501
        if 'differentiated_by_value' in params:
            query_params.append(('differentiated_by_value', params['differentiated_by_value']))  # noqa: E501
        if 'params' in params:
            query_params.append(('params', params['params']))  # noqa: E501
        if '_all_params' in params:
            query_params.append(('all_params', params['_all_params']))  # noqa: E501
        if 'tag_name' in params:
            query_params.append(('tag_name', params['tag_name']))  # noqa: E501
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/caching-rules/edit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_custom_rule(self, rule_id, **kwargs):  # noqa: E501
        """Edit rule  # noqa: E501

        Use this operation to edit an existing rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_rule(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule ID. (required)
        :param str action: Rule action.<br/><br/>Possible action parameter values for Delivery Rules:<br/><ul><li><b>RULE_ACTION_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_SIMPLIFIED_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_REWRITE_URL</b> Modify the path to which a specific request is targeted.</li><li><b>RULE_ACTION_REWRITE_HEADER</b> Modify or add a request header before passing traffic to the origin server.</li><li><b>RULE_ACTION_REWRITE_COOKIE</b> Modify or add cookies that are sent by the client to the origin server. The cookie name and value should be indicated.</li><li><b>RULE_ACTION_DELETE_HEADER</b> Remove a specific request header, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_DELETE_COOKIE</b> Remove a specific cookie set on the client, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_FORWARD_TO_DC</b> Define the data center to which a specific request will be sent.</li><li><b>RULE_ACTION_FORWARD_TO_PORT</b> Define the port to which a specific request will be sent.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_HEADER</b> Modify or add a header to the response received from the origin server.</li><li><b>RULE_ACTION_RESPONSE_DELETE_HEADER</b> Remove a specific response header, which means that it won't be returned to the client.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_RESPONSE_CODE</b> Modify the response code received from the origin server.</li></ul><br/>Possible action parameter values for security rules:<br/><ul><li><b>RULE_ACTION_ALERT</b> Generate a non blocking alert for this event.</li><li><b>RULE_ACTION_BLOCK</b> Block the current request and generate an alert for this event.</li><li><b>RULE_ACTION_BLOCK_USER</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_BLOCK_IP</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_RETRY</b> Require any client matching the rule filters to support cookies in order to complete the request.</li><li><b>RULE_ACTION_INTRUSIVE_HTML</b> Require any client matching the rule filters to support javascript in order to complete the request. Since the Javascript test is embedded in an HTML page, this action should only be enabled for HTML resources.</li><li><b>RULE_ACTION_CAPTCHA</b> Require any client matching the rule filters to pass a CAPTCHA test in order to complete the request. Since the CAPTCHA test is embedded in an HTML page, this action should only be enabled for HTML resources.</li></ul><br/>Possible action parameter values for counter (rate) rules:<br/><ul><li><b>RULE_ACTION_RATE</b> Count the number of requests received that match the rule filter.</li></ul>
        :param str name: Rule name.
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filter guidelines, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param int response_code: Redirect rule's response code. Valid values are 302, 301, 303, 307, 308.
        :param str protocol:
        :param bool add_missing: Add cookie or header if it doesn't exist (Rewrite cookie rule only)
        :param str _from: The pattern to rewrite.<br/>For RULE_ACTION_REWRITE_URL - The URL to rewrite.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to rewrite.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to rewrite.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str to: The pattern to change to.<br/>For RULE_ACTION_REWRITE_URL - The URL to change to.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to change to.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to change to.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str rewrite_name: Name of cookie or header to rewrite. Applies only for RULE_ACTION_REWRITE_COOKIE and RULE_ACTION_REWRITE_HEADER.
        :param int dc_id: Data center to forward request to. Applies only for RULE_ACTION_FORWARD_TO_DC.
        :param bool allow_caching:
        :param str rate_context: The context of the rate counter. Possible values: IP / Session. Applies only to rules using RULE_ACTION_RATE.
        :param int rate_interval: The interval (in seconds) of the rate counter. Possible values: A multiple of 10 from 10-300. Applies only to rules using RULE_ACTION_RATE.
        :param bool is_test_mode: Make rule apply only for IP address the API request was sent from.<br/>This option is not available for Simplified Redirect rules.
        :param str port_forwarding_context: Context for port forwarding. \"Use Port Value\" or \"Use Header Name\". Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param str port_forwarding_value: Port number or header name for port forwarding. Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param bool multiple_deletions: Delete multiple header occurrences. Applies only to rules using RULE_ACTION_DELETE_HEADER and RULE_ACTION_RESPONSE_DELETE_HEADER.
        :param bool rewrite_existing: Rewrite cookie or header if it exists
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_custom_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_custom_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def edit_custom_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Edit rule  # noqa: E501

        Use this operation to edit an existing rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_custom_rule_with_http_info(rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule ID. (required)
        :param str action: Rule action.<br/><br/>Possible action parameter values for Delivery Rules:<br/><ul><li><b>RULE_ACTION_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_SIMPLIFIED_REDIRECT</b> Redirect the client to a different URL, responding with a 30X response.</li><li><b>RULE_ACTION_REWRITE_URL</b> Modify the path to which a specific request is targeted.</li><li><b>RULE_ACTION_REWRITE_HEADER</b> Modify or add a request header before passing traffic to the origin server.</li><li><b>RULE_ACTION_REWRITE_COOKIE</b> Modify or add cookies that are sent by the client to the origin server. The cookie name and value should be indicated.</li><li><b>RULE_ACTION_DELETE_HEADER</b> Remove a specific request header, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_DELETE_COOKIE</b> Remove a specific cookie set on the client, which means that it won’t be sent to the origin server.</li><li><b>RULE_ACTION_FORWARD_TO_DC</b> Define the data center to which a specific request will be sent.</li><li><b>RULE_ACTION_FORWARD_TO_PORT</b> Define the port to which a specific request will be sent.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_HEADER</b> Modify or add a header to the response received from the origin server.</li><li><b>RULE_ACTION_RESPONSE_DELETE_HEADER</b> Remove a specific response header, which means that it won't be returned to the client.</li><li><b>RULE_ACTION_RESPONSE_REWRITE_RESPONSE_CODE</b> Modify the response code received from the origin server.</li></ul><br/>Possible action parameter values for security rules:<br/><ul><li><b>RULE_ACTION_ALERT</b> Generate a non blocking alert for this event.</li><li><b>RULE_ACTION_BLOCK</b> Block the current request and generate an alert for this event.</li><li><b>RULE_ACTION_BLOCK_USER</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_BLOCK_IP</b> Block the current session and generate an alert for this event. Any subsequent request from the same Session will be blocked.</li><li><b>RULE_ACTION_RETRY</b> Require any client matching the rule filters to support cookies in order to complete the request.</li><li><b>RULE_ACTION_INTRUSIVE_HTML</b> Require any client matching the rule filters to support javascript in order to complete the request. Since the Javascript test is embedded in an HTML page, this action should only be enabled for HTML resources.</li><li><b>RULE_ACTION_CAPTCHA</b> Require any client matching the rule filters to pass a CAPTCHA test in order to complete the request. Since the CAPTCHA test is embedded in an HTML page, this action should only be enabled for HTML resources.</li></ul><br/>Possible action parameter values for counter (rate) rules:<br/><ul><li><b>RULE_ACTION_RATE</b> Count the number of requests received that match the rule filter.</li></ul>
        :param str name: Rule name.
        :param str filter: Rule will trigger only a request that matches this filter. For more details on filter guidelines, see <a href=\"https://docs.imperva.com/csh?context=rule_syntax\">Syntax Guide</a>.
        :param int response_code: Redirect rule's response code. Valid values are 302, 301, 303, 307, 308.
        :param str protocol:
        :param bool add_missing: Add cookie or header if it doesn't exist (Rewrite cookie rule only)
        :param str _from: The pattern to rewrite.<br/>For RULE_ACTION_REWRITE_URL - The URL to rewrite.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to rewrite.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to rewrite.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str to: The pattern to change to.<br/>For RULE_ACTION_REWRITE_URL - The URL to change to.<br/>For RULE_ACTION_REWRITE_HEADER - The header value to change to.<br/>For RULE_ACTION_REWRITE_COOKIE - The cookie value to change to.<br/>For RULE_ACTION_SIMPLIFIED_REDIRECT - Redirect the client to a different URL, responding with a 30X response.
        :param str rewrite_name: Name of cookie or header to rewrite. Applies only for RULE_ACTION_REWRITE_COOKIE and RULE_ACTION_REWRITE_HEADER.
        :param int dc_id: Data center to forward request to. Applies only for RULE_ACTION_FORWARD_TO_DC.
        :param bool allow_caching:
        :param str rate_context: The context of the rate counter. Possible values: IP / Session. Applies only to rules using RULE_ACTION_RATE.
        :param int rate_interval: The interval (in seconds) of the rate counter. Possible values: A multiple of 10 from 10-300. Applies only to rules using RULE_ACTION_RATE.
        :param bool is_test_mode: Make rule apply only for IP address the API request was sent from.<br/>This option is not available for Simplified Redirect rules.
        :param str port_forwarding_context: Context for port forwarding. \"Use Port Value\" or \"Use Header Name\". Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param str port_forwarding_value: Port number or header name for port forwarding. Applies only for RULE_ACTION_FORWARD_TO_PORT.
        :param bool multiple_deletions: Delete multiple header occurrences. Applies only to rules using RULE_ACTION_DELETE_HEADER and RULE_ACTION_RESPONSE_DELETE_HEADER.
        :param bool rewrite_existing: Rewrite cookie or header if it exists
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'action', 'name', 'filter', 'response_code', 'protocol', 'add_missing', '_from', 'to', 'rewrite_name', 'dc_id', 'allow_caching', 'rate_context', 'rate_interval', 'is_test_mode', 'port_forwarding_context', 'port_forwarding_value', 'multiple_deletions', 'rewrite_existing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_custom_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `edit_custom_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'response_code' in params:
            query_params.append(('response_code', params['response_code']))  # noqa: E501
        if 'protocol' in params:
            query_params.append(('protocol', params['protocol']))  # noqa: E501
        if 'add_missing' in params:
            query_params.append(('add_missing', params['add_missing']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'rewrite_name' in params:
            query_params.append(('rewrite_name', params['rewrite_name']))  # noqa: E501
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501
        if 'allow_caching' in params:
            query_params.append(('allow_caching', params['allow_caching']))  # noqa: E501
        if 'rate_context' in params:
            query_params.append(('rate_context', params['rate_context']))  # noqa: E501
        if 'rate_interval' in params:
            query_params.append(('rate_interval', params['rate_interval']))  # noqa: E501
        if 'is_test_mode' in params:
            query_params.append(('is_test_mode', params['is_test_mode']))  # noqa: E501
        if 'port_forwarding_context' in params:
            query_params.append(('port_forwarding_context', params['port_forwarding_context']))  # noqa: E501
        if 'port_forwarding_value' in params:
            query_params.append(('port_forwarding_value', params['port_forwarding_value']))  # noqa: E501
        if 'multiple_deletions' in params:
            query_params.append(('multiple_deletions', params['multiple_deletions']))  # noqa: E501
        if 'rewrite_existing' in params:
            query_params.append(('rewrite_existing', params['rewrite_existing']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/edit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_data_center(self, dc_id, **kwargs):  # noqa: E501
        """Edit data center  # noqa: E501

        Use this operation to edit site's data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_data_center(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :param str name: The new data center's name.
        :param bool is_enabled: Enables the data center.
        :param bool is_standby: Defines the data center as <b>standby</b> for failover.
        :param bool is_content: The data center will be available for specific resources (<b>Forward</b> Delivery Rules).
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_data_center_with_http_info(dc_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_data_center_with_http_info(dc_id, **kwargs)  # noqa: E501
            return data

    def edit_data_center_with_http_info(self, dc_id, **kwargs):  # noqa: E501
        """Edit data center  # noqa: E501

        Use this operation to edit site's data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_data_center_with_http_info(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: The data center's ID. (required)
        :param str name: The new data center's name.
        :param bool is_enabled: Enables the data center.
        :param bool is_standby: Defines the data center as <b>standby</b> for failover.
        :param bool is_content: The data center will be available for specific resources (<b>Forward</b> Delivery Rules).
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dc_id', 'name', 'is_enabled', 'is_standby', 'is_content']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_data_center" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dc_id' is set
        if ('dc_id' not in params or
                params['dc_id'] is None):
            raise ValueError("Missing the required parameter `dc_id` when calling `edit_data_center`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'is_enabled' in params:
            query_params.append(('is_enabled', params['is_enabled']))  # noqa: E501
        if 'is_standby' in params:
            query_params.append(('is_standby', params['is_standby']))  # noqa: E501
        if 'is_content' in params:
            query_params.append(('is_content', params['is_content']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/edit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_dc_server(self, server_id, **kwargs):  # noqa: E501
        """Edit server  # noqa: E501

        Use this operation to edit a server in a data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_dc_server(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: Server ID. (required)
        :param str server_address: The IP address of the server to modify.
        :param bool is_enabled: Enable or disable the server (Boolean).
        :param bool is_standby: Set the server as Active (P0) or Standby (P1) (Boolean).
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_dc_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_dc_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def edit_dc_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Edit server  # noqa: E501

        Use this operation to edit a server in a data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_dc_server_with_http_info(server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int server_id: Server ID. (required)
        :param str server_address: The IP address of the server to modify.
        :param bool is_enabled: Enable or disable the server (Boolean).
        :param bool is_standby: Set the server as Active (P0) or Standby (P1) (Boolean).
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'server_address', 'is_enabled', 'is_standby']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_dc_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `edit_dc_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'server_id' in params:
            query_params.append(('server_id', params['server_id']))  # noqa: E501
        if 'server_address' in params:
            query_params.append(('server_address', params['server_address']))  # noqa: E501
        if 'is_enabled' in params:
            query_params.append(('is_enabled', params['is_enabled']))  # noqa: E501
        if 'is_standby' in params:
            query_params.append(('is_standby', params['is_standby']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/servers/edit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_cache_shield(self, site_id, enable, **kwargs):  # noqa: E501
        """Enable cache shield  # noqa: E501

        Enable Cache Shield for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_cache_shield(site_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param bool enable: Use <b>true</b> to enable cache shield on the specified site, and <b>false</b> to disable it. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_cache_shield_with_http_info(site_id, enable, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_cache_shield_with_http_info(site_id, enable, **kwargs)  # noqa: E501
            return data

    def enable_cache_shield_with_http_info(self, site_id, enable, **kwargs):  # noqa: E501
        """Enable cache shield  # noqa: E501

        Enable Cache Shield for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_cache_shield_with_http_info(site_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param bool enable: Use <b>true</b> to enable cache shield on the specified site, and <b>false</b> to disable it. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'enable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_cache_shield" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `enable_cache_shield`")  # noqa: E501
        # verify the required parameter 'enable' is set
        if ('enable' not in params or
                params['enable'] is None):
            raise ValueError("Missing the required parameter `enable` when calling `enable_cache_shield`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'enable' in params:
            query_params.append(('enable', params['enable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache-shield/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_disable_cache_rule(self, site_id, rule_id, enable, **kwargs):  # noqa: E501
        """Enable or disable cache rule  # noqa: E501

        Use this operation for enabling or disable cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_disable_cache_rule(site_id, rule_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: Numeric identifier of the site to operate on. (required)
        :param str enable: When true, the rule will be enabled. Set to false to disable. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_disable_cache_rule_with_http_info(site_id, rule_id, enable, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_disable_cache_rule_with_http_info(site_id, rule_id, enable, **kwargs)  # noqa: E501
            return data

    def enable_disable_cache_rule_with_http_info(self, site_id, rule_id, enable, **kwargs):  # noqa: E501
        """Enable or disable cache rule  # noqa: E501

        Use this operation for enabling or disable cache rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_disable_cache_rule_with_http_info(site_id, rule_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param int rule_id: Numeric identifier of the site to operate on. (required)
        :param str enable: When true, the rule will be enabled. Set to false to disable. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'rule_id', 'enable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_disable_cache_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `enable_disable_cache_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `enable_disable_cache_rule`")  # noqa: E501
        # verify the required parameter 'enable' is set
        if ('enable' not in params or
                params['enable'] is None):
            raise ValueError("Missing the required parameter `enable` when calling `enable_disable_cache_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'enable' in params:
            query_params.append(('enable', params['enable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/caching-rules/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_disable_custom_rule(self, rule_id, enable, **kwargs):  # noqa: E501
        """Enable or disable rule  # noqa: E501

        Use this operation to enable or disable a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_disable_custom_rule(rule_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule id (required)
        :param bool enable: When true, the rule will be enabled. Set to false to disable (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_disable_custom_rule_with_http_info(rule_id, enable, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_disable_custom_rule_with_http_info(rule_id, enable, **kwargs)  # noqa: E501
            return data

    def enable_disable_custom_rule_with_http_info(self, rule_id, enable, **kwargs):  # noqa: E501
        """Enable or disable rule  # noqa: E501

        Use this operation to enable or disable a rule (Delivery, Security or Rate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_disable_custom_rule_with_http_info(rule_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule id (required)
        :param bool enable: When true, the rule will be enabled. Set to false to disable (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'enable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_disable_custom_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `enable_disable_custom_rule`")  # noqa: E501
        # verify the required parameter 'enable' is set
        if ('enable' not in params or
                params['enable'] is None):
            raise ValueError("Missing the required parameter `enable` when calling `enable_disable_custom_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'enable' in params:
            query_params.append(('enable', params['enable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/enableDisable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_advanced_caching_settings(self, site_id, param, **kwargs):  # noqa: E501
        """Get advanced caching settings  # noqa: E501

        Use this operation to get advanced caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advanced_caching_settings(site_id, param, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>async_validation</b> Sets Async validation. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_javascript</b> Sets the Minify JS. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_css</b> Sets the Minify CSS. Pass \"true\" or \"false\" in the value parameter</li><li><b>minify_static_html</b> Sets Minify static HTML. Pass \"true\" or \"false\" in the value parameter</li><li><b>compress_jpeg</b> Sets the Compress JPEG. Pass \"true\" or \"false\" in the value parameter.</li><li><b>progressive_image_rendering</b> Sets the Progressive Image rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>aggressive_compression</b> Sets the Aggressive compression rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>compress_png</b> Sets the Compress PNG flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>on_the_fly_compression</b> \"On the fly\" Compression. Pass \"true\" or \"false\" in the value parameter.</li><li><b>tcp_pre_pooling</b> TCP Pre-Pooling. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_no_cache</b> Comply with no-cache and max-age directives in client requests. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_vary</b> Comply with the <b>Vary</b> header. Pass \"true\" or \"false\" in the value parameter.</li><li><b>use_shortest_caching</b> Use shortest caching duration in case of conflicts. Pass \"true\" or \"false\" in the value parameter.</li><li><b>prefer_last_modified</b> Prefer 'last modified' over eTag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>disable_client_side_caching</b> Disable client side caching. Pass \"true\" or \"false\" in the value parameter.</li><li><b>cache_300x</b> Cache 300X responses. Pass \"true\" or \"false\" in the value parameter.</li><li><b>unite_naked_full_cache</b> Use the same cache for full and naked domains. For example, use the same cached resource for <a href=\"https://www.example.com/a\"></a> and <a href=\"https://example.com/\"></a>a.</li><li><b>cache_empty_responses</b> Cache responses that don’t have a message body.</li><li><b>cache_http_10_responses</b> Cache HTTP 1.0 type responses that don’t include the Content-Length header or chunking. Pass \"true\" or \"false\" in the value parameter.</li><li><b>send_age_header</b> Send <b>Cache-Control: max-age</b> and <b>Age</b> headers. Pass \"true\" or \"false\" in the value parameter.</li><li><b>support_non_sni_clients</b> By default, non-SNI clients are supported. Disable this option to block non-SNI clients. Pass \"true\" or \"false\" in the value parameter.</li><li><b>origin_connection_reuse</b> By default, TCP connections that are opened for a client request remain open for a short time to handle additional requests that may arrive. This option disables that behavior.. Pass \"true\" or \"false\" in the value parameter.</li><li><b>redirect_http_to_https</b> Redirect HTTP requests to HTTPS requests by sending an HTTP 301 response.</li><li><b>redirect_naked_domain_to_full</b> Redirect requests from your website's naked domain to its full domain by sending and HTTP 301 response.</li><li><b>http_2</b> Enables supporting browsers to take advantage of the performance enhancements provided by HTTP/2 for your website. Non-supporting browsers can connect via HTTP/1.0 or HTTP/1.1. HTTP/2 support requires that SSL is configured for your website. Pass \"true\" or \"false\" in the value parameter</li></ul> (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_advanced_caching_settings_with_http_info(site_id, param, **kwargs)  # noqa: E501
        else:
            (data) = self.get_advanced_caching_settings_with_http_info(site_id, param, **kwargs)  # noqa: E501
            return data

    def get_advanced_caching_settings_with_http_info(self, site_id, param, **kwargs):  # noqa: E501
        """Get advanced caching settings  # noqa: E501

        Use this operation to get advanced caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advanced_caching_settings_with_http_info(site_id, param, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>async_validation</b> Sets Async validation. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_javascript</b> Sets the Minify JS. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_css</b> Sets the Minify CSS. Pass \"true\" or \"false\" in the value parameter</li><li><b>minify_static_html</b> Sets Minify static HTML. Pass \"true\" or \"false\" in the value parameter</li><li><b>compress_jpeg</b> Sets the Compress JPEG. Pass \"true\" or \"false\" in the value parameter.</li><li><b>progressive_image_rendering</b> Sets the Progressive Image rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>aggressive_compression</b> Sets the Aggressive compression rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>compress_png</b> Sets the Compress PNG flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>on_the_fly_compression</b> \"On the fly\" Compression. Pass \"true\" or \"false\" in the value parameter.</li><li><b>tcp_pre_pooling</b> TCP Pre-Pooling. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_no_cache</b> Comply with no-cache and max-age directives in client requests. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_vary</b> Comply with the <b>Vary</b> header. Pass \"true\" or \"false\" in the value parameter.</li><li><b>use_shortest_caching</b> Use shortest caching duration in case of conflicts. Pass \"true\" or \"false\" in the value parameter.</li><li><b>prefer_last_modified</b> Prefer 'last modified' over eTag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>disable_client_side_caching</b> Disable client side caching. Pass \"true\" or \"false\" in the value parameter.</li><li><b>cache_300x</b> Cache 300X responses. Pass \"true\" or \"false\" in the value parameter.</li><li><b>unite_naked_full_cache</b> Use the same cache for full and naked domains. For example, use the same cached resource for <a href=\"https://www.example.com/a\"></a> and <a href=\"https://example.com/\"></a>a.</li><li><b>cache_empty_responses</b> Cache responses that don’t have a message body.</li><li><b>cache_http_10_responses</b> Cache HTTP 1.0 type responses that don’t include the Content-Length header or chunking. Pass \"true\" or \"false\" in the value parameter.</li><li><b>send_age_header</b> Send <b>Cache-Control: max-age</b> and <b>Age</b> headers. Pass \"true\" or \"false\" in the value parameter.</li><li><b>support_non_sni_clients</b> By default, non-SNI clients are supported. Disable this option to block non-SNI clients. Pass \"true\" or \"false\" in the value parameter.</li><li><b>origin_connection_reuse</b> By default, TCP connections that are opened for a client request remain open for a short time to handle additional requests that may arrive. This option disables that behavior.. Pass \"true\" or \"false\" in the value parameter.</li><li><b>redirect_http_to_https</b> Redirect HTTP requests to HTTPS requests by sending an HTTP 301 response.</li><li><b>redirect_naked_domain_to_full</b> Redirect requests from your website's naked domain to its full domain by sending and HTTP 301 response.</li><li><b>http_2</b> Enables supporting browsers to take advantage of the performance enhancements provided by HTTP/2 for your website. Non-supporting browsers can connect via HTTP/1.0 or HTTP/1.1. HTTP/2 support requires that SSL is configured for your website. Pass \"true\" or \"false\" in the value parameter</li></ul> (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'param']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_advanced_caching_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_advanced_caching_settings`")  # noqa: E501
        # verify the required parameter 'param' is set
        if ('param' not in params or
                params['param'] is None):
            raise ValueError("Missing the required parameter `param` when calling `get_advanced_caching_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'param' in params:
            query_params.append(('param', params['param']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/advanced/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bots_configuration(self, ext_site_id, **kwargs):  # noqa: E501
        """Get website bot configuration  # noqa: E501

        Retrieve the Bot Access Control configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bots_configuration(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: (required)
        :return: BotsConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bots_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bots_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
            return data

    def get_bots_configuration_with_http_info(self, ext_site_id, **kwargs):  # noqa: E501
        """Get website bot configuration  # noqa: E501

        Retrieve the Bot Access Control configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bots_configuration_with_http_info(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: (required)
        :return: BotsConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bots_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `get_bots_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/settings/botConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BotsConfigurationDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cache404_settings(self, site_id, **kwargs):  # noqa: E501
        """Get cache 404 settings  # noqa: E501

        Use this operation to get the caching settings of 404 responses for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cache404_settings(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cache404_settings_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cache404_settings_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_cache404_settings_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get cache 404 settings  # noqa: E501

        Use this operation to get the caching settings of 404 responses for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cache404_settings_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cache404_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_cache404_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache404', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_caching_mode(self, site_id, **kwargs):  # noqa: E501
        """Get caching mode  # noqa: E501

        Use this operation to get a site's caching mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_caching_mode(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_caching_mode_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_caching_mode_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_caching_mode_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get caching mode  # noqa: E501

        Use this operation to get a site's caching mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_caching_mode_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_caching_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_caching_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache-mode/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_region(self, site_id, **kwargs):  # noqa: E501
        """Get site data storage region  # noqa: E501

        Use this operation to get the site data region.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_region(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_region_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_region_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_data_region_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get site data storage region  # noqa: E501

        Use this operation to get the site data region.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_region_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_data_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/data-privacy/show', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_html_injection_rules(self, site_id, **kwargs):  # noqa: E501
        """Get HTML injection rules  # noqa: E501

        Use this operation to list all the HTML Injection rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_html_injection_rules(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_html_injection_rules_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_html_injection_rules_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_html_injection_rules_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get HTML injection rules  # noqa: E501

        Use this operation to list all the HTML Injection rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_html_injection_rules_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_html_injection_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_html_injection_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/htmlinjections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_override_site_regions_by_geo(self, **kwargs):  # noqa: E501
        """Check site regions by origin geolocation  # noqa: E501

        Use this operation to check if the data storage region for each new site is based on the geolocation of the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_override_site_regions_by_geo(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_override_site_regions_by_geo_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_override_site_regions_by_geo_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_override_site_regions_by_geo_with_http_info(self, **kwargs):  # noqa: E501
        """Check site regions by origin geolocation  # noqa: E501

        Use this operation to check if the data storage region for each new site is based on the geolocation of the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_override_site_regions_by_geo_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_override_site_regions_by_geo" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/data-privacy/show-override-by-geo', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recommended_data_center_origin_po_ps(self, dc_id, **kwargs):  # noqa: E501
        """Get data center recommended origin PoPs  # noqa: E501

        Get a list of recommended origin PoPs for a given data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommended_data_center_origin_po_ps(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: Numeric identifier of the data center to operate on. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recommended_data_center_origin_po_ps_with_http_info(dc_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recommended_data_center_origin_po_ps_with_http_info(dc_id, **kwargs)  # noqa: E501
            return data

    def get_recommended_data_center_origin_po_ps_with_http_info(self, dc_id, **kwargs):  # noqa: E501
        """Get data center recommended origin PoPs  # noqa: E501

        Get a list of recommended origin PoPs for a given data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommended_data_center_origin_po_ps_with_http_info(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: Numeric identifier of the data center to operate on. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dc_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recommended_data_center_origin_po_ps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dc_id' is set
        if ('dc_id' not in params or
                params['dc_id'] is None):
            raise ValueError("Missing the required parameter `dc_id` when calling `get_recommended_data_center_origin_po_ps`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/datacenter/origin-pop/recommend', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_response_header_settings(self, site_id, **kwargs):  # noqa: E501
        """Get cached response headers  # noqa: E501

        Use this operation to get a site's cached response headers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_response_header_settings(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_response_header_settings_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_response_header_settings_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_response_header_settings_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get cached response headers  # noqa: E501

        Use this operation to get a site's cached response headers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_response_header_settings_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_response_header_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_response_header_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/response-headers/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rewrite_ports(self, site_id, **kwargs):  # noqa: E501
        """Get rewrite port  # noqa: E501

        Use this operation to get the rewritten port number used to access the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rewrite_ports(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rewrite_ports_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rewrite_ports_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_rewrite_ports_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get rewrite port  # noqa: E501

        Use this operation to get the rewritten port number used to access the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rewrite_ports_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rewrite_ports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_rewrite_ports`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/rewrite-port', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_secure_resources_mode(self, site_id, **kwargs):  # noqa: E501
        """Get secure resources mode  # noqa: E501

        Use this operation to get the Secure Resources mode for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_secure_resources_mode(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_secure_resources_mode_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_secure_resources_mode_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_secure_resources_mode_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get secure resources mode  # noqa: E501

        Use this operation to get the Secure Resources mode for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_secure_resources_mode_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_secure_resources_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_secure_resources_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/secure-resources/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_site_error_page_template(self, site_id, **kwargs):  # noqa: E501
        """Get error page  # noqa: E501

        Use this operation to get the custom error page for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_error_page_template(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_site_error_page_template_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_site_error_page_template_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_site_error_page_template_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get error page  # noqa: E501

        Use this operation to get the custom error page for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_error_page_template_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_site_error_page_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_site_error_page_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/error-page', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_site_report(self, site_id, report, format, time_range, **kwargs):  # noqa: E501
        """Get site report  # noqa: E501

        Use this operation to get a report for a site. Reports are sent using Base64 encoding.The time_range parameter is ignored for accounts with the WAF Rules policy feature. For such accounts, the report returns the current status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_report(site_id, report, format, time_range, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str report: The report to get. One of: pci-compliance (required)
        :param str format: The format to get the report in. One of: pdf | html (required)
        :param str time_range: Time range to fetch data for.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul> (required)
        :param str start: Start date in milliseconds since 1970.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul>
        :param str end: End date in milliseconds since 1970.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul>
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_site_report_with_http_info(site_id, report, format, time_range, **kwargs)  # noqa: E501
        else:
            (data) = self.get_site_report_with_http_info(site_id, report, format, time_range, **kwargs)  # noqa: E501
            return data

    def get_site_report_with_http_info(self, site_id, report, format, time_range, **kwargs):  # noqa: E501
        """Get site report  # noqa: E501

        Use this operation to get a report for a site. Reports are sent using Base64 encoding.The time_range parameter is ignored for accounts with the WAF Rules policy feature. For such accounts, the report returns the current status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_report_with_http_info(site_id, report, format, time_range, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str report: The report to get. One of: pci-compliance (required)
        :param str format: The format to get the report in. One of: pdf | html (required)
        :param str time_range: Time range to fetch data for.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul> (required)
        :param str start: Start date in milliseconds since 1970.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul>
        :param str end: End date in milliseconds since 1970.<br/>Some operations require the user to specify a time range. This is done via the time_range parameter, which accepts the following values:<br/><ul><li><b>today</b> Retrieve data from midnight today until the current time.</li><li><b>last_7_days</b> Retrieve data from midnight of 7 days ago until the current time.</li><li><b>last_30_days</b> Retrieve data from midnight of 30 days ago until the current time.</li><li><b>last_90_days</b> Retrieve data from midnight of 90 days ago until the current time.</li><li><b>month_to_date</b> Retrieve data from midnight of the first day of the month until the current time.</li><li><b>custom</b> Specify a custom time range using two additional parameters: start and end.<br/>Results are provided for full days only, starting from midnight. A time range of less than 24 hours gives results for the full day.<br/>For example:<ul><li>A time range of 14:00 - 20:00 yesterday gives results for all of yesterday (midnight to midnight) - a full day.</li><li>A time range of 14:00 last Tuesday to 14:00 last Wednesday gives results for all of Tuesday and Wednesday - two full days.</li> <li>A time range of 14:00 yesterday to 14:00 today gives results for all of yesterday starting from midnight until the current time today.</li></ul></li></ul>
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'report', 'format', 'time_range', 'start', 'end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_site_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_site_report`")  # noqa: E501
        # verify the required parameter 'report' is set
        if ('report' not in params or
                params['report'] is None):
            raise ValueError("Missing the required parameter `report` when calling `get_site_report`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_site_report`")  # noqa: E501
        # verify the required parameter 'time_range' is set
        if ('time_range' not in params or
                params['time_range'] is None):
            raise ValueError("Missing the required parameter `time_range` when calling `get_site_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'report' in params:
            query_params.append(('report', params['report']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'time_range' in params:
            query_params.append(('time_range', params['time_range']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/report', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_stale_content(self, site_id, **kwargs):  # noqa: E501
        """Get stale content settings  # noqa: E501

        When Imperva can't connect to the origin server, serve stale content instead of displaying an error to end users for the specified amount of time. Expired resources are returned from cache, and refreshed asynchronously in the background.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stale_content(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_stale_content_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_stale_content_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_stale_content_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get stale content settings  # noqa: E501

        When Imperva can't connect to the origin server, serve stale content instead of displaying an error to end users for the specified amount of time. Expired resources are returned from cache, and refreshed asynchronously in the background.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stale_content_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stale_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_stale_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/stale-content/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_response_header(self, site_id, **kwargs):  # noqa: E501
        """Get header to tag responses by  # noqa: E501

        Get the origin response header containing the cache tags in your resources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_response_header(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tag_response_header_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tag_response_header_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_tag_response_header_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get header to tag responses by  # noqa: E501

        Get the origin response header containing the cache tags in your resources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_response_header_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_response_header" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_tag_response_header`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/tag-response/get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tls_configuration(self, ext_site_id, **kwargs):  # noqa: E501
        """Get website TLS configuration  # noqa: E501

        Retrieve the TLS configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tls_configuration(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: The Imperva ID of the website to operate on. (required)
        :return: TLSConfigurationDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tls_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tls_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
            return data

    def get_tls_configuration_with_http_info(self, ext_site_id, **kwargs):  # noqa: E501
        """Get website TLS configuration  # noqa: E501

        Retrieve the TLS configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tls_configuration_with_http_info(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: The Imperva ID of the website to operate on. (required)
        :return: TLSConfigurationDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tls_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `get_tls_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/settings/TLSConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TLSConfigurationDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_xray_link(self, site_id, **kwargs):  # noqa: E501
        """Get XRay access link  # noqa: E501

        Use this operation to get a URL that enables debug headers on the specific site. For more details see <a href=\"https://docs.imperva.com/bundle/cloud-application-security/page/settings/xray-debug-headers.htm\">XRAY Debug Headers Guide</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_xray_link(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_xray_link_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_xray_link_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_xray_link_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get XRay access link  # noqa: E501

        Use this operation to get a URL that enables debug headers on the specific site. For more details see <a href=\"https://docs.imperva.com/bundle/cloud-application-security/page/settings/xray-debug-headers.htm\">XRAY Debug Headers Guide</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_xray_link_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_xray_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_xray_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/xray/get-link', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_cache_shield_enabled(self, site_id, **kwargs):  # noqa: E501
        """Is cache shield enabled  # noqa: E501

        Get the enablement state of the Cache Shield feature for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_cache_shield_enabled(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_cache_shield_enabled_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.is_cache_shield_enabled_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def is_cache_shield_enabled_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Is cache shield enabled  # noqa: E501

        Get the enablement state of the Cache Shield feature for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_cache_shield_enabled_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_cache_shield_enabled" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `is_cache_shield_enabled`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache-shield', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_account_custom_rules(self, account_id, **kwargs):  # noqa: E501
        """List account rules  # noqa: E501

        Use this operation to list rules (Delivery, Security or Rate) for all sites under a given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_account_custom_rules(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Numeric identifier of the account to operate on (required)
        :param bool include_incap_rules: Whether or not security rules be included. Defaults to \"Yes\".
        :param bool include_ad_rules: Whether or not delivery rules should be included. Defaults to \"Yes\".
        :return: ListCustomRulesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_account_custom_rules_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_account_custom_rules_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def list_account_custom_rules_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List account rules  # noqa: E501

        Use this operation to list rules (Delivery, Security or Rate) for all sites under a given account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_account_custom_rules_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: Numeric identifier of the account to operate on (required)
        :param bool include_incap_rules: Whether or not security rules be included. Defaults to \"Yes\".
        :param bool include_ad_rules: Whether or not delivery rules should be included. Defaults to \"Yes\".
        :return: ListCustomRulesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'include_incap_rules', 'include_ad_rules']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_account_custom_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `list_account_custom_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'include_incap_rules' in params:
            query_params.append(('include_incap_rules', params['include_incap_rules']))  # noqa: E501
        if 'include_ad_rules' in params:
            query_params.append(('include_ad_rules', params['include_ad_rules']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/account/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListCustomRulesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cache_rules(self, site_id, **kwargs):  # noqa: E501
        """List cache rules for a given site  # noqa: E501

        Use this operation for representing cache rules for a given site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cache_rules(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str page_size: The number of objects to return in the response.<br/>Default is 50.<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default is 0.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_cache_rules_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_cache_rules_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def list_cache_rules_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """List cache rules for a given site  # noqa: E501

        Use this operation for representing cache rules for a given site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cache_rules_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str page_size: The number of objects to return in the response.<br/>Default is 50.<br/>Maximum: 100
        :param str page_num: The page to return starting from 0. Default is 0.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'page_size', 'page_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cache_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `list_cache_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_num' in params:
            query_params.append(('page_num', params['page_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/caching-rules/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_custom_rules(self, site_id, **kwargs):  # noqa: E501
        """List rules  # noqa: E501

        Use this operation to list security, delivery, and rate rules for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_custom_rules(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str include_incap_rules: Whether or not security rules be included. Defaults to \"Yes\".
        :param str include_ad_rules: Whether or not delivery rules should be included. Defaults to Yes
        :param str page_size: The number of objects to return in the response. Defaults to 50. Maximum is 100
        :param str page_num: The page to return starting from 0. Default to 0
        :return: ListCustomRulesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_custom_rules_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_custom_rules_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def list_custom_rules_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """List rules  # noqa: E501

        Use this operation to list security, delivery, and rate rules for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_custom_rules_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str include_incap_rules: Whether or not security rules be included. Defaults to \"Yes\".
        :param str include_ad_rules: Whether or not delivery rules should be included. Defaults to Yes
        :param str page_size: The number of objects to return in the response. Defaults to 50. Maximum is 100
        :param str page_num: The page to return starting from 0. Default to 0
        :return: ListCustomRulesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'include_incap_rules', 'include_ad_rules', 'page_size', 'page_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_custom_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `list_custom_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'include_incap_rules' in params:
            query_params.append(('include_incap_rules', params['include_incap_rules']))  # noqa: E501
        if 'include_ad_rules' in params:
            query_params.append(('include_ad_rules', params['include_ad_rules']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_num' in params:
            query_params.append(('page_num', params['page_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListCustomRulesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_data_centers(self, site_id, **kwargs):  # noqa: E501
        """List data centers  # noqa: E501

        Use this operation to list a site's data centers including the data centers' servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_centers(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_data_centers_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_data_centers_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def list_data_centers_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """List data centers  # noqa: E501

        Use this operation to list a site's data centers including the data centers' servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_centers_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_data_centers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `list_data_centers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_data_centers_configuration(self, ext_site_id, **kwargs):  # noqa: E501
        """get site's data centers' configuration  # noqa: E501

        Use this operation to get configured data centers and all their servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_centers_configuration(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: (required)
        :return: DataCentersConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_data_centers_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_data_centers_configuration_with_http_info(ext_site_id, **kwargs)  # noqa: E501
            return data

    def list_data_centers_configuration_with_http_info(self, ext_site_id, **kwargs):  # noqa: E501
        """get site's data centers' configuration  # noqa: E501

        Use this operation to get configured data centers and all their servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_centers_configuration_with_http_info(ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ext_site_id: (required)
        :return: DataCentersConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_data_centers_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `list_data_centers_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/data-centers-configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataCentersConfigurationDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sites(self, **kwargs):  # noqa: E501
        """List sites  # noqa: E501

        List sites for an account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sites(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.<br/>If the account has sub accounts, the operation returns results for the sites in the account and in all of its sub accounts.
        :param str page_size: The number of objects to return in the response. Default is 50. Maximum: 100
        :param str page_num: The page to return starting from 0. Default is 0
        :return: ApiResultListSites
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_sites_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_sites_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_sites_with_http_info(self, **kwargs):  # noqa: E501
        """List sites  # noqa: E501

        List sites for an account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sites_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters.<br/>If the account has sub accounts, the operation returns results for the sites in the account and in all of its sub accounts.
        :param str page_size: The number of objects to return in the response. Default is 50. Maximum: 100
        :param str page_num: The page to return starting from 0. Default is 0
        :return: ApiResultListSites
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'page_size', 'page_num']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sites" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'page_num' in params:
            query_params.append(('page_num', params['page_num']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResultListSites',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_advanced_caching_settings(self, site_id, param, value, **kwargs):  # noqa: E501
        """Advanced caching settings  # noqa: E501

        Use this operation to modify advanced caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_advanced_caching_settings(site_id, param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>async_validation</b> Sets Async validation. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_javascript</b> Sets the Minify JS. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_css</b> Sets the Minify CSS. Pass \"true\" or \"false\" in the value parameter</li><li><b>minify_static_html</b> Sets Minify static HTML. Pass \"true\" or \"false\" in the value parameter</li><li><b>compress_jpeg</b> Sets the Compress JPEG. Pass \"true\" or \"false\" in the value parameter.</li><li><b>progressive_image_rendering</b> Sets the Progressive Image rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>aggressive_compression</b> Sets the Aggressive compression rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>compress_png</b> Sets the Compress PNG flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>on_the_fly_compression</b> \"On the fly\" Compression. Pass \"true\" or \"false\" in the value parameter.</li><li><b>tcp_pre_pooling</b> TCP Pre-Pooling. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_no_cache</b> Comply with no-cache and max-age directives in client requests. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_vary</b> Comply with the <b>Vary</b> header. Pass \"true\" or \"false\" in the value parameter.</li><li><b>use_shortest_caching</b> Use shortest caching duration in case of conflicts. Pass \"true\" or \"false\" in the value parameter.</li><li><b>prefer_last_modified</b> Prefer 'last modified' over eTag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>disable_client_side_caching</b> Disable client side caching. Pass \"true\" or \"false\" in the value parameter.</li><li><b>cache_300x</b> Cache 300X responses. Pass \"true\" or \"false\" in the value parameter.</li><li><b>unite_naked_full_cache</b> Use the same cache for full and naked domains. For example, use the same cached resource for <a href=\"https://www.example.com/a\"></a> and <a href=\"https://example.com/\"></a>a.</li><li><b>cache_empty_responses</b> Cache responses that don’t have a message body.</li><li><b>cache_http_10_responses</b> Cache HTTP 1.0 type responses that don’t include the Content-Length header or chunking. Pass \"true\" or \"false\" in the value parameter.</li><li><b>send_age_header</b> Send <b>Cache-Control: max-age</b> and <b>Age</b> headers. Pass \"true\" or \"false\" in the value parameter.</li><li><b>support_non_sni_clients</b> By default, non-SNI clients are supported. Disable this option to block non-SNI clients. Pass \"true\" or \"false\" in the value parameter.</li><li><b>origin_connection_reuse</b> By default, TCP connections that are opened for a client request remain open for a short time to handle additional requests that may arrive. This option disables that behavior.. Pass \"true\" or \"false\" in the value parameter.</li><li><b>redirect_http_to_https</b> Redirect HTTP requests to HTTPS requests by sending an HTTP 301 response.</li><li><b>redirect_naked_domain_to_full</b> Redirect requests from your website's naked domain to its full domain by sending and HTTP 301 response.</li><li><b>http_2</b> Enables supporting browsers to take advantage of the performance enhancements provided by HTTP/2 for your website. Non-supporting browsers can connect via HTTP/1.0 or HTTP/1.1. HTTP/2 support requires that SSL is configured for your website. Pass \"true\" or \"false\" in the value parameter</li></ul> (required)
        :param str value: According to the param value. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_advanced_caching_settings_with_http_info(site_id, param, value, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_advanced_caching_settings_with_http_info(site_id, param, value, **kwargs)  # noqa: E501
            return data

    def modify_advanced_caching_settings_with_http_info(self, site_id, param, value, **kwargs):  # noqa: E501
        """Advanced caching settings  # noqa: E501

        Use this operation to modify advanced caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_advanced_caching_settings_with_http_info(site_id, param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str param: Name of configuration parameter to set.<br/>Possible values for param and value parameters:<br/><ul><li><b>async_validation</b> Sets Async validation. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_javascript</b> Sets the Minify JS. Pass \"true\" or \"false\" in the value parameter.</li><li><b>minify_css</b> Sets the Minify CSS. Pass \"true\" or \"false\" in the value parameter</li><li><b>minify_static_html</b> Sets Minify static HTML. Pass \"true\" or \"false\" in the value parameter</li><li><b>compress_jpeg</b> Sets the Compress JPEG. Pass \"true\" or \"false\" in the value parameter.</li><li><b>progressive_image_rendering</b> Sets the Progressive Image rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>aggressive_compression</b> Sets the Aggressive compression rendering flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>compress_png</b> Sets the Compress PNG flag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>on_the_fly_compression</b> \"On the fly\" Compression. Pass \"true\" or \"false\" in the value parameter.</li><li><b>tcp_pre_pooling</b> TCP Pre-Pooling. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_no_cache</b> Comply with no-cache and max-age directives in client requests. Pass \"true\" or \"false\" in the value parameter.</li><li><b>comply_vary</b> Comply with the <b>Vary</b> header. Pass \"true\" or \"false\" in the value parameter.</li><li><b>use_shortest_caching</b> Use shortest caching duration in case of conflicts. Pass \"true\" or \"false\" in the value parameter.</li><li><b>prefer_last_modified</b> Prefer 'last modified' over eTag. Pass \"true\" or \"false\" in the value parameter.</li><li><b>disable_client_side_caching</b> Disable client side caching. Pass \"true\" or \"false\" in the value parameter.</li><li><b>cache_300x</b> Cache 300X responses. Pass \"true\" or \"false\" in the value parameter.</li><li><b>unite_naked_full_cache</b> Use the same cache for full and naked domains. For example, use the same cached resource for <a href=\"https://www.example.com/a\"></a> and <a href=\"https://example.com/\"></a>a.</li><li><b>cache_empty_responses</b> Cache responses that don’t have a message body.</li><li><b>cache_http_10_responses</b> Cache HTTP 1.0 type responses that don’t include the Content-Length header or chunking. Pass \"true\" or \"false\" in the value parameter.</li><li><b>send_age_header</b> Send <b>Cache-Control: max-age</b> and <b>Age</b> headers. Pass \"true\" or \"false\" in the value parameter.</li><li><b>support_non_sni_clients</b> By default, non-SNI clients are supported. Disable this option to block non-SNI clients. Pass \"true\" or \"false\" in the value parameter.</li><li><b>origin_connection_reuse</b> By default, TCP connections that are opened for a client request remain open for a short time to handle additional requests that may arrive. This option disables that behavior.. Pass \"true\" or \"false\" in the value parameter.</li><li><b>redirect_http_to_https</b> Redirect HTTP requests to HTTPS requests by sending an HTTP 301 response.</li><li><b>redirect_naked_domain_to_full</b> Redirect requests from your website's naked domain to its full domain by sending and HTTP 301 response.</li><li><b>http_2</b> Enables supporting browsers to take advantage of the performance enhancements provided by HTTP/2 for your website. Non-supporting browsers can connect via HTTP/1.0 or HTTP/1.1. HTTP/2 support requires that SSL is configured for your website. Pass \"true\" or \"false\" in the value parameter</li></ul> (required)
        :param str value: According to the param value. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'param', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_advanced_caching_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_advanced_caching_settings`")  # noqa: E501
        # verify the required parameter 'param' is set
        if ('param' not in params or
                params['param'] is None):
            raise ValueError("Missing the required parameter `param` when calling `modify_advanced_caching_settings`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `modify_advanced_caching_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'param' in params:
            query_params.append(('param', params['param']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/advanced', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_cache404_settings(self, site_id, enable, **kwargs):  # noqa: E501
        """Modify cache 404 settings  # noqa: E501

        Use this operation to modify the caching settings of 404 responses for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_cache404_settings(site_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str enable: Pass 'true' to cache 404 responses, 'false' to disable the option. (required)
        :param str time: A positive number representing the amount of time to cache 404 responses. Default value: 10
        :param str time_unit: Unit of time for caching 404 responses. One of MINUTES, HOURS, DAYS, WEEKS. Default value: HOURS
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_cache404_settings_with_http_info(site_id, enable, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_cache404_settings_with_http_info(site_id, enable, **kwargs)  # noqa: E501
            return data

    def modify_cache404_settings_with_http_info(self, site_id, enable, **kwargs):  # noqa: E501
        """Modify cache 404 settings  # noqa: E501

        Use this operation to modify the caching settings of 404 responses for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_cache404_settings_with_http_info(site_id, enable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str enable: Pass 'true' to cache 404 responses, 'false' to disable the option. (required)
        :param str time: A positive number representing the amount of time to cache 404 responses. Default value: 10
        :param str time_unit: Unit of time for caching 404 responses. One of MINUTES, HOURS, DAYS, WEEKS. Default value: HOURS
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'enable', 'time', 'time_unit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_cache404_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_cache404_settings`")  # noqa: E501
        # verify the required parameter 'enable' is set
        if ('enable' not in params or
                params['enable'] is None):
            raise ValueError("Missing the required parameter `enable` when calling `modify_cache404_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'enable' in params:
            query_params.append(('enable', params['enable']))  # noqa: E501
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501
        if 'time_unit' in params:
            query_params.append(('time_unit', params['time_unit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache404/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_purge_settings(self, site_id, resource_url, resource_pattern, **kwargs):  # noqa: E501
        """Purge resources  # noqa: E501

        Use this operation to purge site resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_purge_settings(site_id, resource_url, resource_pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str resource_url: Comma separated list of URLs where the resource is located. (required)
        :param str resource_pattern: Comma separated list of pattern. One of: contains | equals | prefix | suffix | not_equals | not_contains | not_prefix | not_suffix (required)
        :param str should_purge_all_site_resources: Should purge all cached resources on site.</br>Possible values:</br>If the parameter does not exist, is null, or an empty string, it is ignored and only specific resources defined by the resource_pattern and resource_url parameters are purged.</br><b>true</b> or <b>TRUE</b>: All site resources are purged.</br><b>false</b> or <b>FALSE</b>: Nothing is done.</br>Any other string: An error is returned.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_purge_settings_with_http_info(site_id, resource_url, resource_pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_purge_settings_with_http_info(site_id, resource_url, resource_pattern, **kwargs)  # noqa: E501
            return data

    def modify_purge_settings_with_http_info(self, site_id, resource_url, resource_pattern, **kwargs):  # noqa: E501
        """Purge resources  # noqa: E501

        Use this operation to purge site resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_purge_settings_with_http_info(site_id, resource_url, resource_pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str resource_url: Comma separated list of URLs where the resource is located. (required)
        :param str resource_pattern: Comma separated list of pattern. One of: contains | equals | prefix | suffix | not_equals | not_contains | not_prefix | not_suffix (required)
        :param str should_purge_all_site_resources: Should purge all cached resources on site.</br>Possible values:</br>If the parameter does not exist, is null, or an empty string, it is ignored and only specific resources defined by the resource_pattern and resource_url parameters are purged.</br><b>true</b> or <b>TRUE</b>: All site resources are purged.</br><b>false</b> or <b>FALSE</b>: Nothing is done.</br>Any other string: An error is returned.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'resource_url', 'resource_pattern', 'should_purge_all_site_resources']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_purge_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_purge_settings`")  # noqa: E501
        # verify the required parameter 'resource_url' is set
        if ('resource_url' not in params or
                params['resource_url'] is None):
            raise ValueError("Missing the required parameter `resource_url` when calling `modify_purge_settings`")  # noqa: E501
        # verify the required parameter 'resource_pattern' is set
        if ('resource_pattern' not in params or
                params['resource_pattern'] is None):
            raise ValueError("Missing the required parameter `resource_pattern` when calling `modify_purge_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'resource_url' in params:
            query_params.append(('resource_url', params['resource_url']))  # noqa: E501
        if 'resource_pattern' in params:
            query_params.append(('resource_pattern', params['resource_pattern']))  # noqa: E501
        if 'should_purge_all_site_resources' in params:
            query_params.append(('should_purge_all_site_resources', params['should_purge_all_site_resources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/purge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_response_header_settings(self, site_id, **kwargs):  # noqa: E501
        """Modify cached response headers  # noqa: E501

        Use this operation to modify cached response headers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_response_header_settings(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str cache_headers: Comma separated list of header names to be cached
        :param str cache_all_headers: Cache all response headers. Pass \"true\" or \"false\" in the value parameter. Cannot be selected together with cache_headers. Default:false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_response_header_settings_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_response_header_settings_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def modify_response_header_settings_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Modify cached response headers  # noqa: E501

        Use this operation to modify cached response headers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_response_header_settings_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str cache_headers: Comma separated list of header names to be cached
        :param str cache_all_headers: Cache all response headers. Pass \"true\" or \"false\" in the value parameter. Cannot be selected together with cache_headers. Default:false
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'cache_headers', 'cache_all_headers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_response_header_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_response_header_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'cache_headers' in params:
            query_params.append(('cache_headers', params['cache_headers']))  # noqa: E501
        if 'cache_all_headers' in params:
            query_params.append(('cache_all_headers', params['cache_all_headers']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/response-headers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_rewrite_ports(self, site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, **kwargs):  # noqa: E501
        """Modify rewrite port  # noqa: E501

        Use this operation to rewrite the port number used to access the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_rewrite_ports(site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param bool rewrite_port_enabled: Boolean value to indicate whether the default non-SSL port should be rewritten or not (required)
        :param bool rewrite_ssl_port_enabled: Boolean value to indicate whether the default SSL port should be rewritten or not (required)
        :param str port: The port number. If empty, rewrite port will be removed
        :param str ssl_port: The port number to rewrite default SSL port to
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_rewrite_ports_with_http_info(site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_rewrite_ports_with_http_info(site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, **kwargs)  # noqa: E501
            return data

    def modify_rewrite_ports_with_http_info(self, site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, **kwargs):  # noqa: E501
        """Modify rewrite port  # noqa: E501

        Use this operation to rewrite the port number used to access the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_rewrite_ports_with_http_info(site_id, rewrite_port_enabled, rewrite_ssl_port_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param bool rewrite_port_enabled: Boolean value to indicate whether the default non-SSL port should be rewritten or not (required)
        :param bool rewrite_ssl_port_enabled: Boolean value to indicate whether the default SSL port should be rewritten or not (required)
        :param str port: The port number. If empty, rewrite port will be removed
        :param str ssl_port: The port number to rewrite default SSL port to
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'rewrite_port_enabled', 'rewrite_ssl_port_enabled', 'port', 'ssl_port']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_rewrite_ports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_rewrite_ports`")  # noqa: E501
        # verify the required parameter 'rewrite_port_enabled' is set
        if ('rewrite_port_enabled' not in params or
                params['rewrite_port_enabled'] is None):
            raise ValueError("Missing the required parameter `rewrite_port_enabled` when calling `modify_rewrite_ports`")  # noqa: E501
        # verify the required parameter 'rewrite_ssl_port_enabled' is set
        if ('rewrite_ssl_port_enabled' not in params or
                params['rewrite_ssl_port_enabled'] is None):
            raise ValueError("Missing the required parameter `rewrite_ssl_port_enabled` when calling `modify_rewrite_ports`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'rewrite_port_enabled' in params:
            query_params.append(('rewrite_port_enabled', params['rewrite_port_enabled']))  # noqa: E501
        if 'port' in params:
            query_params.append(('port', params['port']))  # noqa: E501
        if 'rewrite_ssl_port_enabled' in params:
            query_params.append(('rewrite_ssl_port_enabled', params['rewrite_ssl_port_enabled']))  # noqa: E501
        if 'ssl_port' in params:
            query_params.append(('ssl_port', params['ssl_port']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/rewrite-port/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_site_configuration(self, site_id, param, value, **kwargs):  # noqa: E501
        """Modify site configuration  # noqa: E501

        Use this operation to change one of the basic configuration settings of the site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_configuration(site_id, param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str param: Name of configuration parameter to set.<br/>Parameter values:<br/><ul><li><b>active</b> Whether the site is active or bypassed by the Imperva network. One of: active | bypass.</li><li><b>site_ip</b> Comma separated list of IPs. For example: 8.8.8.8,1.2.2.2</li><li><b>domain_validation</b> Sets the domain validation method that will be used to generate an SSL certificate. One of: email | html | dns | cname<br/><b>One-step onboarding:</b> After adding a site and configuring your traffic to point to Imperva, use the html option to automatically add SSL support. Certificate creation takes approximately 5 minutes. During this time no traffic will reach the origin server.<br/><b>Note</b>: When running domain validation on a site, you may see the following error message in the API response: Internal error - \"Add site operation hasn't finished\".<br/>After running the add site process, it may take several minutes for the database to finish updating. During this time, attempts to further configure the site are blocked.<br/>In some cases, the database is not updated even after the add site process is complete.<br/>If the issue does not resolve after a few minutes, contact Support.</li><li><b>approver</b> Sets the approver e-mail address that will be used to perform SSL domain validation.</li><li><b>ignore_ssl</b> Sets the ignore SSL flag (if the site is in pending-select-approver state). Pass \"true\" in the value parameter.</li><li><b>acceleration_level</b> Sets the acceleration level of the site, one of: none | standard | aggressive. It is advised to use the newer Modify caching mode API call instead, as it provides enhanced functionality.</li><li><b>seal_location</b> Sets the seal location, e.g. \"api.seal_location.bottom_right\".</li><li><b>domain_redirect_to_full</b> Sets the redirect naked to full flag. Pass \"true\" in the value parameter.</li><li><b>remove_ssl</b> Sets the remove SSL from site flag. Pass \"true\" in the value parameter.</li><li><b>ref_id</b> Sets the Reference ID, a free-text field that enables you to add a unique identifier to correlate an object in our service, such as a protected website, with an object on the customer side.</li><li><b>naked_domain_san</b> Use this option to determine if the naked domain SAN will be added to the SSL certificate for www site. Will take effect in the next renewal.</li><li><b>wildcard_san</b> Use this option to determine if the wildcard SAN or the full domain SAN is added to the Imperva SSL certificate for site. Will take effect in the next renewal.</li><li><b>set_cookies_without_domain</b> Use this option to determine if to set site cookies without domain.</li><li><b>restricted_cname_reuse</b> Use this option to determine if legitimate traffic for all verified domains in the table is automatically allowed.</li><li><b>request_body_timeouts</b> Use this option to override default mitigation settings for slow HTTP attacks.</li><b>Note</b>: Send value in the format of {“methods”: [method name,method name,…],“interval”: integer,“byteCount”: integer}. For example: {“methods”: [HTTP_POST, HTTP_GET],“interval”:30,“byteCount”:20}. Each post of the API overwrites the custom configuration. To delete the whole custom configuration, send {} as the value. Possible values for method: HTTP_POST, HTTP_GET, HTTP_PUT, HTTP_RPC_IN_DATA, HTTP_RPC_OUT_DATA</ul> (required)
        :param str value: According to the param value. (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_site_configuration_with_http_info(site_id, param, value, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_site_configuration_with_http_info(site_id, param, value, **kwargs)  # noqa: E501
            return data

    def modify_site_configuration_with_http_info(self, site_id, param, value, **kwargs):  # noqa: E501
        """Modify site configuration  # noqa: E501

        Use this operation to change one of the basic configuration settings of the site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_configuration_with_http_info(site_id, param, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str param: Name of configuration parameter to set.<br/>Parameter values:<br/><ul><li><b>active</b> Whether the site is active or bypassed by the Imperva network. One of: active | bypass.</li><li><b>site_ip</b> Comma separated list of IPs. For example: 8.8.8.8,1.2.2.2</li><li><b>domain_validation</b> Sets the domain validation method that will be used to generate an SSL certificate. One of: email | html | dns | cname<br/><b>One-step onboarding:</b> After adding a site and configuring your traffic to point to Imperva, use the html option to automatically add SSL support. Certificate creation takes approximately 5 minutes. During this time no traffic will reach the origin server.<br/><b>Note</b>: When running domain validation on a site, you may see the following error message in the API response: Internal error - \"Add site operation hasn't finished\".<br/>After running the add site process, it may take several minutes for the database to finish updating. During this time, attempts to further configure the site are blocked.<br/>In some cases, the database is not updated even after the add site process is complete.<br/>If the issue does not resolve after a few minutes, contact Support.</li><li><b>approver</b> Sets the approver e-mail address that will be used to perform SSL domain validation.</li><li><b>ignore_ssl</b> Sets the ignore SSL flag (if the site is in pending-select-approver state). Pass \"true\" in the value parameter.</li><li><b>acceleration_level</b> Sets the acceleration level of the site, one of: none | standard | aggressive. It is advised to use the newer Modify caching mode API call instead, as it provides enhanced functionality.</li><li><b>seal_location</b> Sets the seal location, e.g. \"api.seal_location.bottom_right\".</li><li><b>domain_redirect_to_full</b> Sets the redirect naked to full flag. Pass \"true\" in the value parameter.</li><li><b>remove_ssl</b> Sets the remove SSL from site flag. Pass \"true\" in the value parameter.</li><li><b>ref_id</b> Sets the Reference ID, a free-text field that enables you to add a unique identifier to correlate an object in our service, such as a protected website, with an object on the customer side.</li><li><b>naked_domain_san</b> Use this option to determine if the naked domain SAN will be added to the SSL certificate for www site. Will take effect in the next renewal.</li><li><b>wildcard_san</b> Use this option to determine if the wildcard SAN or the full domain SAN is added to the Imperva SSL certificate for site. Will take effect in the next renewal.</li><li><b>set_cookies_without_domain</b> Use this option to determine if to set site cookies without domain.</li><li><b>restricted_cname_reuse</b> Use this option to determine if legitimate traffic for all verified domains in the table is automatically allowed.</li><li><b>request_body_timeouts</b> Use this option to override default mitigation settings for slow HTTP attacks.</li><b>Note</b>: Send value in the format of {“methods”: [method name,method name,…],“interval”: integer,“byteCount”: integer}. For example: {“methods”: [HTTP_POST, HTTP_GET],“interval”:30,“byteCount”:20}. Each post of the API overwrites the custom configuration. To delete the whole custom configuration, send {} as the value. Possible values for method: HTTP_POST, HTTP_GET, HTTP_PUT, HTTP_RPC_IN_DATA, HTTP_RPC_OUT_DATA</ul> (required)
        :param str value: According to the param value. (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'param', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_site_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_site_configuration`")  # noqa: E501
        # verify the required parameter 'param' is set
        if ('param' not in params or
                params['param'] is None):
            raise ValueError("Missing the required parameter `param` when calling `modify_site_configuration`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `modify_site_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'param' in params:
            query_params.append(('param', params['param']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/configure', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_site_error_page_template(self, site_id, error_page_template, **kwargs):  # noqa: E501
        """Modify error page  # noqa: E501

        Use this operation to set a custom error page for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_error_page_template(site_id, error_page_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str error_page_template: The error page html template. $TITLE$ and $BODY$ placeholders are required. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_site_error_page_template_with_http_info(site_id, error_page_template, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_site_error_page_template_with_http_info(site_id, error_page_template, **kwargs)  # noqa: E501
            return data

    def modify_site_error_page_template_with_http_info(self, site_id, error_page_template, **kwargs):  # noqa: E501
        """Modify error page  # noqa: E501

        Use this operation to set a custom error page for a given site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_error_page_template_with_http_info(site_id, error_page_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str error_page_template: The error page html template. $TITLE$ and $BODY$ placeholders are required. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'error_page_template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_site_error_page_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_site_error_page_template`")  # noqa: E501
        # verify the required parameter 'error_page_template' is set
        if ('error_page_template' not in params or
                params['error_page_template'] is None):
            raise ValueError("Missing the required parameter `error_page_template` when calling `modify_site_error_page_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'error_page_template' in params:
            query_params.append(('error_page_template', params['error_page_template']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/error-page/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_site_log_level(self, site_id, log_level, **kwargs):  # noqa: E501
        """Modify site logs level  # noqa: E501

        Use this operation to change the site log configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_log_level(site_id, log_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str log_level: Available only for customers that purchased the Logs Integration SKU. Sets the log reporting level for the site.<br/>Possible values: full, security, none, default (required)
        :param str logs_account_id: Available only for customers that purchased the Logs Integration SKU. Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_site_log_level_with_http_info(site_id, log_level, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_site_log_level_with_http_info(site_id, log_level, **kwargs)  # noqa: E501
            return data

    def modify_site_log_level_with_http_info(self, site_id, log_level, **kwargs):  # noqa: E501
        """Modify site logs level  # noqa: E501

        Use this operation to change the site log configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_log_level_with_http_info(site_id, log_level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str log_level: Available only for customers that purchased the Logs Integration SKU. Sets the log reporting level for the site.<br/>Possible values: full, security, none, default (required)
        :param str logs_account_id: Available only for customers that purchased the Logs Integration SKU. Numeric identifier of the account that purchased the logs integration SKU and which collects the logs.<br/>If not specified, operation will be performed on the account identified by the authentication parameters
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'log_level', 'logs_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_site_log_level" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_site_log_level`")  # noqa: E501
        # verify the required parameter 'log_level' is set
        if ('log_level' not in params or
                params['log_level'] is None):
            raise ValueError("Missing the required parameter `log_level` when calling `modify_site_log_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'log_level' in params:
            query_params.append(('log_level', params['log_level']))  # noqa: E501
        if 'logs_account_id' in params:
            query_params.append(('logs_account_id', params['logs_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/setlog', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_site_security_configuration(self, site_id, rule_id, **kwargs):  # noqa: E501
        """Modify site security configuration  # noqa: E501

        Use this operation to change the security configuration of a site. To modify the configuration for a specific rule, additional parameters may be required, as documented below.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_security_configuration(site_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str rule_id: ID of the security rule to change.<br/>Values for the rule_id parameter:<br/><ul><li>api.threats.bot_access_control</li><li>api.threats.sql_injection</li><li>api.threats.cross_site_scripting</li><li>api.threats.backdoor</li><li>api.threats.ddos</li><li>api.threats.remote_file_inclusion</li></ul> (required)
        :param str block_bad_bots: Whether or not to block bad bots. Possible values: true, false
        :param str challenge_suspected_bots: Whether or not to send a challenge to clients that are suspected to be bad bots (CAPTCHA for example). Possible values: true, false
        :param str activation_mode: Possible values: api.threats.ddos.activation_mode.off, api.threats.ddos.activation_mode.auto, api.threats.ddos.activation_mode.on<br/><ul><li><b>api.threats.ddos.activation_mode.off</b> security measures are disabled even if site is under a DDoS attack</li><li><b>api.threats.ddos.activation_mode.auto</b> security measures will be activated automatically when the system suspects site is under a DDoS attack</li><li><b>api.threats.ddos.activation_mode.on</b> security measures are enabled even if site is not under a DDoS attack</li></ul>The syntax is as follows:<rule_id>.activation_mode.<value> For example, for 'off', use 'activation_mode=api.threats.ddos.activation_mode.off.<br/><b>Note:</b> This parameter is relevant and required for a DDoS rule only -- where rule_id=api.threats.ddos.
        :param str security_rule_action: The action that should be taken when a threat is detected, for example:<br/>api.threats.action.block_ip. Different actions are allowed per different threats, e.g. backdoors may only be quarantined, ignored, or trigger an alert.<br/>Values for the security_rule_action parameter:<br/><ul><li><b>api.threats.action.disabled</b> Threat is not blocked, site owner is not notified.</li><li><b>api.threats.action.alert</b> Threat is not blocked, site owner is notified.</li><li><b>api.threats.action.block_request</b> Threat blocked by stopping the request, site owner is notified.</li><li><b>api.threats.action.block_user</b> Threat blocked by stopping the request. Additional requests by the client application will be automatically blocked for a duration of several minutes. Site owner is notified.</li><li><b>api.threats.action.block_ip</b> Threat blocked by stopping the request. Additional requests from the same IP addresses will be automatically blocked for a duration of several minutes. Site owner is notified.</li><li><b>api.threats.action.quarantine_url</b> Relevant only for Backdoor Protect. When detecting a backdoor, additional requests to the URL of the backdoor will be automatically blocked. Site owner is notified.</li></ul>
        :param str quarantined_urls: Removes quarantined URLs from the backdoor protection list, as defined in the Cloud Security Console Website Settings > WAF Settings > Backdoor Protect.<br/>To remove a URL from the backdoor protection list, use the following parameters with the specified values:<br/>quarantined_urls: <URL full path><br/>rule_id: api.threats.backdoor<br/>security_rule_action: api.threats.action.quarantine_url
        :param int ddos_traffic_threshold: Consider site to be under DDoS if the request rate is above this threshold.<br/><b>Allowed values:</b> 10-10000 requests per second.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_site_security_configuration_with_http_info(site_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_site_security_configuration_with_http_info(site_id, rule_id, **kwargs)  # noqa: E501
            return data

    def modify_site_security_configuration_with_http_info(self, site_id, rule_id, **kwargs):  # noqa: E501
        """Modify site security configuration  # noqa: E501

        Use this operation to change the security configuration of a site. To modify the configuration for a specific rule, additional parameters may be required, as documented below.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_security_configuration_with_http_info(site_id, rule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str rule_id: ID of the security rule to change.<br/>Values for the rule_id parameter:<br/><ul><li>api.threats.bot_access_control</li><li>api.threats.sql_injection</li><li>api.threats.cross_site_scripting</li><li>api.threats.backdoor</li><li>api.threats.ddos</li><li>api.threats.remote_file_inclusion</li></ul> (required)
        :param str block_bad_bots: Whether or not to block bad bots. Possible values: true, false
        :param str challenge_suspected_bots: Whether or not to send a challenge to clients that are suspected to be bad bots (CAPTCHA for example). Possible values: true, false
        :param str activation_mode: Possible values: api.threats.ddos.activation_mode.off, api.threats.ddos.activation_mode.auto, api.threats.ddos.activation_mode.on<br/><ul><li><b>api.threats.ddos.activation_mode.off</b> security measures are disabled even if site is under a DDoS attack</li><li><b>api.threats.ddos.activation_mode.auto</b> security measures will be activated automatically when the system suspects site is under a DDoS attack</li><li><b>api.threats.ddos.activation_mode.on</b> security measures are enabled even if site is not under a DDoS attack</li></ul>The syntax is as follows:<rule_id>.activation_mode.<value> For example, for 'off', use 'activation_mode=api.threats.ddos.activation_mode.off.<br/><b>Note:</b> This parameter is relevant and required for a DDoS rule only -- where rule_id=api.threats.ddos.
        :param str security_rule_action: The action that should be taken when a threat is detected, for example:<br/>api.threats.action.block_ip. Different actions are allowed per different threats, e.g. backdoors may only be quarantined, ignored, or trigger an alert.<br/>Values for the security_rule_action parameter:<br/><ul><li><b>api.threats.action.disabled</b> Threat is not blocked, site owner is not notified.</li><li><b>api.threats.action.alert</b> Threat is not blocked, site owner is notified.</li><li><b>api.threats.action.block_request</b> Threat blocked by stopping the request, site owner is notified.</li><li><b>api.threats.action.block_user</b> Threat blocked by stopping the request. Additional requests by the client application will be automatically blocked for a duration of several minutes. Site owner is notified.</li><li><b>api.threats.action.block_ip</b> Threat blocked by stopping the request. Additional requests from the same IP addresses will be automatically blocked for a duration of several minutes. Site owner is notified.</li><li><b>api.threats.action.quarantine_url</b> Relevant only for Backdoor Protect. When detecting a backdoor, additional requests to the URL of the backdoor will be automatically blocked. Site owner is notified.</li></ul>
        :param str quarantined_urls: Removes quarantined URLs from the backdoor protection list, as defined in the Cloud Security Console Website Settings > WAF Settings > Backdoor Protect.<br/>To remove a URL from the backdoor protection list, use the following parameters with the specified values:<br/>quarantined_urls: <URL full path><br/>rule_id: api.threats.backdoor<br/>security_rule_action: api.threats.action.quarantine_url
        :param int ddos_traffic_threshold: Consider site to be under DDoS if the request rate is above this threshold.<br/><b>Allowed values:</b> 10-10000 requests per second.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'rule_id', 'block_bad_bots', 'challenge_suspected_bots', 'activation_mode', 'security_rule_action', 'quarantined_urls', 'ddos_traffic_threshold']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_site_security_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_site_security_configuration`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `modify_site_security_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'block_bad_bots' in params:
            query_params.append(('block_bad_bots', params['block_bad_bots']))  # noqa: E501
        if 'challenge_suspected_bots' in params:
            query_params.append(('challenge_suspected_bots', params['challenge_suspected_bots']))  # noqa: E501
        if 'activation_mode' in params:
            query_params.append(('activation_mode', params['activation_mode']))  # noqa: E501
        if 'security_rule_action' in params:
            query_params.append(('security_rule_action', params['security_rule_action']))  # noqa: E501
        if 'quarantined_urls' in params:
            query_params.append(('quarantined_urls', params['quarantined_urls']))  # noqa: E501
        if 'ddos_traffic_threshold' in params:
            query_params.append(('ddos_traffic_threshold', params['ddos_traffic_threshold']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/configure/security', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_site_support_deprecated_tls(self, site_id, support_all_tls_versions, **kwargs):  # noqa: E501
        """Set support for all TLS versions  # noqa: E501

        Use this operation to support all TLS versions for the site for connectivity between clients (visitors) and the Imperva service. To remain PCI-compliant, do not enable this option.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_support_deprecated_tls(site_id, support_all_tls_versions, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param bool support_all_tls_versions: Support all TLS versions. Default value: false (required)
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_site_support_deprecated_tls_with_http_info(site_id, support_all_tls_versions, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_site_support_deprecated_tls_with_http_info(site_id, support_all_tls_versions, **kwargs)  # noqa: E501
            return data

    def modify_site_support_deprecated_tls_with_http_info(self, site_id, support_all_tls_versions, **kwargs):  # noqa: E501
        """Set support for all TLS versions  # noqa: E501

        Use this operation to support all TLS versions for the site for connectivity between clients (visitors) and the Imperva service. To remain PCI-compliant, do not enable this option.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_site_support_deprecated_tls_with_http_info(site_id, support_all_tls_versions, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param bool support_all_tls_versions: Support all TLS versions. Default value: false (required)
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'support_all_tls_versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_site_support_deprecated_tls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_site_support_deprecated_tls`")  # noqa: E501
        # verify the required parameter 'support_all_tls_versions' is set
        if ('support_all_tls_versions' not in params or
                params['support_all_tls_versions'] is None):
            raise ValueError("Missing the required parameter `support_all_tls_versions` when calling `modify_site_support_deprecated_tls`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'support_all_tls_versions' in params:
            query_params.append(('support_all_tls_versions', params['support_all_tls_versions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/tls', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_stale_content(self, site_id, serve_stale_content, stale_content_mode, **kwargs):  # noqa: E501
        """Modify stale content settings  # noqa: E501

        When Imperva can't connect to the origin server, serve stale content instead of displaying an error to end users for the specified amount of time. Expired resources are returned from cache, and refreshed asynchronously in the background.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_stale_content(site_id, serve_stale_content, stale_content_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str serve_stale_content: Pass <b>true</b> to serve stale content, <b>false</b> to disable the option. (required)
        :param str stale_content_mode: Pass <b>ADAPTIVE</b> to use Imperva's algorithm, or <b>CUSTOM</b> to specify an amount of time. When using <b>CUSTOM</b>, you must specify the time and time_unit parameters. (required)
        :param str time: A positive number representing the amount of time to serve stale content.
        :param str time_unit: Stale content time unit. One of SECONDS, MINUTES, HOURS.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_stale_content_with_http_info(site_id, serve_stale_content, stale_content_mode, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_stale_content_with_http_info(site_id, serve_stale_content, stale_content_mode, **kwargs)  # noqa: E501
            return data

    def modify_stale_content_with_http_info(self, site_id, serve_stale_content, stale_content_mode, **kwargs):  # noqa: E501
        """Modify stale content settings  # noqa: E501

        When Imperva can't connect to the origin server, serve stale content instead of displaying an error to end users for the specified amount of time. Expired resources are returned from cache, and refreshed asynchronously in the background.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_stale_content_with_http_info(site_id, serve_stale_content, stale_content_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str serve_stale_content: Pass <b>true</b> to serve stale content, <b>false</b> to disable the option. (required)
        :param str stale_content_mode: Pass <b>ADAPTIVE</b> to use Imperva's algorithm, or <b>CUSTOM</b> to specify an amount of time. When using <b>CUSTOM</b>, you must specify the time and time_unit parameters. (required)
        :param str time: A positive number representing the amount of time to serve stale content.
        :param str time_unit: Stale content time unit. One of SECONDS, MINUTES, HOURS.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'serve_stale_content', 'stale_content_mode', 'time', 'time_unit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_stale_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_stale_content`")  # noqa: E501
        # verify the required parameter 'serve_stale_content' is set
        if ('serve_stale_content' not in params or
                params['serve_stale_content'] is None):
            raise ValueError("Missing the required parameter `serve_stale_content` when calling `modify_stale_content`")  # noqa: E501
        # verify the required parameter 'stale_content_mode' is set
        if ('stale_content_mode' not in params or
                params['stale_content_mode'] is None):
            raise ValueError("Missing the required parameter `stale_content_mode` when calling `modify_stale_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'serve_stale_content' in params:
            query_params.append(('serve_stale_content', params['serve_stale_content']))  # noqa: E501
        if 'stale_content_mode' in params:
            query_params.append(('stale_content_mode', params['stale_content_mode']))  # noqa: E501
        if 'time' in params:
            query_params.append(('time', params['time']))  # noqa: E501
        if 'time_unit' in params:
            query_params.append(('time_unit', params['time_unit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/stale-content', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modify_tag_response_header(self, site_id, header, **kwargs):  # noqa: E501
        """Tag the response according to the value of a header  # noqa: E501

        Specify which origin response header contains the cache tags in your resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_tag_response_header(site_id, header, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str header: Specify which origin response header contains the cache tags in your resources. default: \"\". (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.modify_tag_response_header_with_http_info(site_id, header, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_tag_response_header_with_http_info(site_id, header, **kwargs)  # noqa: E501
            return data

    def modify_tag_response_header_with_http_info(self, site_id, header, **kwargs):  # noqa: E501
        """Tag the response according to the value of a header  # noqa: E501

        Specify which origin response header contains the cache tags in your resources.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modify_tag_response_header_with_http_info(site_id, header, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str header: Specify which origin response header contains the cache tags in your resources. default: \"\". (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'header']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_tag_response_header" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `modify_tag_response_header`")  # noqa: E501
        # verify the required parameter 'header' is set
        if ('header' not in params or
                params['header'] is None):
            raise ValueError("Missing the required parameter `header` when calling `modify_tag_response_header`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'header' in params:
            query_params.append(('header', params['header']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/tag-response', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_site(self, site_id, destination_account_id, **kwargs):  # noqa: E501
        """Move site  # noqa: E501

        Use this operation to move a site from its account to another account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_site(site_id, destination_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to move (required)
        :param int destination_account_id: The numeric identifier of the account which the site will be moved to (required)
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_site_with_http_info(site_id, destination_account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.move_site_with_http_info(site_id, destination_account_id, **kwargs)  # noqa: E501
            return data

    def move_site_with_http_info(self, site_id, destination_account_id, **kwargs):  # noqa: E501
        """Move site  # noqa: E501

        Use this operation to move a site from its account to another account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_site_with_http_info(site_id, destination_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to move (required)
        :param int destination_account_id: The numeric identifier of the account which the site will be moved to (required)
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'destination_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `move_site`")  # noqa: E501
        # verify the required parameter 'destination_account_id' is set
        if ('destination_account_id' not in params or
                params['destination_account_id'] is None):
            raise ValueError("Missing the required parameter `destination_account_id` when calling `move_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'destination_account_id' in params:
            query_params.append(('destination_account_id', params['destination_account_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/moveSite', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20035',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def purge_hostname(self, **kwargs):  # noqa: E501
        """Purge hostname from cache  # noqa: E501

        Use this operation to purge the hostname from the cache. This API is for customers who use the same CNAME provided by Imperva for multiple hostnames and would like to change the CNAME for a particular hostname. Purging the hostname is required for the CNAME change to take effect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.purge_hostname(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str host_name: The hostname to purge from the cache
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.purge_hostname_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.purge_hostname_with_http_info(**kwargs)  # noqa: E501
            return data

    def purge_hostname_with_http_info(self, **kwargs):  # noqa: E501
        """Purge hostname from cache  # noqa: E501

        Use this operation to purge the hostname from the cache. This API is for customers who use the same CNAME provided by Imperva for multiple hostnames and would like to change the CNAME for a particular hostname. Purging the hostname is required for the CNAME change to take effect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.purge_hostname_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str host_name: The hostname to purge from the cache
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['host_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method purge_hostname" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'host_name' in params:
            query_params.append(('host_name', params['host_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/hostname/purge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def purge_site_cache(self, site_id, **kwargs):  # noqa: E501
        """Purge site cache  # noqa: E501

        Use this operation to purge all cached content on our proxy servers for a specific site.<br/>Our Proxy servers keep cached content of your sites in order to accelerate page load times for your users.<br/>When you want this cached content to be refreshed (for example, after making adjustments in your site) you can use this API call.<br/>In order to purge the entire cached content for this site just use the API call with no parameters.<br/>If you want to purge a specific resource add the resource name as parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.purge_site_cache(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str purge_pattern: The pattern of the resource to be purged from the cache. For example:</br><ul/><li><b>Resource_name</b> - Resources that contain Resource_name will be purged</li><li><b>^Resource_name</b> - Resources that start with Resource_name will be purged</li><li><b>Resource_name$</b> - Resources that end with Resource_name will be purged.</li></ul>
        :param str purge_tag_names: A comma separated list of tag names to purge.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.purge_site_cache_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.purge_site_cache_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def purge_site_cache_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Purge site cache  # noqa: E501

        Use this operation to purge all cached content on our proxy servers for a specific site.<br/>Our Proxy servers keep cached content of your sites in order to accelerate page load times for your users.<br/>When you want this cached content to be refreshed (for example, after making adjustments in your site) you can use this API call.<br/>In order to purge the entire cached content for this site just use the API call with no parameters.<br/>If you want to purge a specific resource add the resource name as parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.purge_site_cache_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str purge_pattern: The pattern of the resource to be purged from the cache. For example:</br><ul/><li><b>Resource_name</b> - Resources that contain Resource_name will be purged</li><li><b>^Resource_name</b> - Resources that start with Resource_name will be purged</li><li><b>Resource_name$</b> - Resources that end with Resource_name will be purged.</li></ul>
        :param str purge_tag_names: A comma separated list of tag names to purge.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'purge_pattern', 'purge_tag_names']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method purge_site_cache" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `purge_site_cache`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'purge_pattern' in params:
            query_params.append(('purge_pattern', params['purge_pattern']))  # noqa: E501
        if 'purge_tag_names' in params:
            query_params.append(('purge_tag_names', params['purge_tag_names']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/cache/purge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_data_centers_configuration(self, body, ext_site_id, **kwargs):  # noqa: E501
        """set site's data centers' configuration  # noqa: E501

        Use this operation to configure site's data centers and all their servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_data_centers_configuration(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataCentersConfigurationDTO body: JSON body. Schema is identical to the response. (required)
        :param int ext_site_id: (required)
        :return: DataCentersConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_data_centers_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_data_centers_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
            return data

    def put_data_centers_configuration_with_http_info(self, body, ext_site_id, **kwargs):  # noqa: E501
        """set site's data centers' configuration  # noqa: E501

        Use this operation to configure site's data centers and all their servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_data_centers_configuration_with_http_info(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataCentersConfigurationDTO body: JSON body. Schema is identical to the response. (required)
        :param int ext_site_id: (required)
        :return: DataCentersConfigurationDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_data_centers_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_data_centers_configuration`")  # noqa: E501
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `put_data_centers_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/data-centers-configuration', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataCentersConfigurationDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_custom_certificate(self, **kwargs):  # noqa: E501
        """Remove custom certificate  # noqa: E501

        Use this operation to remove a custom certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_custom_certificate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on
        :param str auth_type: The authentication type of the certificate (RSA or ECC). Optional. If not provided, then RSA will be assume 
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_custom_certificate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_custom_certificate_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_custom_certificate_with_http_info(self, **kwargs):  # noqa: E501
        """Remove custom certificate  # noqa: E501

        Use this operation to remove a custom certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_custom_certificate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on
        :param str auth_type: The authentication type of the certificate (RSA or ECC). Optional. If not provided, then RSA will be assume 
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'auth_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_custom_certificate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'auth_type' in params:
            query_params.append(('auth_type', params['auth_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/customCertificate/remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_traffic_to_active_dcs(self, site_id, **kwargs):  # noqa: E501
        """Resume traffic to your active data centers  # noqa: E501

        When at least one active data center is back up, you have to manually reroute your traffic back to the active data center.<br/>Traffic does not revert automatically to your active data centers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_traffic_to_active_dcs(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_traffic_to_active_dcs_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_traffic_to_active_dcs_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def resume_traffic_to_active_dcs_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Resume traffic to your active data centers  # noqa: E501

        When at least one active data center is back up, you have to manually reroute your traffic back to the active data center.<br/>Traffic does not revert automatically to your active data centers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_traffic_to_active_dcs_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_traffic_to_active_dcs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `resume_traffic_to_active_dcs`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/dataCenters/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_caching_mode(self, cache_mode, site_id, **kwargs):  # noqa: E501
        """Modify caching mode  # noqa: E501

        Use this operation to edit basic site caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_caching_mode(cache_mode, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cache_mode: Possible values:<br/><ul/><li>disable</li><li>custom_cache_rules_only</li><li>static_only</li><li>static_and_dynamic</li><li>aggressive</li>Default value: static_only</ul> (required)
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str dynamic_cache_duration: Profile dynamic pages and cache duration. Pass a number followed by '_' and one of: hr | min | sec | days | weeks.</br>Default: 5_min
        :param str aggressive_cache_duration: Cache resource duration. Pass a number followed by '_' and one of: hr | min | sec | days | weeks</br>Default: 1_hr
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_caching_mode_with_http_info(cache_mode, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_caching_mode_with_http_info(cache_mode, site_id, **kwargs)  # noqa: E501
            return data

    def set_caching_mode_with_http_info(self, cache_mode, site_id, **kwargs):  # noqa: E501
        """Modify caching mode  # noqa: E501

        Use this operation to edit basic site caching settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_caching_mode_with_http_info(cache_mode, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cache_mode: Possible values:<br/><ul/><li>disable</li><li>custom_cache_rules_only</li><li>static_only</li><li>static_and_dynamic</li><li>aggressive</li>Default value: static_only</ul> (required)
        :param str site_id: Numeric identifier of the site to operate on. (required)
        :param str dynamic_cache_duration: Profile dynamic pages and cache duration. Pass a number followed by '_' and one of: hr | min | sec | days | weeks.</br>Default: 5_min
        :param str aggressive_cache_duration: Cache resource duration. Pass a number followed by '_' and one of: hr | min | sec | days | weeks</br>Default: 1_hr
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cache_mode', 'site_id', 'dynamic_cache_duration', 'aggressive_cache_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_caching_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cache_mode' is set
        if ('cache_mode' not in params or
                params['cache_mode'] is None):
            raise ValueError("Missing the required parameter `cache_mode` when calling `set_caching_mode`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `set_caching_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cache_mode' in params:
            query_params.append(('cache_mode', params['cache_mode']))  # noqa: E501
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'dynamic_cache_duration' in params:
            query_params.append(('dynamic_cache_duration', params['dynamic_cache_duration']))  # noqa: E501
        if 'aggressive_cache_duration' in params:
            query_params.append(('aggressive_cache_duration', params['aggressive_cache_duration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/cache-mode', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_data_center_origin_po_p(self, dc_id, **kwargs):  # noqa: E501
        """Set data center origin PoP  # noqa: E501

        Set an origin PoP for a given data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_data_center_origin_po_p(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: Numeric identifier of the data center to operate on. (required)
        :param str origin_pop: The ID of the PoP that serves as an access point between Imperva and the customer’s origin server. For example: “lax”, for Los Angeles.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_data_center_origin_po_p_with_http_info(dc_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_data_center_origin_po_p_with_http_info(dc_id, **kwargs)  # noqa: E501
            return data

    def set_data_center_origin_po_p_with_http_info(self, dc_id, **kwargs):  # noqa: E501
        """Set data center origin PoP  # noqa: E501

        Set an origin PoP for a given data center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_data_center_origin_po_p_with_http_info(dc_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int dc_id: Numeric identifier of the data center to operate on. (required)
        :param str origin_pop: The ID of the PoP that serves as an access point between Imperva and the customer’s origin server. For example: “lax”, for Los Angeles.
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dc_id', 'origin_pop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_data_center_origin_po_p" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dc_id' is set
        if ('dc_id' not in params or
                params['dc_id'] is None):
            raise ValueError("Missing the required parameter `dc_id` when calling `set_data_center_origin_po_p`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dc_id' in params:
            query_params.append(('dc_id', params['dc_id']))  # noqa: E501
        if 'origin_pop' in params:
            query_params.append(('origin_pop', params['origin_pop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/datacenter/origin-pop/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_data_region(self, site_id, data_storage_region, **kwargs):  # noqa: E501
        """Set site data storage region  # noqa: E501

        Use this operation to set the site data region.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_data_region(site_id, data_storage_region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str data_storage_region: The data region to use. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_data_region_with_http_info(site_id, data_storage_region, **kwargs)  # noqa: E501
        else:
            (data) = self.set_data_region_with_http_info(site_id, data_storage_region, **kwargs)  # noqa: E501
            return data

    def set_data_region_with_http_info(self, site_id, data_storage_region, **kwargs):  # noqa: E501
        """Set site data storage region  # noqa: E501

        Use this operation to set the site data region.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_data_region_with_http_info(site_id, data_storage_region, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: Numeric identifier of the site to operate on. (required)
        :param str data_storage_region: The data region to use. (required)
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'data_storage_region']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_data_region" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `set_data_region`")  # noqa: E501
        # verify the required parameter 'data_storage_region' is set
        if ('data_storage_region' not in params or
                params['data_storage_region'] is None):
            raise ValueError("Missing the required parameter `data_storage_region` when calling `set_data_region`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'data_storage_region' in params:
            query_params.append(('data_storage_region', params['data_storage_region']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/data-privacy/region-change', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_html_injection_rule(self, site_id, url, url_pattern, location, **kwargs):  # noqa: E501
        """Add, replace or remove a HTML injection rule  # noqa: E501

        Use this operation to add a new HTML injection rule, or to replace or remove an existing rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_html_injection_rule(site_id, url, url_pattern, location, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str url: The URL where the content is injected (required)
        :param str url_pattern: The url pattern. One of: contains | not_contains | equals | not_equals | prefix | suffix | not_prefix | not_suffix (required)
        :param str location: The location of the injection inside the URL ('head' or 'body_end') (required)
        :param str content: The injected HTML snippet, Base64-encoded
        :param bool delete_content: Whether or not to delete existing HTML content.<br/>Possible values: true/false
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_html_injection_rule_with_http_info(site_id, url, url_pattern, location, **kwargs)  # noqa: E501
        else:
            (data) = self.set_html_injection_rule_with_http_info(site_id, url, url_pattern, location, **kwargs)  # noqa: E501
            return data

    def set_html_injection_rule_with_http_info(self, site_id, url, url_pattern, location, **kwargs):  # noqa: E501
        """Add, replace or remove a HTML injection rule  # noqa: E501

        Use this operation to add a new HTML injection rule, or to replace or remove an existing rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_html_injection_rule_with_http_info(site_id, url, url_pattern, location, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str url: The URL where the content is injected (required)
        :param str url_pattern: The url pattern. One of: contains | not_contains | equals | not_equals | prefix | suffix | not_prefix | not_suffix (required)
        :param str location: The location of the injection inside the URL ('head' or 'body_end') (required)
        :param str content: The injected HTML snippet, Base64-encoded
        :param bool delete_content: Whether or not to delete existing HTML content.<br/>Possible values: true/false
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'url', 'url_pattern', 'location', 'content', 'delete_content']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_html_injection_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `set_html_injection_rule`")  # noqa: E501
        # verify the required parameter 'url' is set
        if ('url' not in params or
                params['url'] is None):
            raise ValueError("Missing the required parameter `url` when calling `set_html_injection_rule`")  # noqa: E501
        # verify the required parameter 'url_pattern' is set
        if ('url_pattern' not in params or
                params['url_pattern'] is None):
            raise ValueError("Missing the required parameter `url_pattern` when calling `set_html_injection_rule`")  # noqa: E501
        # verify the required parameter 'location' is set
        if ('location' not in params or
                params['location'] is None):
            raise ValueError("Missing the required parameter `location` when calling `set_html_injection_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'url' in params:
            query_params.append(('url', params['url']))  # noqa: E501
        if 'url_pattern' in params:
            query_params.append(('url_pattern', params['url_pattern']))  # noqa: E501
        if 'location' in params:
            query_params.append(('location', params['location']))  # noqa: E501
        if 'content' in params:
            query_params.append(('content', params['content']))  # noqa: E501
        if 'delete_content' in params:
            query_params.append(('delete_content', params['delete_content']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/configure/htmlInjections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_override_site_regions_by_geo(self, account_id, override_site_regions_by_geo, **kwargs):  # noqa: E501
        """Set site regions by origin geolocation  # noqa: E501

        Use this operation to set the data storage region for each new site based on the geolocation of the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_override_site_regions_by_geo(account_id, override_site_regions_by_geo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters. (required)
        :param bool override_site_regions_by_geo: A boolean parameter. If it is set to \"true\", the data storage region for each new site will be based on the geolocation of the origin server. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_override_site_regions_by_geo_with_http_info(account_id, override_site_regions_by_geo, **kwargs)  # noqa: E501
        else:
            (data) = self.set_override_site_regions_by_geo_with_http_info(account_id, override_site_regions_by_geo, **kwargs)  # noqa: E501
            return data

    def set_override_site_regions_by_geo_with_http_info(self, account_id, override_site_regions_by_geo, **kwargs):  # noqa: E501
        """Set site regions by origin geolocation  # noqa: E501

        Use this operation to set the data storage region for each new site based on the geolocation of the origin server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_override_site_regions_by_geo_with_http_info(account_id, override_site_regions_by_geo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: Numeric identifier of the account to operate on.<br/>If not specified, operation will be performed on the account identified by the authentication parameters. (required)
        :param bool override_site_regions_by_geo: A boolean parameter. If it is set to \"true\", the data storage region for each new site will be based on the geolocation of the origin server. (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'override_site_regions_by_geo']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_override_site_regions_by_geo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_override_site_regions_by_geo`")  # noqa: E501
        # verify the required parameter 'override_site_regions_by_geo' is set
        if ('override_site_regions_by_geo' not in params or
                params['override_site_regions_by_geo'] is None):
            raise ValueError("Missing the required parameter `override_site_regions_by_geo` when calling `set_override_site_regions_by_geo`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account_id' in params:
            query_params.append(('account_id', params['account_id']))  # noqa: E501
        if 'override_site_regions_by_geo' in params:
            query_params.append(('override_site_regions_by_geo', params['override_site_regions_by_geo']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/data-privacy/override-by-geo', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_priority(self, rule_id, priority, **kwargs):  # noqa: E501
        """Set rule priority  # noqa: E501

        Use this operation to change delivery rule's priority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_priority(rule_id, priority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule ID (required)
        :param int priority: New priority for the selected rule (required)
        :return: SetPriorityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_priority_with_http_info(rule_id, priority, **kwargs)  # noqa: E501
        else:
            (data) = self.set_priority_with_http_info(rule_id, priority, **kwargs)  # noqa: E501
            return data

    def set_priority_with_http_info(self, rule_id, priority, **kwargs):  # noqa: E501
        """Set rule priority  # noqa: E501

        Use this operation to change delivery rule's priority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_priority_with_http_info(rule_id, priority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int rule_id: Rule ID (required)
        :param int priority: New priority for the selected rule (required)
        :return: SetPriorityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'priority']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_priority" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `set_priority`")  # noqa: E501
        # verify the required parameter 'priority' is set
        if ('priority' not in params or
                params['priority'] is None):
            raise ValueError("Missing the required parameter `priority` when calling `set_priority`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'rule_id' in params:
            query_params.append(('rule_id', params['rule_id']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/incapRules/priority/set', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SetPriorityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_secure_resources_mode(self, site_id, secured_resources_mode, **kwargs):  # noqa: E501
        """Modify secure resources mode  # noqa: E501

        Use this operation to modify the Secure Resources mode for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_secure_resources_mode(site_id, secured_resources_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str secured_resources_mode: <b>do_not_cache</b> - Do not cache HTTPS resources<br/><b>defaults</b> - Use default HTTPS caching. Do not cache HTML pages<br/><b>defaults_with_html</b> - Use default HTTPS caching. Also cache HTML pages<br/><b>general</b> - Cache HTTPS according to general caching settings (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_secure_resources_mode_with_http_info(site_id, secured_resources_mode, **kwargs)  # noqa: E501
        else:
            (data) = self.set_secure_resources_mode_with_http_info(site_id, secured_resources_mode, **kwargs)  # noqa: E501
            return data

    def set_secure_resources_mode_with_http_info(self, site_id, secured_resources_mode, **kwargs):  # noqa: E501
        """Modify secure resources mode  # noqa: E501

        Use this operation to modify the Secure Resources mode for a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_secure_resources_mode_with_http_info(site_id, secured_resources_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str secured_resources_mode: <b>do_not_cache</b> - Do not cache HTTPS resources<br/><b>defaults</b> - Use default HTTPS caching. Do not cache HTML pages<br/><b>defaults_with_html</b> - Use default HTTPS caching. Also cache HTML pages<br/><b>general</b> - Cache HTTPS according to general caching settings (required)
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'secured_resources_mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_secure_resources_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `set_secure_resources_mode`")  # noqa: E501
        # verify the required parameter 'secured_resources_mode' is set
        if ('secured_resources_mode' not in params or
                params['secured_resources_mode'] is None):
            raise ValueError("Missing the required parameter `secured_resources_mode` when calling `set_secure_resources_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'secured_resources_mode' in params:
            query_params.append(('secured_resources_mode', params['secured_resources_mode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/performance/secure-resources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def site_status(self, site_id, **kwargs):  # noqa: E501
        """Get site status  # noqa: E501

        Use this operation to get the status of a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.site_status(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str tests: List of tests to run on site before returning its status.<br/>A comma separated list of one of: domain_validation, services, dns<br/>Values for the stats parameters:<br/><ul><li><b>domain_validation</b> Runs the domain validation test on the specified site. This test will check for HTML meta tag or DNS records, according to the selected domain validation method.</li><li><b>services</b> Runs the services test on the specified site. This test will check the availability of HTTP and HTTPS connections on the site.</li><li><b>dns</b> Runs the DNS test on the specified site. This test will check whether the site owner performed the DNS changes required in order to protect the site.</li></ul>
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.site_status_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.site_status_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def site_status_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Get site status  # noqa: E501

        Use this operation to get the status of a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.site_status_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_id: Numeric identifier of the site to operate on (required)
        :param str tests: List of tests to run on site before returning its status.<br/>A comma separated list of one of: domain_validation, services, dns<br/>Values for the stats parameters:<br/><ul><li><b>domain_validation</b> Runs the domain validation test on the specified site. This test will check for HTML meta tag or DNS records, according to the selected domain validation method.</li><li><b>services</b> Runs the services test on the specified site. This test will check the availability of HTTP and HTTPS connections on the site.</li><li><b>dns</b> Runs the DNS test on the specified site. This test will check whether the site owner performed the DNS changes required in order to protect the site.</li></ul>
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id', 'tests']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method site_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `site_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'tests' in params:
            query_params.append(('tests', params['tests']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tls_configuration(self, body, ext_site_id, **kwargs):  # noqa: E501
        """Update website TLS configuration  # noqa: E501

        Update the TLS configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tls_configuration(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TLSConfigurationDto body: JSON body. Schema is identical or semi identical to the response. (required)
        :param int ext_site_id: The Imperva ID of the website to operate on. (required)
        :return: TLSConfigurationDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_tls_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_tls_configuration_with_http_info(body, ext_site_id, **kwargs)  # noqa: E501
            return data

    def update_tls_configuration_with_http_info(self, body, ext_site_id, **kwargs):  # noqa: E501
        """Update website TLS configuration  # noqa: E501

        Update the TLS configuration for a given website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tls_configuration_with_http_info(body, ext_site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TLSConfigurationDto body: JSON body. Schema is identical or semi identical to the response. (required)
        :param int ext_site_id: The Imperva ID of the website to operate on. (required)
        :return: TLSConfigurationDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ext_site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tls_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_tls_configuration`")  # noqa: E501
        # verify the required parameter 'ext_site_id' is set
        if ('ext_site_id' not in params or
                params['ext_site_id'] is None):
            raise ValueError("Missing the required parameter `ext_site_id` when calling `update_tls_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ext_site_id' in params:
            path_params['extSiteId'] = params['ext_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v3/sites/{extSiteId}/settings/TLSConfiguration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TLSConfigurationDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_custom_certificate(self, certificate, private_key, **kwargs):  # noqa: E501
        """Upload custom certificate  # noqa: E501

        Use this operation to upload a custom certificate for your site. The following SSL certificate file formats are supported: PFX, PEM, CER.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_custom_certificate(certificate, private_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str certificate: The certificate file in base64 format (required)
        :param str private_key: The private key of the certificate in base64 format. Optional in case of PFX certificate file format (required)
        :param int site_id: Numeric identifier of the site to operate on
        :param str passphrase: The passphrase used to protect your SSL certificate 
        :param str auth_type: The authentication type of the certificate (RSA or ECC). Optional. If not provided, then RSA will be assume 
        :param str input_hash: optional parameter. usually a hash representation for the concatenation of all inputs
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_custom_certificate_with_http_info(certificate, private_key, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_custom_certificate_with_http_info(certificate, private_key, **kwargs)  # noqa: E501
            return data

    def upload_custom_certificate_with_http_info(self, certificate, private_key, **kwargs):  # noqa: E501
        """Upload custom certificate  # noqa: E501

        Use this operation to upload a custom certificate for your site. The following SSL certificate file formats are supported: PFX, PEM, CER.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_custom_certificate_with_http_info(certificate, private_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str certificate: The certificate file in base64 format (required)
        :param str private_key: The private key of the certificate in base64 format. Optional in case of PFX certificate file format (required)
        :param int site_id: Numeric identifier of the site to operate on
        :param str passphrase: The passphrase used to protect your SSL certificate 
        :param str auth_type: The authentication type of the certificate (RSA or ECC). Optional. If not provided, then RSA will be assume 
        :param str input_hash: optional parameter. usually a hash representation for the concatenation of all inputs
        :return: ApiResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['certificate', 'private_key', 'site_id', 'passphrase', 'auth_type', 'input_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_custom_certificate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'certificate' is set
        if ('certificate' not in params or
                params['certificate'] is None):
            raise ValueError("Missing the required parameter `certificate` when calling `upload_custom_certificate`")  # noqa: E501
        # verify the required parameter 'private_key' is set
        if ('private_key' not in params or
                params['private_key'] is None):
            raise ValueError("Missing the required parameter `private_key` when calling `upload_custom_certificate`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'site_id' in params:
            query_params.append(('site_id', params['site_id']))  # noqa: E501
        if 'certificate' in params:
            query_params.append(('certificate', params['certificate']))  # noqa: E501
        if 'private_key' in params:
            query_params.append(('private_key', params['private_key']))  # noqa: E501
        if 'passphrase' in params:
            query_params.append(('passphrase', params['passphrase']))  # noqa: E501
        if 'auth_type' in params:
            query_params.append(('auth_type', params['auth_type']))  # noqa: E501
        if 'input_hash' in params:
            query_params.append(('input_hash', params['input_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/prov/v1/sites/customCertificate/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
