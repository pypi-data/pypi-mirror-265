# coding: utf-8

"""
    Account Takeover Protection API

    This is the API documentation for Imperva Account Takeover Protection. ATO detects and mitigates account takeover attempts, protecting your web applications against volumetric and low and slow ATO attacks. For the full feature documentation, see https://docs.imperva.com/bundle/account-takeover.  # noqa: E501

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class LoginEvent(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'ip': 'str',
        'risk': 'str',
        'time': 'int',
        'user': 'str',
        'type': 'str',
        'path': 'str',
        'referrer': 'str',
        'endpoint_id': 'str'
    }

    attribute_map = {
        'ip': 'ip',
        'risk': 'risk',
        'time': 'time',
        'user': 'user',
        'type': 'type',
        'path': 'path',
        'referrer': 'referrer',
        'endpoint_id': 'endpointId'
    }

    def __init__(self, ip=None, risk=None, time=None, user=None, type=None, path=None, referrer=None, endpoint_id=None):  # noqa: E501
        """LoginEvent - a model defined in Swagger"""  # noqa: E501
        self._ip = None
        self._risk = None
        self._time = None
        self._user = None
        self._type = None
        self._path = None
        self._referrer = None
        self._endpoint_id = None
        self.discriminator = None
        if ip is not None:
            self.ip = ip
        if risk is not None:
            self.risk = risk
        if time is not None:
            self.time = time
        if user is not None:
            self.user = user
        if type is not None:
            self.type = type
        if path is not None:
            self.path = path
        if referrer is not None:
            self.referrer = referrer
        if endpoint_id is not None:
            self.endpoint_id = endpoint_id

    @property
    def ip(self):
        """Gets the ip of this LoginEvent.  # noqa: E501

        IP address from which the login attempt was made. This will be either an IPv4 (e.g. 50.3.183.2) or normalized IPv6 representation (e.g. 2001:db8:0:0:1:0:0:1).  # noqa: E501

        :return: The ip of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._ip

    @ip.setter
    def ip(self, ip):
        """Sets the ip of this LoginEvent.

        IP address from which the login attempt was made. This will be either an IPv4 (e.g. 50.3.183.2) or normalized IPv6 representation (e.g. 2001:db8:0:0:1:0:0:1).  # noqa: E501

        :param ip: The ip of this LoginEvent.  # noqa: E501
        :type: str
        """

        self._ip = ip

    @property
    def risk(self):
        """Gets the risk of this LoginEvent.  # noqa: E501

        Probability that this event was part of an attack, as computed post-factum.  # noqa: E501

        :return: The risk of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._risk

    @risk.setter
    def risk(self, risk):
        """Sets the risk of this LoginEvent.

        Probability that this event was part of an attack, as computed post-factum.  # noqa: E501

        :param risk: The risk of this LoginEvent.  # noqa: E501
        :type: str
        """
        allowed_values = ["LOW", "MEDIUM", "HIGH"]  # noqa: E501
        if risk not in allowed_values:
            raise ValueError(
                "Invalid value for `risk` ({0}), must be one of {1}"  # noqa: E501
                .format(risk, allowed_values)
            )

        self._risk = risk

    @property
    def time(self):
        """Gets the time of this LoginEvent.  # noqa: E501

        Timestamp, in UNIX Epoch milliseconds, of the login event.  # noqa: E501

        :return: The time of this LoginEvent.  # noqa: E501
        :rtype: int
        """
        return self._time

    @time.setter
    def time(self, time):
        """Sets the time of this LoginEvent.

        Timestamp, in UNIX Epoch milliseconds, of the login event.  # noqa: E501

        :param time: The time of this LoginEvent.  # noqa: E501
        :type: int
        """

        self._time = time

    @property
    def user(self):
        """Gets the user of this LoginEvent.  # noqa: E501

        The username, if the PII password was specified, or a hashed/encrypted form of the username if the PII password was not specified or does not match.  # noqa: E501

        :return: The user of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._user

    @user.setter
    def user(self, user):
        """Sets the user of this LoginEvent.

        The username, if the PII password was specified, or a hashed/encrypted form of the username if the PII password was not specified or does not match.  # noqa: E501

        :param user: The user of this LoginEvent.  # noqa: E501
        :type: str
        """

        self._user = user

    @property
    def type(self):
        """Gets the type of this LoginEvent.  # noqa: E501

        Reason for the presence of the login event in the report.  # noqa: E501

        :return: The type of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this LoginEvent.

        Reason for the presence of the login event in the report.  # noqa: E501

        :param type: The type of this LoginEvent.  # noqa: E501
        :type: str
        """
        allowed_values = ["LEAKED", "COMPROMISED"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def path(self):
        """Gets the path of this LoginEvent.  # noqa: E501

        The login request endpoint path.  # noqa: E501

        :return: The path of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._path

    @path.setter
    def path(self, path):
        """Sets the path of this LoginEvent.

        The login request endpoint path.  # noqa: E501

        :param path: The path of this LoginEvent.  # noqa: E501
        :type: str
        """

        self._path = path

    @property
    def referrer(self):
        """Gets the referrer of this LoginEvent.  # noqa: E501

        The URL of the referring page.  # noqa: E501

        :return: The referrer of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._referrer

    @referrer.setter
    def referrer(self, referrer):
        """Sets the referrer of this LoginEvent.

        The URL of the referring page.  # noqa: E501

        :param referrer: The referrer of this LoginEvent.  # noqa: E501
        :type: str
        """

        self._referrer = referrer

    @property
    def endpoint_id(self):
        """Gets the endpoint_id of this LoginEvent.  # noqa: E501

        The endpoint ID associated with the login request.  # noqa: E501

        :return: The endpoint_id of this LoginEvent.  # noqa: E501
        :rtype: str
        """
        return self._endpoint_id

    @endpoint_id.setter
    def endpoint_id(self, endpoint_id):
        """Sets the endpoint_id of this LoginEvent.

        The endpoint ID associated with the login request.  # noqa: E501

        :param endpoint_id: The endpoint_id of this LoginEvent.  # noqa: E501
        :type: str
        """

        self._endpoint_id = endpoint_id

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LoginEvent, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LoginEvent):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
