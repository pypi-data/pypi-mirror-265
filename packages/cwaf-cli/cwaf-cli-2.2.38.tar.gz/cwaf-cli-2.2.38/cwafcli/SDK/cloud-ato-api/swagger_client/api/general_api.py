# coding: utf-8

"""
    Account Takeover Protection API

    This is the API documentation for Imperva Account Takeover Protection. ATO detects and mitigates account takeover attempts, protecting your web applications against volumetric and low and slow ATO attacks. For the full feature documentation, see https://docs.imperva.com/bundle/account-takeover.  # noqa: E501

    OpenAPI spec version: 2.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class GeneralApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_to_allow_list(self, body, site_id, **kwargs):  # noqa: E501
        """Update the allowlist for a specific site  # noqa: E501

        Update the list of IPs and subnets excluded from traffic mitigation by ATO Protection. All traffic from these IPs will not be mitigated. The input should be a comma separated JSON list containing the IPs to add to the site allowlist. Each allowed IP object can have a mask property to be applied to that IP and allow that whole subnet. For example: [{\"ip\":\"192.20.1.1\",\"desc\":\"My own IP\"},{\"ip\":\"15.5.0.0\",\"mask\":\"16\",\"desc\":\"Office subnet\"},{\"ip\":\"20.1.1.0\",\"mask\":\"24\",\"desc\":\"Home subnet\"}]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_allow_list(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: List of IPs/subnets (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_to_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_to_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def add_to_allow_list_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Update the allowlist for a specific site  # noqa: E501

        Update the list of IPs and subnets excluded from traffic mitigation by ATO Protection. All traffic from these IPs will not be mitigated. The input should be a comma separated JSON list containing the IPs to add to the site allowlist. Each allowed IP object can have a mask property to be applied to that IP and allow that whole subnet. For example: [{\"ip\":\"192.20.1.1\",\"desc\":\"My own IP\"},{\"ip\":\"15.5.0.0\",\"mask\":\"16\",\"desc\":\"Office subnet\"},{\"ip\":\"20.1.1.0\",\"mask\":\"24\",\"desc\":\"Home subnet\"}]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_allow_list_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: List of IPs/subnets (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_to_allow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_to_allow_list`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `add_to_allow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/allowlist', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allow_list(self, site_id, **kwargs):  # noqa: E501
        """Retrieve the allowlist for a specific site  # noqa: E501

        Retrieve the list of IPs and subnets excluded from traffic mitigation by ATO Protection. All traffic from these IPs will not be mitigated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allow_list(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: The Imperva ID of the website (required)
        :return: AllowlistIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allow_list_with_http_info(site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allow_list_with_http_info(site_id, **kwargs)  # noqa: E501
            return data

    def get_allow_list_with_http_info(self, site_id, **kwargs):  # noqa: E501
        """Retrieve the allowlist for a specific site  # noqa: E501

        Retrieve the list of IPs and subnets excluded from traffic mitigation by ATO Protection. All traffic from these IPs will not be mitigated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allow_list_with_http_info(site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int site_id: The Imperva ID of the website (required)
        :return: AllowlistIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_allow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/allowlist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllowlistIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_leaked_report(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the leaked users login report  # noqa: E501

        Retrieve the list of successful login events that used publicly available leaked credentials. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_leaked_report(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_leaked_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_leaked_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def get_leaked_report_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the leaked users login report  # noqa: E501

        Retrieve the list of successful login events that used publicly available leaked credentials. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_leaked_report_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id', 'caid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_leaked_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_leaked_report`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_leaked_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []
        if 'caid' in params:
            query_params.append(('caid', params['caid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/report/evidence/leaked', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mitigated_report(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the mitigated (CAPTCHA, BLOCK) users login report  # noqa: E501

        Retrieve the list of mitigated (CAPTCHA, BLOCK) login events. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mitigated_report(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mitigated_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mitigated_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def get_mitigated_report_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the mitigated (CAPTCHA, BLOCK) users login report  # noqa: E501

        Retrieve the list of mitigated (CAPTCHA, BLOCK) login events. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mitigated_report_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id', 'caid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mitigated_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_mitigated_report`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_mitigated_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []
        if 'caid' in params:
            query_params.append(('caid', params['caid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/report/evidence/mitigated', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_successful_and_suspicious_report(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the compromised users login report  # noqa: E501

        Retrieve the list of successful login events that had a non-zero probability of being an attack. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_successful_and_suspicious_report(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_successful_and_suspicious_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_successful_and_suspicious_report_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def get_successful_and_suspicious_report_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Retrieve the compromised users login report  # noqa: E501

        Retrieve the list of successful login events that had a non-zero probability of being an attack. If the API key used is for a parent account, and the website belongs to a sub account, the caid of the sub account must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_successful_and_suspicious_report_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportRequest body: Specify event selection range, PII password and endpoint ID (required)
        :param int site_id: The Imperva ID of the website (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: LoginEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id', 'caid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_successful_and_suspicious_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_successful_and_suspicious_report`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `get_successful_and_suspicious_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []
        if 'caid' in params:
            query_params.append(('caid', params['caid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/report/evidence/suspicious/successful', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginEvent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_from_allow_list(self, body, site_id, **kwargs):  # noqa: E501
        """Remove IPs from the allowlist for a specific site  # noqa: E501

        Remove the list of IPs and subnets from the current allowlist configuration of the site. Matching the IPs and subnets will be done by comparing the 'ip' and 'mask' fields of the entries. For example: [{\"ip\":\"192.20.1.1\"},{\"ip\":\"15.5.0.0\",\"mask\":\"16\"}]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_from_allow_list(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: List of IPs/subnets to remove (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_from_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_from_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def remove_from_allow_list_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Remove IPs from the allowlist for a specific site  # noqa: E501

        Remove the list of IPs and subnets from the current allowlist configuration of the site. Matching the IPs and subnets will be done by comparing the 'ip' and 'mask' fields of the entries. For example: [{\"ip\":\"192.20.1.1\"},{\"ip\":\"15.5.0.0\",\"mask\":\"16\"}]  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_from_allow_list_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: List of IPs/subnets to remove (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_from_allow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_from_allow_list`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `remove_from_allow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/allowlist', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_risk(self, body, site_id, **kwargs):  # noqa: E501
        """Reset the risk level of IPs for a specific site  # noqa: E501

        Resets the risk level assigned to an IP address by Account Takeover Protection. Risk level indicates the severity of risk.  If there is continued suspicious activity from an IP, the risk level will escalate again afterwards.  For example: [\"192.20.1.1\",\"15.5.0.0\"]  For sites with ATO fingerprint enabled, not all devices will have their risk reset. Priority will be given to devices that were most recently active.  IPV4 and IPV6 values are accepted but IP ranges will be rejected  There is a limit of 10 IPs per request    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_risk(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: List of IPs. The input must be a comma separated list of IP addresses in JSON format. It can take up to one minute to fully process the request after it has been sent. (required)
        :param int site_id: (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_risk_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_risk_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def reset_risk_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Reset the risk level of IPs for a specific site  # noqa: E501

        Resets the risk level assigned to an IP address by Account Takeover Protection. Risk level indicates the severity of risk.  If there is continued suspicious activity from an IP, the risk level will escalate again afterwards.  For example: [\"192.20.1.1\",\"15.5.0.0\"]  For sites with ATO fingerprint enabled, not all devices will have their risk reset. Priority will be given to devices that were most recently active.  IPV4 and IPV6 values are accepted but IP ranges will be rejected  There is a limit of 10 IPs per request    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_risk_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: List of IPs. The input must be a comma separated list of IP addresses in JSON format. It can take up to one minute to fully process the request after it has been sent. (required)
        :param int site_id: (required)
        :param int caid: The Imperva account ID. By default, the API operates on account (A) associated with the API credentials used for authentication. To operate on a different account (an account under the account (A)), specify the account ID.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id', 'caid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_risk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `reset_risk`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `reset_risk`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []
        if 'caid' in params:
            query_params.append(('caid', params['caid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/reset-risk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_allow_list(self, body, site_id, **kwargs):  # noqa: E501
        """Overwrite the allowlist for a specific site  # noqa: E501

        Overwrite the list of IPs and subnets excluded from traffic mitigation by ATO Protection. THIS CALL WILL REPLACE THE EXISTING LIST. All traffic from these IPs will not be mitigated. The input should be a comma separated JSON list containing all the IPs in the allowlist for the site. Each allowed IP object can have a mask property to be applied to that IP and allow that whole subnet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_allow_list(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: Complete list of IPs/subnets (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_allow_list_with_http_info(body, site_id, **kwargs)  # noqa: E501
            return data

    def set_allow_list_with_http_info(self, body, site_id, **kwargs):  # noqa: E501
        """Overwrite the allowlist for a specific site  # noqa: E501

        Overwrite the list of IPs and subnets excluded from traffic mitigation by ATO Protection. THIS CALL WILL REPLACE THE EXISTING LIST. All traffic from these IPs will not be mitigated. The input should be a comma separated JSON list containing all the IPs in the allowlist for the site. Each allowed IP object can have a mask property to be applied to that IP and allow that whole subnet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_allow_list_with_http_info(body, site_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AllowlistIp] body: Complete list of IPs/subnets (required)
        :param int site_id: The Imperva ID of the website (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_allow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_allow_list`")  # noqa: E501
        # verify the required parameter 'site_id' is set
        if ('site_id' not in params or
                params['site_id'] is None):
            raise ValueError("Missing the required parameter `site_id` when calling `set_allow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_id' in params:
            path_params['siteId'] = params['site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_id', 'api_key']  # noqa: E501

        return self.api_client.call_api(
            '/v2/sites/{siteId}/allowlist', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
