import pyarrow as pa
from _typeshed import Incomplete
from typing import Dict, Iterator, List, Tuple
from vinyl.infra.pg_proxy.core import BVType as BVType, Connection as Connection, QueryResult as QueryResult, Session as Session

logger: Incomplete

def to_bvtype(t: pa.DataType) -> BVType: ...

class RecordBatchIterator(Iterator[list[str | None]]):
    rbr: Incomplete
    def __init__(self, rbr: pa.RecordBatchReader) -> None: ...
    rb: Incomplete
    i: int
    def __iter__(self): ...
    def __next__(self) -> List: ...

class DuckDBQueryResult(QueryResult):
    rbr: Incomplete
    bvtypes: Incomplete
    def __init__(self, rbr: pa.RecordBatchReader | None = None, status: str | None = None) -> None: ...
    def has_results(self) -> bool: ...
    def column_count(self): ...
    def column(self, index: int) -> Tuple[str, BVType]: ...
    def rows(self) -> Iterator[List]: ...
    def status(self) -> str: ...

class DuckDBSession(Session):
    in_txn: bool
    def __init__(self, cursor) -> None: ...
    def cursor(self): ...
    def close(self) -> None: ...
    config_params: Incomplete
    def refresh_config(self) -> None: ...
    def load_df_function(self, table: str): ...
    def rewrite_sql(self, sql: str) -> str:
        """Some minimalist SQL rewrites, inspired by postlite, to make DBeaver less unhappy."""
    def in_transaction(self) -> bool: ...
    def execute_sql(self, sql: str, params: Incomplete | None = None) -> QueryResult: ...

class DuckDBConnection(Connection):
    db: Incomplete
    def __init__(self, db) -> None: ...
    def parameters(self) -> Dict[str, str]: ...
    def new_session(self) -> Session: ...
