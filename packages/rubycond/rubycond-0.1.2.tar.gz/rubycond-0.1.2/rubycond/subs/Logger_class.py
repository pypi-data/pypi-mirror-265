# -*- coding: utf-8 -*-
"""

Logger_class

This file is part of Rubycond

Rubycond: Pressure by Ruby Luminescence (PRL) software to determine pressure in diamond anvil cell experiments.

Version 0.1.0
Release 240222

Author:

Yiuri Garino:
     yiuri.garino@cnrs.fr   

Copyright (c) 2023-2024 Yiuri Garino

Download: https://github.com/CelluleProjet/Rubycond

License: GPLv3

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

"""

def reset():
    import sys
    
    if hasattr(sys, 'ps1'):
        
        #clean Console and Memory
        from IPython import get_ipython
        get_ipython().run_line_magic('clear','/')
        get_ipython().run_line_magic('reset','-sf')
        print("Running interactively")
        print()
        terminal = False
    else:
        print("Running in terminal")
        print()
        terminal = True

if __name__ == '__main__':
    reset()

import configparser as cp
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
import threading
from datetime import datetime
from time import sleep, time
import csv
from pathlib import Path

class Logger:
    """
    
    /\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\

    "Logger" example class, version 240102
    
    Print list of all variables names:

    =>    name.list_var()
    
    Print list aff all functions
    
    =>    name.list_func()
    
    Specific function help:

    =>    help(name.load)
    
    This doc : print(a)
    Longer help : dir(name)
    Much longer : help(name)
    
    Parameters
    ----------
    
    debug
        if True print messages on the prompt, default is False
    
    logger_time
        used to evaluate the elapsed time beetween every log, default is 0.1
        the logger udate the log file according the bigger value of logger_time & logger_sleep
    
    logger_sleep
        sleep time used in every loop, default is 1
        the logger udate the log file according the bigger value of logger_time & logger_sleep
        
    logger_filename
        filename used for log, it can be change during logging
        is not given will be generated by filename_date_format method
    
    logger_folder
        folder used to save log files, default is current working directory Path.cwd()
        
    logger_session_filenames
        list of the filenames used during the session
    
    logger_column_delimiter
        column delimiter used in the log file, default = tab '\t'
       
    
    Methods
    ----------
    
    logger_start
        start the logger using filename = logger_filename
        logger_filename can be changed at any moment without stopping the logger
    
    logger_stop
        stop the logger
    
    logger_is_running
        check if the logger is running
    
    filename_date_format
        return the filename format if the filename is not given
        %y%m%d_%H%M%S.txt, i.e. '240123_140528.txt'
    
    read_log_file
        Read a saved log file, using logger_column_delimiter as column delimiter if delimiter is not defined
        
    /\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\
        
    """
    def __init__(self, parameters = [],  methods = [], debug = False):
        self.logger_methods = methods
        self.logger_parameters = parameters
        self.debug = debug
        self.logger_column_delimiter = '\t'
        self.logger_time = .1 
        self.logger_sleep = 1
        self.logger_filename = None
        self.logger_folder = Path.cwd() #Path(r'C:/tmp') #
        self.logger_session_filenames = []
        self._running = False
        self._stop_thread = threading.Event()
        self._used_filename = None
        if self.debug: print(self.__doc__)
    
    @property
    def logger_filename(self):
        return self._logger_filename

    @logger_filename.setter
    def logger_filename(self, value):
        self._logger_filename = Path(str(value)).with_suffix('.txt')
    
    @property
    def logger_folder(self):
        return self._logger_folder
    
    @logger_folder.setter 
    def logger_folder(self, value):
        try:
            if value.is_dir():
                self._logger_folder = value
            else:
                print('Error dir not valid')
        except Exception as e:
            if self.debug:
                print(e)
            else:
                print('Input Path folder or use logger_folder_set')
                    
    def logger_folder_set(self):
        ''' 
        
        use this method to change logger_folder
        this method wiill ask as input the folder path using windows syntax (file explorer)
        
        '''
        path = input(r'''Input your path
c & p from file explorer
''')
        path = Path(path)
        if path.is_dir():
            print('Folder exists')
            self.logger_folder = path
        else:
            print('Error or Folder not exists')
            
    def filename_date_format(self):
        """
        
        Default filename format, %y%m%d_%H%M%S, i.e. :
        '240123_140528'
        
        """
        now = datetime.now()
        #now.strftime("%A_%d_%B_%Y_%H_%M_%S") #'Thursday_29_June_2023_16_13_14'
        return Path(now.strftime("%y%m%d_%H%M%S")) #WindowsPath('240123_132633.txt')

    def logger_start(self, filename = None):
        """
        
        Start the logger in a thread
        
        """
        try:
            status = self.thread.is_alive()
        except:
            status = False
            
        if status != True:
            self.thread = threading.Thread(target=self._logger_thread, args=(self._stop_thread, filename), daemon=True)
            self.thread.start()
        else:
            print('Logger already running')
            
    
    def logger_stop(self):
        """
        
        Stop the logger in a thread
        
        """
        self._stop_thread.set()
        
    def print_time(self, Message = 'Now = '):
        """
        
        Return time as Message + time, i.e. :
        'Now = Tuesday 23 January 2024 14:22:37'
        
        """
        now = datetime.now()
        current_time = now.strftime("%A %d %B %Y %H:%M:%S")
        #print(Message + current_time)
        return Message + current_time
    
    def logger_is_running(self):
        """
        
        Check if the logger is running
        
        """ 
        try:
            status = self.thread.is_alive()
        except:
            status = False 
        if self.debug: print(f"Logger is running = {status}")
        return status
    
    
    def first_line(self):
        #columns names
        columns = ['pc_unix_time',
        'integration_time',
        'accumulation',
        'R1_center',
        'R1_gamma',
        'R1_fwhm',
        'R2_center',
        'R2_gamma',
        'R2_fwhm',
        'fit_x_min',
        'fit_x_max',
        'log_pressure_gauge',
        'log_temperature_gauge',
        'log_pressure',
        'log_temperature\n',
        ]
        _ = ''
        for i in columns:
            _+= self.logger_column_delimiter + i
        return '#filename' + _
        
        
        
    def _logger_thread(self, event, filename ):
        if filename is None:
            self.logger_filename = self.filename_date_format().with_suffix('.txt')
        else:
            try:
                self.logger_filename = Path(str(filename)).with_suffix('.txt')
            except:
                self.logger_filename = self.filename_date_format().with_suffix('.txt')
                print('Error in filename, using default')
                print(self.logger_filename)
            
        if self.debug: print(self.logger_filename)
        
        if not (self.logger_folder / self.logger_filename).is_file():
            #if file doesn't exist write first line
            with open(self.logger_folder / self.logger_filename, 'a') as f:
                f.write(self.first_line())
        
        running = True
        time_ref = datetime.now()
        while running:
            sleep(self.logger_sleep)
            if event.is_set():
                running = False

            else:
                elapsed_time = (datetime.now() - time_ref).total_seconds()
                if elapsed_time > self.logger_time:
                    time_ref = datetime.now()
                    div = self.logger_column_delimiter
                    try:
                        #Create log line and add it to log file
                        _filename = self.filename_date_format()
                        log = ''
                        log+= str(_filename)
                        # now = datetime.now()
                        # log+= now.strftime("%y%m%d_%H%M%S_%f")
                        log+= div + str(time())
                        
                        parameters = self.logger_parameters()
                        for var in parameters:
                            log+= div + str(var)
                        log+= '\n'
                        if self.debug: print(log)
                        _full_filename = self.logger_folder / self.logger_filename
                        with open(_full_filename, 'a') as f:
                            f.write(log)
                        
                        #Start logger_methods
                        for func in self.logger_methods:
                            func(self.logger_folder / _filename)
                        
                        if _full_filename != self._used_filename:
                            #New filename, add it to logger_session_filenames
                            self.logger_session_filenames.append(str(_full_filename.resolve()).replace('\\','/'))
                            self._used_filename = _full_filename
                    except Exception as e:
                        running = False
                        event.clear()
                        print(e)
                        
        if self.debug: print('quitting')
        event.clear()
    
    def save_logger_session_filenames(self):
       
        _f = self.logger_folder / self.filename_date_format() 
        _full_filename = _f.with_name(_f.stem + '_session_filenames.txt')
        with open(_full_filename, 'a') as f:
            for i in self.logger_session_filenames:
                f.write(i + '\n')
            
    def read_log_file(self, filename, delimiter = None):
        """
        
        Read a saved log file, using logger_column_delimiter as column delimiter if delimiter is not defined
        
        """
        if delimiter is None:
            delimiter = self.logger_column_delimiter
        return np.genfromtxt(filename, dtype='str', delimiter = delimiter) 
    
    def __str__(self):
        #what is returned by print
        return str(self.__doc__)
    
    def list_var(self):
        """
        
        Print the list of all the variables in the Logger class
        
        """
        members = [attr for attr in dir(self) if not callable(getattr(self, attr)) and not attr.startswith("_")]
        print(members) 
        
    def list_func(self):
        """
        
        Print the list of all the functions in the Logger class
        
        """
        members = [func for func in dir(self) if callable(getattr(self, func)) and not func.startswith("_")]
        print(members) 
