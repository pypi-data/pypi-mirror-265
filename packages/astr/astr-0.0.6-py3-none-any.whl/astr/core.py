# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['DOT', 'NIL', 'GET', 'ATTR', 'BASES', 'CHECK', 'GUARD', 'RETHAS', 'RETSELF', 'DEFAULT', 'CHECKOBJ', 'GUARDOBJ',
           'NAMESPACE', 'CLASSVARS', 'ASSIGNED', 'T', 'O', 'P', 'GuardLike', 'iscall', 'isnone', 'notnone', 'isiter',
           'isstr', 'allstrs', 'istuple', 'insattr', 'astrmeta', 'astr', 'attr', 'attrstr']

# %% ../nbs/00_core.ipynb 6
from abc import abstractmethod
from functools import wraps

# %% ../nbs/00_core.ipynb 8
from typing import (
    Any, Self, Type, Union, TypeVar, ParamSpec, 
    TypeAlias, TypeGuard, ClassVar, Callable, Optional, Iterable,
)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
#| export


# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
DOT = '.'
NIL = ''

GET = 'get'
ATTR = 'attr' 

BASES = 'bases' 
CHECK = 'check'
GUARD = 'guard'

RETHAS = 'rethas' 
RETSELF = 'retself'

DEFAULT = 'default'

CHECKOBJ = 'checkobj'
GUARDOBJ = 'guardobj'

NAMESPACE = 'namespace'

__DOC__ = '__doc__' 
__NAME__ = '__name__'
__MODULE__ = '__module__'
__QUALNAME__ = '__qualname__'
__ANNOTATIONS__ = '__annotations__'


CLASSVARS = (ATTR, CHECK, GUARD, CHECKOBJ, GUARDOBJ, RETSELF, DEFAULT)
ASSIGNED = (__MODULE__, __DOC__, __ANNOTATIONS__)

# %% ../nbs/00_core.ipynb 18
T = TypeVar('T')

O = TypeVar('O')

P = ParamSpec('P')

GuardLike: TypeAlias = Callable[[O], TypeGuard[T]]
'''TypeAlias for a callable that takes an object of type O and returns a TypeGuard for type T.''';

# %% ../nbs/00_core.ipynb 20
def iscall(x) -> TypeGuard[Callable]:
    '''Check if `x` is `Callable`.'''
    return isinstance(x, Callable)

def isnone(x) -> TypeGuard[None]:
    '''Check if `x` is `None`.'''
    return x is None

def notnone(x) -> TypeGuard[Any]:
    '''Check if `x` is not `None`.'''
    return not isnone(x)

def isiter(x) -> TypeGuard[Iterable]:
    '''Check if `x` is `Iterable`.'''
    return isinstance(x, Iterable)


def isstr(x) -> TypeGuard[str]:
    '''Check if `x` is `str`.'''
    return isinstance(x, str)

def allstrs(x) -> TypeGuard[tuple[str, ...]]:
    '''Check if `x` is an iterable of `str`s.'''
    return isinstance(x, Iterable) and all(isstr(a) for a in x)

def istuple(x) -> TypeGuard[tuple]:
    '''Check if `x` is a `tuple`'''
    return isinstance(x, tuple)

# %% ../nbs/00_core.ipynb 22
def insattr(
    obj:      object, 
    attr:     str, 
    default:  Any = None,
    check:    bool = True,
    guard:    Optional[GuardLike] = notnone,
    checkobj: Optional[GuardLike] = None, 
    guardobj: Optional[GuardLike] = notnone, 
    rethas:   bool = False,
    retself:  bool = False,
    __value:  Any = None,
) -> Union[Any, bool, object]:
    '''Get an attribute from an object and check its type.
    
    Parameters
    ----------
    obj : object
        The object to get the attribute from.
        
    attr : str
        The name of the attribute to get.
        
    default : Any, optional
        The default value to return if the attribute is not found, by default None.
        
    check : bool, default: True
        Whether to check the type of the attribute, by default True.
        
    guard : Optional[GuardLike], default: `notnone`
        The guard to check the type of the retrieved attribute, by default `notnone`.
        
    checkobj : Optional[GuardLike], default: None
        The guard to check the type of the object, by default None.
        
    guardobj : Optional[GuardLike], default: `notnone`
        The guard to check the type of the object, by default `notnone`.
        
    rethas : bool, default: False
        Whether to return the boolean result of the typeguard or the attribute, 
        by default False.
        
    retself : bool, default: False
        Whether to return the object if the attribute fails the guard, otherwise
        the default value is returned, by default False.
    '''
    # Step 1: Check if the object is of the correct type
    if (checkobj and iscall(guardobj)) and not guardobj(obj): 
        return default
    
    # Step 2: Try and get the attribute
    try: has = hasattr(obj, attr)
    except: has = False
    
    if not isstr(attr):
        try: attr = getattr(attr, ATTR, attr)
        except: ...
        
    try: val = getattr(obj, attr, default)
    except: val = default
    
    if isnone(val): 
        val = default
    
    if __value is not None: 
        val = __value
    
    if val is None and __value is None:
        try: val = getattr(obj, ATTR, val)
        except: ...
        
    # Step 3: Check if the attribute is of the correct type
    passed = (has and check and iscall(guard)) and guard(val)
    if passed: 
        return has if rethas else val
    
    # Step 4: value failed the guard, check if the boolean
    # i.e. typeguard result should be returned
    if rethas: 
        return has
    
    # Step 5: value failed the guard, check if the object 
    # should be returned
    passed = (check and iscall(guard)) and guardobj(obj)
    if (retself and passed): 
        return obj
    
    return default

# %% ../nbs/00_core.ipynb 24
class astrmeta(type):
    '''A metaclass for attributes to extend instance checks and equality.
    
    A metaclass for dynamically generating and handling attributes with enhanced instance checks, equality, and attribute manipulation.
    This metaclass allows for the creation of attribute-centric classes (`astr` instances) that encapsulate logic for accessing, setting, 
    and checking the presence of specified attributes on objects. It supports creating attribute-specific classes directly or 
    through decoration, enabling flexible and powerful attribute manipulation and introspection.
    
    Attributes
    ----------
    attr : str
        The name of the attribute to get, set, or check on an object.
        
    check : bool
        Indicates whether to check the type of the attribute upon retrieval.
        
    guard : GuardLike, optional
        A callable used as a type guard for the retrieved attribute.
        
    checkobj : bool, optional
        Indicates whether to check the type of the object before attribute manipulation.
        
    guardobj : GuardLike, optional
        A callable used as a type guard for the object before attribute manipulation.
        
    retself : bool
        Determines whether to return the original object if the attribute fails the type guard check.
        
    default : Any
        The default value to return if the attribute is not found or fails the type guard check.
    '''
    
    
    attr: ClassVar[str]
    '''The name of the attribute to get / set / or check if an object has.'''
    
    check: ClassVar[bool] = True
    '''Whether to check the type of the attribute, by default True.'''
    
    guard: ClassVar[Optional[GuardLike]] = notnone
    '''The guard to check the type of the retrieved attribute, by default `notnone`.'''
    
    checkobj: ClassVar[Optional[bool]] = True
    '''The guard to check the type of the object, by default None.'''
    
    guardobj: ClassVar[Optional[GuardLike]] = notnone
    '''The guard to check the type of the object, by default `notnone`.'''
    
    retself: ClassVar[bool] = True
    '''Whether to return the object if the attribute fails the guard, otherwise the default value is returned, by default False.'''
    
    default: ClassVar[Any] = None
    '''The default value to return if the attribute is not found, by default None.'''
    
    clsvars: tuple[str, ...] = CLASSVARS
    '''The tuple of class variable names.'''
    
    def __new__(cls, name: str, bases: tuple = tuple(), dct: dict = dict(), *args: P.args, **kwargs: P.kwargs):
        # new = super().__new__(mcls, name, bases, dct, *args, **kwargs)
        kwargs.setdefault('__args', args)
        new = super().__new__(cls, name, bases, dct)
        new.setvars(**kwargs)
        return new
    
    def __init__(cls, name: str, bases: tuple = tuple(), dct: dict = dict(), *args: P.args, **kwargs: P.kwargs):
        super().__init__(name, bases, dct)
        # NOTE: likely unneeded as it is called in __new__
        cls.setvars(**kwargs)
            
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__(*args, **kwargs)
        # NOTE: likely unneeded as it is called in __new__
        cls.setvars(**kwargs)
        
    @classmethod
    @abstractmethod
    def __guard__(cls, ins: object) -> TypeGuard['astrmeta']:
        '''Checks if the instance `ins` has the attribute `cls.attr`.'''
        return cls.has(cls, ins)
    
    def __instancecheck__(cls, __instance: object) -> bool:
        '''Checks if the instance has the attribute `cls.attr`.
        
        Examples
        --------
        >>> # create the foo attribtue via subclassing
        ... class foo(attr):
        ...    attr = 'foo'
        ...
        ... # create two classes that have a foo attribute
        ... class testa: 
        ...    foo = 1; bar = 2; hi = 'no'; qux = dict(a=2);
        ... 
        ... class testb: 
        ...    foo = None; bar = -10; hello = 'yes'; qux = dict(a=5);
        ... 
        ... # test equality and instance check works via astrmeta __eq__ and __instancecheck__ methods
        ... foo == testa, foo == testb, isinstance(testa, foo), isinstance(testb, foo)
        (True, True, True, True)
        '''
        try: sub = issubclass(__instance, cls)
        except: sub = False
        return cls.__guard__(__instance) or sub
    
    def __eq__(cls, ins: object) -> bool:
        '''Checks if the instance has the attribute `cls.attr`.
        
        Examples
        --------
        >>> # create the foo attribtue via subclassing
        ... class foo(attr):
        ...    attr = 'foo'
        ...
        ... # create two classes that have a foo attribute
        ... class testa: 
        ...    foo = 1; bar = 2; hi = 'no'; qux = dict(a=2);
        ... 
        ... class testb: 
        ...    foo = None; bar = -10; hello = 'yes'; qux = dict(a=5);
        ... 
        ... # test equality and instance check works via attrmeta __eq__ and __instancecheck__ methods
        ... foo == testa, foo == testb, isinstance(testa, foo), isinstance(testb, foo)
        (True, True, True, True)
        '''
        if isinstance(ins, cls): 
            return True
        return super().__eq__(ins)
    
    def __hash__(cls) -> int:
        return super().__hash__()
    
    def getvars(cls, **kwargs: P.kwargs) -> dict:
        '''Returns a dictionary of class variables using class defaults if not found in `kwargs`.'''
        return {a: kwargs.get(a, getattr(cls, a, None)) for a in cls.clsvars}
    
    def setvars(cls, **kwargs: P.kwargs):
        '''Set all class variables using their defaults values if not found in `kwargs`.'''
        for k, v in cls.getvars(**kwargs).items():
            setattr(cls, k, v)
        
        clsattr = getattr(cls, ATTR, NIL)
        clsname = getattr(cls, __NAME__, NIL).lower()
        # no attr but class has a name, use that for the attribute
        if not clsattr and clsname: 
            setattr(cls, ATTR, clsname)
        
        # cls.attr is 'attr' but class has a different name (e.g. subclass)
        if clsattr == ATTR and clsname != clsattr:
            setattr(cls, ATTR, clsname)
        return cls
    
    def __make_astr__(cls, name: str, *args: P.args, attr: Optional[str] = None, **kwargs: P.kwargs): 
        '''Make a new attribute class with the given attribute name.'''
        # class name, bases and dct
        kwargs.setdefault(ATTR, attr or name)
        bases = kwargs.pop(BASES, (cls, ))
        ndict = kwargs.pop(NAMESPACE, {})
        ndict.update(__annotations__ = cls.__annotations__, __module__ = cls.__module__, attr = attr)
        return cls.__class__(name, bases, ndict, *args, **kwargs)
        new.setvars(**kwargs)
        return new
    
    def __make_astrs__(cls, attrs: tuple[str, ...] = tuple(), *args: P.args, **kwargs: P.kwargs):
        attrs = attrs or (getattr(cls, __NAME__, None), )
        return tuple(cls.__make_astr__(
            getattr(cls, __NAME__, attr), *args, **kwargs, 
            attr=attr) for attr in attrs
        )
    
    def __make_or_call__(cls, *args: P.args, **kwargs: P.kwargs):
        len0 = len(args) == 0
        arg0 = (args if len0 else args[0])
        # no args, create a single attribute using the class __name__ as the attribute name
        if len0:
            return cls.__make_astrs__(*args, **kwargs)
        
        # if here, then there are arguments
        elif allstrs(args):
            # args are all strings (e.g. names of attributes), make many attributes
            attrs = cls.__make_astrs__(attrs=args, **kwargs)
            return attrs[0] if len(attrs) == 1 else attrs
        
        elif istuple(arg0) and allstrs(arg0) and allstrs(args[1:]):
            # args0 is a tuple of all strings (e.g. names of attributes) so
            # args is something like: (('attr1', ...), 'attr2', 'attr3', ...)
            return cls.__make_or_call__(*arg0, *args[1:], **kwargs)
        
        elif istuple(arg0) and allstrs(arg0) and len(arg0) == 1:
            return cls.__make_or_call__(*arg0, *args[1:], **kwargs)
        
        elif istuple(arg0) and allstrs(arg0):
            # args0 is a tuple of all strings (e.g. names of attributes)
            attrs = cls.__make_astrs__(attrs=arg0, *args[1:], **kwargs)
            return attrs[0] if len(attrs) == 1 else attrs
        
        else:
            # called with arguments, but not all are strings, use the classes __call__ method
            return cls.__call__(cls, *args, **kwargs)
        return cls.__make_astrs__(*args, **kwargs)
    
    
    def __deco__(cls, **kwargs: P.kwargs):
        def decorator(sub: type):
            return cls.__make_astr__(sub.__name__, bases=(cls, ), **kwargs)
        return decorator
    
    @wraps(insattr)
    def get(cls, obj: object) -> Union[Any, bool, object]:
        '''Get the attribute specified by the this class from the object.'''
        if DOT in cls.attr: 
            return cls.dot(obj, rethas = False)
        return insattr(obj, rethas = False, **cls.getvars())
    
    @wraps(insattr)
    def has(cls, obj: object) -> TypeGuard[bool]:
        '''Returns whether the object has the attribute specified by the this class.'''
        if DOT in cls.attr: return cls.dot(obj, rethas=True)
        return insattr(obj, rethas=True, **cls.getvars())
    
    def set(cls, obj: object, val: Any) -> Type[Self]:
        '''Set the attribute specified by the this class on the object to the value `val`.'''
        setattr(obj, cls.attr, val)
        return cls
    
    def dot(cls, obj: object, **kwargs:P.kwargs):
        '''Returns get(...) --> get(...) --> ... --> get / has for a dotted attribute name e.g. `attr1.attr2.attr3`.'''
        names = getattr(cls, ATTR, NIL).split(DOT)
        return cls.chain(obj, *names, **kwargs)
    
    def chain(cls, obj: object, *names: P.args, **kwargs: P.kwargs):
        '''Returns chain cls.get until for each attribute in *names until the end, then call get / has 
        for a dotted attribute name e.g. `attr1.attr2.attr3`.'''
        kwds = cls.getvars(**kwargs)
        rethas = kwargs.get(RETHAS, False)
        for i, name in enumerate(names):
            cur = dict(attr=name, rethas=False, retself=True)
            for key in ('guard', 'guardobj'):
                val = kwds.get(key, None)
                if not isiter(val):
                    kwds[key] = notnone
                elif isiter(val) and i >= len(val):
                    kwds[key] = notnone
                elif isiter(val) and i < len(val):
                    cur[key] = val[i]
                    
            kws = {**kwds, **cur}
            if i == len(names) - 1: 
                kws.update(rethas = rethas)
            obj = insattr(obj, **kws)
        return obj
    
    def __repr__(cls) -> str:
        return f'{cls.__name__}({cls.attr})'
    
    def __str__(cls) -> str:
        return f'{cls.__name__}({cls.attr})'

# %% ../nbs/00_core.ipynb 26
class astr(metaclass=astrmeta):
    '''Provides a flexible and powerful interface for getting, setting, and checking if an object has a specific attribute.
    
    Instances of `astr` (or subclasses thereof) represent specific attributes and encapsulate logic for accessing, setting, and 
    verifying the presence of these attributes on objects. This enables expressive and concise attribute manipulation and 
    introspection. `astr` classes support creating attribute-specific behavior directly or through decoration, offering a 
    versatile tool for object attribute management.

    Attributes
    ----------
    attr : str
        The name of the attribute to get, set, or check on an object.
        
    check : bool
        Indicates whether to check the type of the attribute upon retrieval.
        
    guard : GuardLike, optional
        A callable used as a type guard for the retrieved attribute.
        
    checkobj : bool, optional
        Indicates whether to check the type of the object before attribute manipulation.
        
    guardobj : GuardLike, optional
        A callable used as a type guard for the object before attribute manipulation.
        
    retself : bool
        Determines whether to return the original object if the attribute fails the type guard check.
        
    default : Any
        The default value to return if the attribute is not found or fails the type guard check.
    
    Notes
    -----
    `astr` can be subclassed to create attribute-specific classes that include logic for getting, 
    setting, and checking attributes on objects. It supports dot notation for nested attributes and 
    can be used directly or as a decorator to enhance classes with attribute-specific logic.
    
    Examples
    --------
    >>> class foo(attr):
    ...    attr = 'foo'
    
    >>> class bar(attr):
    ...    attr = 'bar'
    
    >>> # Decorator usage to enhance a class with attribute-specific logic
    ... @attr.deco(check=False)
    ... class quz: ...
    '''
    attr: ClassVar[str]
    '''The name of the attribute to get / set / or check if an object has.'''
    
    check: ClassVar[bool] = True
    '''Whether to check the type of the attribute, by default True.'''
    
    guard: ClassVar[Optional[GuardLike]] = notnone
    '''The guard to check the type of the retrieved attribute, by default `notnone`.'''
    
    checkobj: ClassVar[Optional[bool]] = True
    '''The guard to check the type of the object, by default None.'''
    
    guardobj: ClassVar[Optional[GuardLike]] = notnone
    '''The guard to check the type of the object, by default `notnone`.'''
    
    retself: ClassVar[bool] = True
    '''Whether to return the object if the attribute fails the guard, otherwise the default value is returned, by default False.'''
    
    default: ClassVar[Any] = None
    '''The default value to return if the attribute is not found, by default None.'''
    
    clsvars: tuple[str, ...] = CLASSVARS
    '''The tuple of class variable names.'''
    
    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        if args: return cls.many(*args, **kwargs)
        if kwargs: return cls.deco(**kwargs)
        new = super().__new__(cls)
        return new
    
    def __call__(self, obj: object, *args: P.args, **kwargs: P.kwargs) -> object:
        return self.get(obj) if kwargs.get(GET, True) else self.has(obj)
    
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()
        # NOTE: likely unneeded as it is called in __new__
        cls.setvars(**kwargs)
        
    @classmethod
    @abstractmethod
    def __guard__(cls, ins: object) -> TypeGuard[Type[Self]]:
        '''Checks if the instance `ins` has the attribute `cls.attr`.'''
        return cls.has(ins, )
    
    @classmethod
    def many(
        cls, attrs: tuple[str, ...] = tuple(), 
        *args: P.args, **kwargs: P.kwargs
    ) -> (tuple[type[Self], ...] | type[Self]):
        if isinstance(attrs, str): attrs = tuple((attrs, ))
        attrs: tuple['astr', ...] = cls.__make_or_call__(attrs, *args, **kwargs)
        if istuple(attrs) and len(attrs) == 1: return attrs[0]
        return attrs
    
    @classmethod
    def deco(cls: Type[Self], **kwargs: P.kwargs) -> Type[Self]:
        return cls.__deco__(**kwargs)

# %% ../nbs/00_core.ipynb 28
@wraps(astr, assigned=ASSIGNED, updated=()) 
class attr(astr):
    '''An alias for the `astr` class.
    
    See Also
    --------
    astr : A class for getting, setting and checking if an object has an attribute.
    '''
    
@wraps(astr, assigned=ASSIGNED, updated=()) 
class attrstr(astr):
    '''An alias for the `astr` class.
    
    See Also
    --------
    astr : A class for getting, setting and checking if an object has an attribute.
    '''
