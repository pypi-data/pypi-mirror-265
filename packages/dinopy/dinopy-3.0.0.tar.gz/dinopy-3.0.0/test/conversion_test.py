# -*- coding: utf-8 -*-
import unittest
from array import array

import numpy as np

from dinopy import basenumbers
from dinopy import conversion as cnv


class ByteToConversionTest(unittest.TestCase):
    def test_bytes_to_basenumbers(self):
        """Is the correct sequence generated by byte_to_basenumber?"""
        byteseq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv".encode("utf-8")
        expected_basenumber_seq = bytes(
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
             15])
        computed_basenumber_seq = cnv.bytes_to_basenumbers(byteseq)
        self.assertEqual(expected_basenumber_seq, computed_basenumber_seq)

    def test_bytes_to_basenumbers_suppressed(self):
        """Is the correct sequence generated by byte_to_basenumber?"""
        byteseq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv".encode("utf-8")
        expected_basenumber_seq = bytes(
            [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4])
        computed_basenumber_seq = cnv.bytes_to_basenumbers(byteseq, suppress_iupac=True)
        self.assertEqual(expected_basenumber_seq, computed_basenumber_seq)

    def test_bytes_to_basenumbers_error_handling(self):
        """Is a KeyError raised for non-DNA Characters?"""
        test_bytes = "ACGTNacFgtn".encode("utf-8")
        with self.assertRaises(KeyError):
            cnv.bytes_to_basenumbers(test_bytes)

    def test_bytes_to_string(self):
        """Is the correct sequence generated by byte_to_basenumber?"""
        byteseq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv".encode("utf-8")
        expected_str = "ACGTNURYMKWSBDHVACGTNURYMKWSBDHV"
        computed_str = cnv.bytes_to_string(byteseq)
        self.assertEqual(expected_str, computed_str)

    def test_bytes_to_string_error_handling(self):
        """Is a KeyError raised for non-DNA Characters?"""
        test_bytes = "ACGTNacFgtn".encode("utf-8")
        with self.assertRaises(KeyError):
            cnv.bytes_to_string(test_bytes)


class StringToConversionTest(unittest.TestCase):
    def test_string_to_basenumbers(self):
        """Are strings correctly converted to basenumbers?"""
        seq = "ACGT"
        expected_seq = bytes([0, 1, 2, 3])
        computed_seq = cnv.string_to_basenumbers(seq)
        np.testing.assert_array_equal(expected_seq, computed_seq)
        seq = "ACGTN"
        expected_seq = bytes([0, 1, 2, 3, 4])
        computed_seq = cnv.string_to_basenumbers(seq)
        np.testing.assert_array_equal(expected_seq, computed_seq)
        seq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv"
        expected_seq = bytes(
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
             15])
        computed_seq = cnv.string_to_basenumbers(seq)
        np.testing.assert_array_equal(expected_seq, computed_seq)

    def test_string_to_basenumbers_error_handling(self):
        """Are errors handled correctly when converting str -> basenumbers?"""
        with self.assertRaises(TypeError):
            seq = 42  # wrong type
            cnv.string_to_basenumbers(seq)
        with self.assertRaises(KeyError):
            seq = "foobar"  # non IUPAC-chars
            cnv.string_to_basenumbers(seq)

    def test_string_to_basenumbers_suppressed(self):
        """Are strings correctly converted to basenumbers
        (suppressing IUPAC chars to N)?"""
        seq = "ACGT"
        expected_seq = bytes([0, 1, 2, 3])
        computed_seq = cnv.string_to_basenumbers(seq, suppress_iupac=True)
        np.testing.assert_array_equal(expected_seq, computed_seq)
        seq = "ACGTN"
        expected_seq = bytes([0, 1, 2, 3, 4])
        computed_seq = cnv.string_to_basenumbers(seq, suppress_iupac=True)
        np.testing.assert_array_equal(expected_seq, computed_seq)
        seq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv"
        expected_seq = bytes(
            [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4])
        computed_seq = cnv.string_to_basenumbers(seq, suppress_iupac=True)
        np.testing.assert_array_equal(expected_seq, computed_seq)

    def test_string_to_basenumbers_suppressed_error_handling(self):
        """Are errors handled correctly when converting str -> basenumbers (suppressed)?"""
        with self.assertRaises(TypeError):
            seq = 42  # wrong type
            cnv.string_to_basenumbers(seq, suppress_iupac=True)
        with self.assertRaises(KeyError):
            seq = "foobar"  # non IUPAC-chars
            cnv.string_to_basenumbers(seq, suppress_iupac=True)

    def test_string_to_basenumbers_list(self):
        """Are lists of unicode string qgrams correctly converted to basenumbers?"""
        seqs = [
            "ACGT",
            "ACGTN",
            "ACGTNURYMKWSBDHVacgtnurymkwsbdhv",
        ]
        expected_seqs = [
            bytes([0, 1, 2, 3]),
            bytes([0, 1, 2, 3, 4]),
            bytes(
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                 15]),
        ]

        computed_seqs = cnv.string_list_to_basenumbers(seqs)

        for exp_seq, comp_seq in zip(expected_seqs, computed_seqs):
            np.testing.assert_array_equal(exp_seq, comp_seq)

        expected_seqs_suppressed = [
            bytes([0, 1, 2, 3]),
            bytes([0, 1, 2, 3, 4]),
            bytes([0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]),
        ]

        computed_seqs_suppressed = cnv.string_list_to_basenumbers(seqs, suppress_iupac=True)

        for exp_seq, comp_seq in zip(expected_seqs_suppressed, computed_seqs_suppressed):
            np.testing.assert_array_equal(exp_seq, comp_seq)

    def test_string_to_basenumbers_list_error_handling(self):
        """Are errors handled correctly when converting [str] -> basenrs?"""
        with self.assertRaises(TypeError):
            seqs = 42  # wrong type
            cnv.string_list_to_basenumbers(seqs)
        with self.assertRaises(TypeError):
            seqs = "ACGT"  # not a list
            cnv.string_list_to_basenumbers(seqs)
        with self.assertRaises(KeyError):
            seqs = ["foobar"]  # non IUPAC-chars
            cnv.string_list_to_basenumbers(seqs)

    def test_string_sublists_to_basenumbers(self):
        """Are lists of lists of unicode string qgrams correctly converted to basenumbers?"""
        seqs = [
            ["ACGT"],
            ["ACGTN", "ACGTNURYMKWSBDHVacgtnurymkwsbdhv"],
        ]
        expected_seqs = [
            [bytes([0, 1, 2, 3])],
            [bytes([0, 1, 2, 3, 4]),
             bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5,
                    6, 7, 8, 9, 10, 11, 12, 13, 14, 15])],
        ]

        computed_seqs = cnv.string_sublists_to_basenumbers(seqs)

        for exp_list, comp_list in zip(expected_seqs, computed_seqs):
            for exp_seq, comp_seq in zip(exp_list, comp_list):
                np.testing.assert_array_equal(exp_seq, comp_seq)

        expected_seqs_suppressed = [
            [bytes([0, 1, 2, 3])],
            [bytes([0, 1, 2, 3, 4]),
             bytes([0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4,
                    4, 4, 4, 4, 4, 4, 4, 4])],
        ]

        computed_seqs_suppressed = cnv.string_sublists_to_basenumbers(seqs, suppress_iupac=True)

        for exp_list, comp_list in zip(expected_seqs_suppressed, computed_seqs_suppressed):
            for exp_seq, comp_seq in zip(exp_list, comp_list):
                np.testing.assert_array_equal(exp_seq, comp_seq)

    def test_string_sublists_to_basenumbers_error_handling(self):
        """Are errors handled correctly when converting [[str],...] -> basenrs?"""
        with self.assertRaises(TypeError):
            seqs = 42  # wrong type
            cnv.string_sublists_to_basenumbers(seqs)
        with self.assertRaises(TypeError):
            seqs = "ACGT"  # not a nested list
            cnv.string_sublists_to_basenumbers(seqs)
        with self.assertRaises(TypeError):
            seqs = ["ACGT"]  # not a nested list
            cnv.string_sublists_to_basenumbers(seqs)
        with self.assertRaises(KeyError):
            seqs = [["foobar"]]  # non IUPAC chars
            cnv.string_sublists_to_basenumbers(seqs)

    def test_string_to_bytes(self):
        seq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv"
        expected_bytes = "ACGTNURYMKWSBDHVACGTNURYMKWSBDHV".encode("utf-8")
        computed_bytes = cnv.string_to_bytes(seq)
        np.testing.assert_array_equal(expected_bytes, computed_bytes)

    def test_string_to_bytes_suppressed(self):
        seq = "ACGTNURYMKWSBDHVacgtnurymkwsbdhv"
        expected_bytes = "ACGTNNNNNNNNNNNNACGTNNNNNNNNNNNN".encode("utf-8")
        computed_bytes = cnv.string_to_bytes(seq, suppress_iupac=True)
        np.testing.assert_array_equal(expected_bytes, computed_bytes)

    def test_string_to_bytes_error_handling(self):
        """Are errors handled correctly when converting str -> bytes?"""
        with self.assertRaises(TypeError):
            seq = 42
            cnv.string_to_bytes(seq)
        with self.assertRaises(KeyError):
            seq = "foobar"
            cnv.string_to_bytes(seq)


class BasenumbersToConversionTest(unittest.TestCase):
    def test_basenumbers_to_string(self):
        """Are basenumbers correctly translated to unicode strings?"""
        basenumbers = bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                             12, 13, 14, 15])
        expected_str = "ACGTNURYMKWSBDHVACGTNURYMKWSBDHV"
        expected_list = ["A", "C", "G", "T", "N", "U", "R", "Y", "M", "K", "W", "S", "B", "D", "H", "V", "A", "C", "G",
                         "T", "N", "U", "R", "Y", "M", "K", "W", "S", "B", "D", "H", "V"]
        self.assertEqual(expected_str, cnv.basenumbers_to_string(basenumbers))
        self.assertEqual(expected_list, cnv.basenumbers_to_string(basenumbers, as_list=True))

    def test_basenumbers_to_string_error_handling(self):
        """Are errors handled correctly when converting basenrs -> string?"""
        with self.assertRaises(TypeError):
            seq = 42  # wrong type
            cnv.basenumbers_to_string(seq)
        with self.assertRaises(KeyError):
            seq = [0, 1, 2, 3, 4, 42]  # non basenumber char
            cnv.basenumbers_to_string(seq)
        with self.assertRaises(KeyError):
            # sequence of the wrong type
            # -> bad lookup in conversion dict
            seq = "foobar"
            cnv.basenumbers_to_string(seq)

    def test_basenumbers_to_bytes(self):
        """Are basenumbers correctly translated to bytes?"""
        basenumbers = bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                             12, 13, 14, 15])
        expected_bytes = array('B', "ACGTNURYMKWSBDHVACGTNURYMKWSBDHV".encode("utf-8"))
        np.testing.assert_array_equal(expected_bytes, list(cnv.basenumbers_to_bytes(basenumbers)))

    def test_basenumbers_to_bytes_error_handling(self):
        """Are errors handled correctly when converting basenrs -> string?"""
        with self.assertRaises(TypeError):
            seq = 42  # wrong type
            cnv.basenumbers_to_bytes(seq)
        with self.assertRaises(KeyError):
            seq = bytes([0, 1, 2, 3, 4, 42])  # non basenumber char
            cnv.basenumbers_to_bytes(seq)
        with self.assertRaises(KeyError):
            # sequence of the wrong type
            # -> bad lookup in conversion dict
            seq = "foobar"
            cnv.basenumbers_to_bytes(seq)


class EncodeLineTest(unittest.TestCase):
    def test_encode_line_as_bytes(self):
        """Are byte lines correctly encoded as bytes?"""
        line = bytearray([65, 67, 71, 84, 78])
        expected_bytes_line = bytes([65, 67, 71, 84, 78])
        bytes_line = cnv._test_encode_line(line, bytes)
        np.testing.assert_array_equal(bytes_line, expected_bytes_line)

    def test_encode_line_as_basenumbers(self):
        """Are byte lines correctly encoded as basenumbers?"""
        line = bytearray([65, 67, 71, 84, 78])
        expected_basenumbers_line = bytes([0, 1, 2, 3, 4])
        basenumbers_line = cnv._test_encode_line(line, basenumbers)
        self.assertEqual(basenumbers_line, expected_basenumbers_line)

    def test_encode_line_as_string(self):
        """Are byte lines correctly encoded as strings?"""
        line = bytearray([65, 67, 71, 84, 78])
        expected_str_line = "ACGTN"
        str_line = cnv._test_encode_line(line, str)
        self.assertEqual(str_line, expected_str_line)


class EncodeTest(unittest.TestCase):

    def test_encode_2bit(self):
        """Are qgrams encoded correctly using the encode 2bit function?"""
        seqs = [
            "A",
            "C",
            "G",
            "T",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",  # "00000000000000000000000000000000000000000000000000000000000000"
            "ACGTACGTACGTACGTACGTACGTACGTACG",  # "00011011000110110001101100011011000110110001101100011011000110"
        ]
        expected_qgrams = [
            0,
            1,
            2,
            3,
            0,
            488296166657017542,
        ]
        for exp_qgram, seq in zip(expected_qgrams, seqs):
            self.assertEqual(exp_qgram, cnv.encode_twobit(seq))

    def test_encode_4bit(self):
        """Are qgrams encoded correctly using the encode 4bit function?"""
        seqs = [
            "A",
            "C",
            "G",
            "T",
            "AAAAAAAAAAAAAAA",
            "ACGTNRYMKWSBDHV",
        ]
        expected_qgrams = [
            0b0001,
            0b0010,
            0b0100,
            0b1000,
            0b000100010001000100010001000100010001000100010001000100010001,
            0b000100100100100011110101101000111100100101101110110110110111,
        ]
        for exp_qgram, seq in zip(expected_qgrams, seqs):
            self.assertEqual(exp_qgram, cnv.encode_fourbit(seq))

    def test_get_inverse_codemap_from_twobit(self):
        map_str = cnv.get_inverse_codemap_from_twobit(str)
        map_bytes = cnv.get_inverse_codemap_from_twobit(bytes)
        map_bytearray = cnv.get_inverse_codemap_from_twobit(bytearray)
        map_basenumbers = cnv.get_inverse_codemap_from_twobit(basenumbers)
        self.assertDictEqual(map_str, {0: 'A', 1: 'C', 2: 'G', 3: 'T'})
        self.assertDictEqual(map_bytes, {0: 65, 1: 67, 2: 71, 3: 84})
        self.assertDictEqual(map_bytearray, {0: 65, 1: 67, 2: 71, 3: 84})
        self.assertDictEqual(map_basenumbers, {0: 0, 1: 1, 2: 2, 3: 3})


class DecodeTest(unittest.TestCase):

    def test_decode_2bit_str(self):
        """Are 2bit encoded qgrams decoded correctly to all dtypes?"""
        qgrams = [
            (0, 1),
            (1, 1),
            (2, 1),
            (3, 1),
            (0, 31),
            (488296166657017542, 31)
        ]
        expected_seqs_str = [
            "A",
            "C",
            "G",
            "T",
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "ACGTACGTACGTACGTACGTACGTACGTACG",
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_str, qgrams):
            self.assertEqual(exp_seq, cnv.decode_twobit(qgram, length, dtype=str))

        expected_seqs_bytes = [
            b"A",
            b"C",
            b"G",
            b"T",
            b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            b"ACGTACGTACGTACGTACGTACGTACGTACG",
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_bytes, qgrams):
            self.assertEqual(exp_seq, cnv.decode_twobit(qgram, length, dtype=bytes))

        expected_seqs_bytearray = [
            bytearray(b"A"),
            bytearray(b"C"),
            bytearray(b"G"),
            bytearray(b"T"),
            bytearray(b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"),
            bytearray(b"ACGTACGTACGTACGTACGTACGTACGTACG"),
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_bytearray, qgrams):
            self.assertEqual(exp_seq, cnv.decode_twobit(qgram, length, dtype=bytearray))

        expected_seqs_basenumbers = [
            bytes([0]),
            bytes([1]),
            bytes([2]),
            bytes([3]),
            bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]),
            bytes([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, ]),
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_basenumbers, qgrams):
            self.assertEqual(exp_seq, cnv.decode_twobit(qgram, length, dtype=basenumbers))

    def test_decode_4bit_str(self):
        """Are 4bit encoded qgrams decoded correctly to all dtypes?"""
        qgrams = [
            (0b0001, 1),
            (0b0010, 1),
            (0b0100, 1),
            (0b1000, 1),
            (0b000100010001000100010001000100010001000100010001000100010001, 15),
            (0b000100100100100011110101101000111100100101101110110110110111, 15),
        ]
        expected_seqs_str = [
            "A",
            "C",
            "G",
            "T",
            "AAAAAAAAAAAAAAA",
            "ACGTNRYMKWSBDHV",
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_str, qgrams):
            self.assertEqual(exp_seq, cnv.decode_fourbit(qgram, length, dtype=str))

        expected_seqs_bytes = [
            b"A",
            b"C",
            b"G",
            b"T",
            b"AAAAAAAAAAAAAAA",
            b"ACGTNRYMKWSBDHV",
            b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            b"ACGTACGTACGTACGTACGTACGTACGTACG",
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_bytes, qgrams):
            self.assertEqual(exp_seq, cnv.decode_fourbit(qgram, length, dtype=bytes))

        expected_seqs_bytearray = [
            bytearray(b"A"),
            bytearray(b"C"),
            bytearray(b"G"),
            bytearray(b"T"),
            bytearray(b"AAAAAAAAAAAAAAA"),
            bytearray(b"ACGTNRYMKWSBDHV"),
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_bytearray, qgrams):
            self.assertEqual(exp_seq, cnv.decode_fourbit(qgram, length, dtype=bytearray))

        expected_seqs_basenumbers = [
            bytes([1]),
            bytes([2]),
            bytes([4]),
            bytes([8]),
            bytes([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ]),
            bytes([1, 2, 4, 8, 15, 5, 10, 3, 12, 9, 6, 14, 13, 11, 7, ]),
        ]
        for exp_seq, (qgram, length) in zip(expected_seqs_basenumbers, qgrams):
            self.assertEqual(exp_seq, cnv.decode_fourbit(qgram, length, dtype=basenumbers))

    def test_decode(self):
        self.assertEqual(cnv.decode(0b00011011, 4, cnv.get_inverse_codemap_from_twobit(str)), ['A', 'C', 'G', 'T'])
        self.assertEqual(cnv.decode(0b00011011, 4, cnv.get_inverse_codemap_from_twobit(bytes)), list(b"ACGT"))
        self.assertEqual(cnv.decode(0b00011011, 4, cnv.get_inverse_codemap_from_twobit(basenumbers)), [0, 1, 2, 3])


class PHREDConversionTest(unittest.TestCase):
    """
                - 'Sanger'                   (ASCII 33-73)  PHRED   0-40
                - 'Solexa, Illumina <=1.2'   (ASCII 59-104) Solexa -5-40
                - 'Illumina 1.3+'            (ASCII 64-104) PHRED   0-40
                - 'Illumina 1.5+'            (ASCII 66-104) PHRED   3-40
                - 'Illumina 1.8+'            (ASCII 33-74)  PHRED   0-41
    """

    def test_PHRED_to_sanger(self):
        """Are PHRED-QS translated to sanger-QVs correctly?"""
        phred_values = range(0, 41)
        sanger_values = cnv.phred_to_sanger(phred_values)
        expected_sanger_values = bytes(range(33, 74))
        np.testing.assert_array_equal(sanger_values, expected_sanger_values)

    def test_PHRED_to_solexa(self):
        """Are PHRED-QS translated to solexa-QVs correctly?"""
        phred_values = range(-5, 41)
        solexa_values = cnv.phred_to_solexa(phred_values)
        expected_solexa_values = bytes(range(59, 105))
        np.testing.assert_array_equal(solexa_values, expected_solexa_values)

    def test_PHRED_to_illumina13(self):
        """Are PHRED-QS translated to illumina1.3-QVs correctly?"""
        phred_values = range(0, 41)
        illumina13_values = cnv.phred_to_illumina13(phred_values)
        expected_illumina13_values = bytes(range(64, 105))
        np.testing.assert_array_equal(illumina13_values, expected_illumina13_values)

    def test_PHRED_to_illumina15(self):
        """Are PHRED-QS translated to illumina1.5-QVs correctly?"""
        phred_values = range(0, 41)
        illumina15_values = cnv.phred_to_illumina15(phred_values)
        expected_illumina15_values = bytes(range(64, 105))
        np.testing.assert_array_equal(illumina15_values, expected_illumina15_values)

    def test_PHRED_to_illumina18(self):
        """Are PHRED-QS translated to illumina1.8-QVs correctly?"""
        phred_values = range(0, 42)
        illumina18_values = cnv.phred_to_illumina18(phred_values)
        expected_illumina18_values = bytes(range(33, 75))
        np.testing.assert_array_equal(illumina18_values, expected_illumina18_values)

    def test_sanger_to_PHRED(self):
        """Are sanger-QVs translated to PHRED-QS correctly?"""
        sanger_values = bytes(range(33, 74))
        phred_values = cnv.sanger_to_phred(sanger_values)
        expected_phred_values = range(0, 41)
        np.testing.assert_array_equal(phred_values, expected_phred_values)

    def test_solexa_to_PHRED(self):
        """Are solexa-QVs translated to PHRED-QS correctly?"""
        solexa_values = bytes(range(59, 105))
        phred_values = cnv.solexa_to_phred(solexa_values)
        expected_phred_values = range(-5, 41)
        np.testing.assert_array_equal(phred_values, expected_phred_values)

    def test_illumina13_to_PHRED(self):
        """Are illumina1.3-QVs translated to PHRED-QS correctly?"""
        illumina13_range = bytes(range(64, 105))
        phred_values = cnv.illumina13_to_phred(illumina13_range)
        expected_phred_values = range(0, 41)
        np.testing.assert_array_equal(phred_values, expected_phred_values)

    def test_illumina15_to_PHRED(self):
        """Are illumina1.5-QVs translated to PHRED-QS correctly?"""
        illumina15_range = bytes(range(64, 105))
        phred_values = cnv.illumina15_to_phred(illumina15_range)
        expected_phred_values = range(0, 41)
        np.testing.assert_array_equal(phred_values, expected_phred_values)

    def test_illumina18_to_PHRED(self):
        """Are illumina1.8-QVs translated to PHRED-QS correctly?"""
        illumina18_range = bytes(range(33, 75))
        phred_values = cnv.illumina18_to_phred(illumina18_range)
        expected_phred_values = range(0, 42)
        np.testing.assert_array_equal(phred_values, expected_phred_values)
